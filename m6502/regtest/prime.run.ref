Simulating file prime.asm starting at line 9
> [1]     9 0200: prime:	lda #2
> [2] a: 00 p: 00 pc: 0200 sp: FF x: 00 y: 00 
> [ 1]    38 0243: done:	rts
> ---
[1]     9 0200: prime:	lda #2
[2] a: 00 p: 00 pc: 0200 sp: FF x: 00 y: 00 
---
[1]    10 0202: 	sta pstore
[2] a: 02 p: 00 pc: 0202 sp: FF x: 00 y: 00 
---
[1]    11 0205: 	lda #3
[2] a: 02 p: 00 pc: 0205 sp: FF x: 00 y: 00 
---
[1]    12 0207: 	sta pstore + 1		;  seed array with first 2 primes
[2] a: 03 p: 00 pc: 0207 sp: FF x: 00 y: 00 
---
[1]    13 020A: 	lda #5
[2] a: 03 p: 00 pc: 020A sp: FF x: 00 y: 00 
---
[1]    14 020C: 	sta pstore + 2		; last array value test prime
[2] a: 05 p: 00 pc: 020C sp: FF x: 00 y: 00 
---
[1]    15 020F: 	ldx #2			; number of primes and index of test prime
[2] a: 05 p: 00 pc: 020F sp: FF x: 00 y: 00 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 05 p: 00 pc: 0211 sp: FF x: 02 y: 00 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 00 pc: 0213 sp: FF x: 02 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 05 p: 00 pc: 0216 sp: FF x: 02 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 05 p: 00 pc: 0218 sp: FF x: 02 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 00 pc: 021B sp: FF x: 02 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 00 pc: 021D sp: FF x: 02 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 00 pc: 0244 sp: FD x: 02 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 00 pc: 0246 sp: FD x: 02 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 00 pc: 0248 sp: FD x: 02 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 02 pc: 024A sp: FD x: 02 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 02 pc: 024C sp: FD x: 02 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 00 pc: 024E sp: FD x: 02 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 02 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 02 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 02 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 02 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 02 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 00 pc: 0250 sp: FD x: 02 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 06 p: 00 pc: 0257 sp: FD x: 02 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 02 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 02 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 02 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 02 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 02 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 02 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 02 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 02 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 02 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 02 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 02 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 02 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 02 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 02 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 02 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 01 p: 00 pc: 026A sp: FD x: 02 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 00 pc: 026C sp: FD x: 02 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 02 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 02 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 02 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 02 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 02 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 02 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 02 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 00 pc: 0229 sp: FF x: 02 y: 01 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 03 p: 00 pc: 022E sp: FF x: 02 y: 01 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 05 p: 00 pc: 0231 sp: FF x: 02 y: 01 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 05 p: 00 pc: 0232 sp: FF x: 03 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 05 p: 00 pc: 0235 sp: FF x: 03 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 05 p: 00 pc: 0238 sp: FF x: 03 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 05 p: 00 pc: 023B sp: FF x: 03 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 07 p: 00 pc: 023E sp: FF x: 03 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 07 p: 81 pc: 0240 sp: FF x: 03 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 07 p: 81 pc: 0211 sp: FF x: 03 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 03 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 07 p: 01 pc: 0216 sp: FF x: 03 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 07 p: 01 pc: 0218 sp: FF x: 03 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 03 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 03 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 03 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 03 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 03 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 03 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 03 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 03 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 03 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 03 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 03 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 03 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 03 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 03 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 03 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 03 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 03 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 03 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 00 pc: 0250 sp: FD x: 03 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 0C p: 00 pc: 0257 sp: FD x: 03 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 03 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 03 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 03 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 03 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 03 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 03 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 03 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 03 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 03 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 03 y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 03 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 03 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 03 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 03 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 03 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 02 p: 00 pc: 026A sp: FD x: 03 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 02 p: 00 pc: 026C sp: FD x: 03 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 02 p: 00 pc: 026E sp: FD x: 03 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 02 p: 00 pc: 0270 sp: FD x: 03 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 02 p: 00 pc: 0259 sp: FD x: 03 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 03 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 03 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 03 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 03 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 03 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 03 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 03 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 03 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 03 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 03 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 00 pc: 0229 sp: FF x: 03 y: 01 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 03 p: 00 pc: 022E sp: FF x: 03 y: 01 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 07 p: 00 pc: 0231 sp: FF x: 03 y: 01 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 07 p: 00 pc: 0232 sp: FF x: 04 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 07 p: 00 pc: 0235 sp: FF x: 04 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 07 p: 00 pc: 0238 sp: FF x: 04 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 07 p: 00 pc: 023B sp: FF x: 04 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 09 p: 00 pc: 023E sp: FF x: 04 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 09 p: 81 pc: 0240 sp: FF x: 04 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 09 p: 81 pc: 0211 sp: FF x: 04 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 09 p: 01 pc: 0213 sp: FF x: 04 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 09 p: 01 pc: 0216 sp: FF x: 04 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 09 p: 01 pc: 0218 sp: FF x: 04 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 04 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 04 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 04 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 04 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 04 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 04 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 04 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 04 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 04 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 04 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 04 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 04 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 04 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 04 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 04 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 04 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 04 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 04 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 00 pc: 0250 sp: FD x: 04 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 0C p: 00 pc: 0257 sp: FD x: 04 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 04 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 04 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 04 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 04 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 04 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 04 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 04 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 04 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 04 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 04 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 04 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 04 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 04 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 04 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 04 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 02 p: 00 pc: 026A sp: FD x: 04 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 02 p: 00 pc: 026C sp: FD x: 04 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 02 p: 00 pc: 026E sp: FD x: 04 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 02 p: 00 pc: 0270 sp: FD x: 04 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 02 p: 00 pc: 0259 sp: FD x: 04 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 04 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 04 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 04 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 04 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 04 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 04 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 04 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 02 p: 00 pc: 0268 sp: FD x: 04 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 03 p: 00 pc: 026A sp: FD x: 04 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 00 pc: 026C sp: FD x: 04 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 04 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 04 y: 01 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 04 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 04 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 04 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 04 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 04 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 04 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 0B p: 01 pc: 023E sp: FF x: 04 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 0B p: 81 pc: 0240 sp: FF x: 04 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 0B p: 81 pc: 0211 sp: FF x: 04 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 04 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 0B p: 01 pc: 0216 sp: FF x: 04 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 0B p: 01 pc: 0218 sp: FF x: 04 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 04 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 04 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 04 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 04 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 04 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 04 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 04 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 04 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 04 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 04 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 04 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 04 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 04 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 04 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 04 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 04 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 04 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 04 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 00 pc: 0250 sp: FD x: 04 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 0C p: 00 pc: 0257 sp: FD x: 04 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 04 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 04 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 04 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 04 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 04 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 04 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 04 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 04 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 04 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 04 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 04 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 04 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 04 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 04 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 04 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 02 p: 00 pc: 026A sp: FD x: 04 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 02 p: 00 pc: 026C sp: FD x: 04 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 02 p: 00 pc: 026E sp: FD x: 04 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 02 p: 00 pc: 0270 sp: FD x: 04 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 02 p: 00 pc: 0259 sp: FD x: 04 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 04 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 04 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 04 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 04 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 04 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 04 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 04 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 02 p: 00 pc: 0268 sp: FD x: 04 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 03 p: 00 pc: 026A sp: FD x: 04 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 00 pc: 026C sp: FD x: 04 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 04 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 04 y: 01 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 04 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 04 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 04 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 04 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 04 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 02 pc: 0229 sp: FF x: 04 y: 01 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 03 p: 02 pc: 022E sp: FF x: 04 y: 01 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 0B p: 00 pc: 0231 sp: FF x: 04 y: 01 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 0B p: 00 pc: 0232 sp: FF x: 05 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 0B p: 00 pc: 0235 sp: FF x: 05 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 0B p: 00 pc: 0238 sp: FF x: 05 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 0B p: 00 pc: 023B sp: FF x: 05 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 0D p: 00 pc: 023E sp: FF x: 05 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 0D p: 81 pc: 0240 sp: FF x: 05 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 0D p: 81 pc: 0211 sp: FF x: 05 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 05 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 0D p: 01 pc: 0216 sp: FF x: 05 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 0D p: 01 pc: 0218 sp: FF x: 05 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 05 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 05 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 05 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 05 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 05 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 05 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 05 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 05 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 05 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 05 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 05 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 05 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 05 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 05 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 05 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 05 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 05 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 05 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 05 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 05 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 05 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 05 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 05 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 00 pc: 0250 sp: FD x: 05 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 18 p: 00 pc: 0257 sp: FD x: 05 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 05 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 05 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 05 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 05 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 05 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 05 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 05 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 05 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 05 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 05 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 05 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 05 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 05 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 05 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 05 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 05 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 05 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 05 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 05 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 05 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 05 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 05 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 05 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 05 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 05 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 05 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 05 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 05 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 05 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 05 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 05 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 05 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 05 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 05 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 05 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 05 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 05 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 05 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 05 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 05 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 0D p: 01 pc: 0216 sp: FF x: 05 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 0D p: 01 pc: 0218 sp: FF x: 05 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 05 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 05 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 05 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 05 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 05 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 05 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 05 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 05 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 05 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 05 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 05 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 05 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 05 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 05 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 05 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 05 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 05 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 05 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 00 pc: 0250 sp: FD x: 05 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 14 p: 00 pc: 0257 sp: FD x: 05 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 05 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 05 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 05 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 05 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 05 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 05 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 05 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 05 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 05 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 05 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 05 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 05 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 05 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 05 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 05 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 02 p: 00 pc: 026A sp: FD x: 05 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 02 p: 00 pc: 026C sp: FD x: 05 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 02 p: 00 pc: 026E sp: FD x: 05 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 02 p: 00 pc: 0270 sp: FD x: 05 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 02 p: 00 pc: 0259 sp: FD x: 05 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 05 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 05 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 05 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 05 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 05 y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 05 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 05 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 05 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 05 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 05 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 00 pc: 0229 sp: FF x: 05 y: 02 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 05 p: 00 pc: 022E sp: FF x: 05 y: 02 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 0D p: 00 pc: 0231 sp: FF x: 05 y: 02 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 0D p: 00 pc: 0232 sp: FF x: 06 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 0D p: 00 pc: 0235 sp: FF x: 06 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 0D p: 00 pc: 0238 sp: FF x: 06 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 0D p: 00 pc: 023B sp: FF x: 06 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 0F p: 00 pc: 023E sp: FF x: 06 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 0F p: 81 pc: 0240 sp: FF x: 06 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 0F p: 81 pc: 0211 sp: FF x: 06 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0F p: 01 pc: 0213 sp: FF x: 06 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 0F p: 01 pc: 0216 sp: FF x: 06 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 0F p: 01 pc: 0218 sp: FF x: 06 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 06 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 06 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 06 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 06 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 06 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 06 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 06 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 06 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 06 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 06 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 06 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 06 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 06 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 06 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 06 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 06 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 06 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 06 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 06 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 06 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 06 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 06 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 06 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 00 pc: 0250 sp: FD x: 06 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 18 p: 00 pc: 0257 sp: FD x: 06 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 06 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 06 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 06 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 06 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 06 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 06 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 06 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 06 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 06 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 06 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 06 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 06 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 06 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 06 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 06 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 06 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 06 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 06 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 06 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 06 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 06 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 06 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 06 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 06 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 06 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 06 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 06 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 06 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 06 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 06 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 06 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 06 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 06 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 06 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 05 p: 00 pc: 026A sp: FD x: 06 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 00 pc: 026C sp: FD x: 06 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 06 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 06 y: 01 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 06 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 06 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 06 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 06 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 06 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 06 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 11 p: 01 pc: 023E sp: FF x: 06 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 11 p: 81 pc: 0240 sp: FF x: 06 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 11 p: 81 pc: 0211 sp: FF x: 06 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 11 p: 01 pc: 0213 sp: FF x: 06 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 11 p: 01 pc: 0216 sp: FF x: 06 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 11 p: 01 pc: 0218 sp: FF x: 06 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 06 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 06 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 06 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 06 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 06 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 06 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 06 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 06 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 06 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 06 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 06 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 06 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 06 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 06 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 06 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 06 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 06 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 06 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 06 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 06 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 06 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 06 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 06 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 00 pc: 0250 sp: FD x: 06 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 18 p: 00 pc: 0257 sp: FD x: 06 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 06 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 06 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 06 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 06 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 06 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 06 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 06 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 06 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 06 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 06 y: 01 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 06 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 06 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 06 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 06 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 06 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 06 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 06 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 06 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 06 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 06 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 06 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 06 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 06 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 06 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 06 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 06 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 06 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 06 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 06 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 06 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 06 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 06 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 06 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 06 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 05 p: 00 pc: 026A sp: FD x: 06 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 00 pc: 026C sp: FD x: 06 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 06 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 06 y: 01 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 06 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 06 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 06 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 06 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 06 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 06 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 06 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 06 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 06 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 11 p: 01 pc: 0216 sp: FF x: 06 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 11 p: 01 pc: 0218 sp: FF x: 06 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 06 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 06 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 06 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 06 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 06 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 06 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 06 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 06 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 06 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 06 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 06 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 06 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 06 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 06 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 06 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 06 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 06 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 06 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 00 pc: 0250 sp: FD x: 06 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 14 p: 00 pc: 0257 sp: FD x: 06 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 06 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 06 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 06 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 06 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 06 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 06 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 06 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 06 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 06 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 06 y: 02 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 06 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 06 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 06 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 06 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 06 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 02 p: 00 pc: 026A sp: FD x: 06 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 02 p: 00 pc: 026C sp: FD x: 06 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 02 p: 00 pc: 026E sp: FD x: 06 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 02 p: 00 pc: 0270 sp: FD x: 06 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 02 p: 00 pc: 0259 sp: FD x: 06 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 06 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 06 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 06 y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 06 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 06 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 06 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 06 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 02 p: 00 pc: 0268 sp: FD x: 06 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 03 p: 00 pc: 026A sp: FD x: 06 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 00 pc: 026C sp: FD x: 06 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 06 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 06 y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 06 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 06 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 06 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 06 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 06 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 00 pc: 0229 sp: FF x: 06 y: 02 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 05 p: 00 pc: 022E sp: FF x: 06 y: 02 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 11 p: 00 pc: 0231 sp: FF x: 06 y: 02 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 11 p: 00 pc: 0232 sp: FF x: 07 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 11 p: 00 pc: 0235 sp: FF x: 07 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 11 p: 00 pc: 0238 sp: FF x: 07 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 11 p: 00 pc: 023B sp: FF x: 07 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 13 p: 00 pc: 023E sp: FF x: 07 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 13 p: 81 pc: 0240 sp: FF x: 07 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 13 p: 81 pc: 0211 sp: FF x: 07 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 13 p: 01 pc: 0213 sp: FF x: 07 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 13 p: 01 pc: 0216 sp: FF x: 07 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 13 p: 01 pc: 0218 sp: FF x: 07 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 07 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 07 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 07 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 07 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 07 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 07 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 07 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 07 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 07 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 07 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 07 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 07 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 07 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 07 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 07 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 07 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 07 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 07 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 07 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 07 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 07 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 07 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 07 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 00 pc: 0250 sp: FD x: 07 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 18 p: 00 pc: 0257 sp: FD x: 07 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 07 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 07 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 07 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 07 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 07 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 07 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 07 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 07 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 07 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 07 y: 01 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 07 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 07 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 07 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 07 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 07 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 07 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 07 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 07 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 07 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 07 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 07 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 07 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 07 y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 07 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 07 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 07 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 07 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 07 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 07 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 07 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 07 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 07 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 07 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 07 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 07 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 07 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 07 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 07 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 07 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 07 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 07 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 07 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 07 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 07 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 07 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 07 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 07 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 13 p: 01 pc: 0216 sp: FF x: 07 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 13 p: 01 pc: 0218 sp: FF x: 07 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 07 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 07 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 07 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 07 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 07 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 07 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 07 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 07 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 07 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 07 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 07 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 07 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 07 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 07 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 07 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 07 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 07 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 07 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 00 pc: 0250 sp: FD x: 07 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 14 p: 00 pc: 0257 sp: FD x: 07 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 07 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 07 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 07 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 07 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 07 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 07 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 07 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 07 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 07 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 07 y: 02 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 07 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 07 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 07 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 07 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 07 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 02 p: 00 pc: 026A sp: FD x: 07 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 02 p: 00 pc: 026C sp: FD x: 07 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 02 p: 00 pc: 026E sp: FD x: 07 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 02 p: 00 pc: 0270 sp: FD x: 07 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 02 p: 00 pc: 0259 sp: FD x: 07 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 07 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 07 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 07 y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 07 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 07 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 07 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 07 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 02 p: 00 pc: 0268 sp: FD x: 07 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 03 p: 00 pc: 026A sp: FD x: 07 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 00 pc: 026C sp: FD x: 07 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 07 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 07 y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 07 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 07 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 07 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 07 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 07 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 00 pc: 0229 sp: FF x: 07 y: 02 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 05 p: 00 pc: 022E sp: FF x: 07 y: 02 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 13 p: 00 pc: 0231 sp: FF x: 07 y: 02 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 13 p: 00 pc: 0232 sp: FF x: 08 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 13 p: 00 pc: 0235 sp: FF x: 08 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 13 p: 00 pc: 0238 sp: FF x: 08 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 13 p: 00 pc: 023B sp: FF x: 08 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 15 p: 00 pc: 023E sp: FF x: 08 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 15 p: 81 pc: 0240 sp: FF x: 08 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 15 p: 81 pc: 0211 sp: FF x: 08 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 15 p: 01 pc: 0213 sp: FF x: 08 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 15 p: 01 pc: 0216 sp: FF x: 08 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 15 p: 01 pc: 0218 sp: FF x: 08 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 08 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 08 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 08 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 08 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 08 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 08 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 08 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 08 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 08 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 08 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 08 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 08 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 08 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 08 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 08 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 08 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 08 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 08 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 08 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 08 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 08 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 08 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 08 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 00 pc: 0250 sp: FD x: 08 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 18 p: 00 pc: 0257 sp: FD x: 08 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 08 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 08 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 08 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 08 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 08 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 08 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 08 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 08 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 08 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 08 y: 01 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 08 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 08 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 08 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 08 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 08 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 08 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 08 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 08 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 08 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 08 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 08 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 08 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 08 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 08 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 08 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 08 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 08 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 08 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 08 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 08 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 08 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 08 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 08 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 08 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 08 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 08 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 08 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 08 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 08 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 08 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 06 p: 00 pc: 0268 sp: FD x: 08 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 07 p: 00 pc: 026A sp: FD x: 08 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 00 pc: 026C sp: FD x: 08 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 08 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 08 y: 01 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 08 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 08 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 08 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 08 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 08 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 08 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 17 p: 01 pc: 023E sp: FF x: 08 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 17 p: 81 pc: 0240 sp: FF x: 08 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 17 p: 81 pc: 0211 sp: FF x: 08 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 17 p: 01 pc: 0213 sp: FF x: 08 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 17 p: 01 pc: 0216 sp: FF x: 08 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 17 p: 01 pc: 0218 sp: FF x: 08 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 08 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 08 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 08 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 08 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 08 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 08 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 08 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 08 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 08 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 08 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 08 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 08 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 08 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 08 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 08 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 08 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 08 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 08 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 08 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 08 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 08 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 08 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 08 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 00 pc: 0250 sp: FD x: 08 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 18 p: 00 pc: 0257 sp: FD x: 08 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 08 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 08 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 08 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 08 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 08 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 08 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 08 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 08 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 08 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 08 y: 01 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 08 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 08 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 08 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 08 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 08 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 08 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 08 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 08 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 08 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 08 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 08 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 08 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 08 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 08 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 08 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 08 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 08 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 08 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 08 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 08 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 08 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 08 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 08 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 08 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 08 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 08 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 08 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 08 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 08 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 08 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 06 p: 00 pc: 0268 sp: FD x: 08 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 07 p: 00 pc: 026A sp: FD x: 08 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 00 pc: 026C sp: FD x: 08 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 08 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 08 y: 01 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 08 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 08 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 08 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 08 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 08 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 08 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 08 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 08 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 08 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 17 p: 01 pc: 0216 sp: FF x: 08 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 17 p: 01 pc: 0218 sp: FF x: 08 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 08 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 08 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 08 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 08 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 08 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 08 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 08 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 08 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 08 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 08 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 08 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 08 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 08 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 08 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 08 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 08 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 08 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 08 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 08 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 08 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 08 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 08 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 08 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 00 pc: 0250 sp: FD x: 08 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 28 p: 00 pc: 0257 sp: FD x: 08 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 08 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 08 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 08 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 08 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 08 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 08 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 08 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 08 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 08 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 08 y: 02 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 08 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 08 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 08 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 08 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 08 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 08 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 08 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 08 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 08 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 08 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 08 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 08 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 08 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 08 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 08 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 08 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 08 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 08 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 08 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 08 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 08 y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 08 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 08 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 08 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 08 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 08 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 00 pc: 0229 sp: FF x: 08 y: 02 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 05 p: 00 pc: 022E sp: FF x: 08 y: 02 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 17 p: 00 pc: 0231 sp: FF x: 08 y: 02 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 17 p: 00 pc: 0232 sp: FF x: 09 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 17 p: 00 pc: 0235 sp: FF x: 09 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 17 p: 00 pc: 0238 sp: FF x: 09 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 17 p: 00 pc: 023B sp: FF x: 09 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 19 p: 00 pc: 023E sp: FF x: 09 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 19 p: 81 pc: 0240 sp: FF x: 09 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 19 p: 81 pc: 0211 sp: FF x: 09 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 19 p: 01 pc: 0213 sp: FF x: 09 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 19 p: 01 pc: 0216 sp: FF x: 09 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 19 p: 01 pc: 0218 sp: FF x: 09 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 09 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 09 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 09 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 09 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 09 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 09 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 09 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 09 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 09 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 09 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 09 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 09 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 09 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 09 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 00 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 30 p: 00 pc: 0257 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 09 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 09 y: 01 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 09 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 09 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 09 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 09 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 09 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 09 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 09 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 09 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 09 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 09 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 09 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 09 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 09 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 09 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 19 p: 01 pc: 0216 sp: FF x: 09 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 19 p: 01 pc: 0218 sp: FF x: 09 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 09 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 09 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 09 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 09 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 09 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 09 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 09 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 09 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 09 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 09 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 09 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 09 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 09 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 09 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 09 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 09 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 09 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 09 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 09 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 09 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 09 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 09 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 09 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 00 pc: 0250 sp: FD x: 09 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 28 p: 00 pc: 0257 sp: FD x: 09 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 09 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 09 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 09 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 09 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 09 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 09 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 09 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 09 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 09 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 09 y: 02 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 09 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 09 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 09 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 09 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 09 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 09 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 09 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 09 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 09 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 09 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 09 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 09 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 09 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 09 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 09 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 09 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 09 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 09 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 09 y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 09 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 09 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 09 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 09 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 09 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 05 p: 00 pc: 026A sp: FD x: 09 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 00 pc: 026C sp: FD x: 09 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 09 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 09 y: 02 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 09 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 09 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 09 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 09 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 09 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 09 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 1B p: 01 pc: 023E sp: FF x: 09 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 1B p: 81 pc: 0240 sp: FF x: 09 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 1B p: 81 pc: 0211 sp: FF x: 09 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 1B p: 01 pc: 0213 sp: FF x: 09 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 1B p: 01 pc: 0216 sp: FF x: 09 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 1B p: 01 pc: 0218 sp: FF x: 09 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 09 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 09 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 09 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 09 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 09 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 09 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 09 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 09 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 09 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 09 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 09 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 09 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 09 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 09 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 00 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 30 p: 00 pc: 0257 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 09 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 09 y: 01 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 09 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 09 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 09 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 09 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 09 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 09 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 09 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 09 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 09 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 09 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 09 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 09 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 09 p: 00 pc: 026A sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 00 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 09 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 09 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 09 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 09 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 09 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 09 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 1D p: 01 pc: 023E sp: FF x: 09 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 1D p: 81 pc: 0240 sp: FF x: 09 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 1D p: 81 pc: 0211 sp: FF x: 09 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 1D p: 01 pc: 0213 sp: FF x: 09 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 1D p: 01 pc: 0216 sp: FF x: 09 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 1D p: 01 pc: 0218 sp: FF x: 09 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 09 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 09 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 09 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 09 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 09 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 09 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 09 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 09 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 09 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 09 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 09 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 09 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 09 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 09 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 09 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 09 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 00 pc: 0250 sp: FD x: 09 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 30 p: 00 pc: 0257 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 81 pc: 025D sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 81 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 00 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 00 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1D p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 09 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 09 y: 01 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 09 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 09 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 09 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 09 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 09 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 09 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 09 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 09 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 09 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 09 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 09 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 09 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 09 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 09 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 09 p: 00 pc: 026A sp: FD x: 09 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 00 pc: 026C sp: FD x: 09 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 09 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 09 y: 01 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 09 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 09 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 09 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 09 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 09 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 09 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 09 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 09 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 09 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 1D p: 01 pc: 0216 sp: FF x: 09 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 1D p: 01 pc: 0218 sp: FF x: 09 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 09 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 09 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 09 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 09 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 09 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 09 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 09 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 09 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 09 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 09 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 09 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 09 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 09 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 09 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 09 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 09 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 09 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 09 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 09 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 09 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 09 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 09 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 09 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 00 pc: 0250 sp: FD x: 09 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 28 p: 00 pc: 0257 sp: FD x: 09 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 09 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 09 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 81 pc: 025D sp: FD x: 09 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 81 pc: 026C sp: FD x: 09 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 00 pc: 026E sp: FD x: 09 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 00 pc: 0270 sp: FD x: 09 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1D p: 00 pc: 0259 sp: FD x: 09 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 09 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 09 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 09 y: 02 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 09 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 09 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 09 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 09 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 09 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 09 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 09 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 09 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 09 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 09 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 09 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 09 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 09 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 09 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 09 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 09 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 09 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 09 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 09 y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 09 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 09 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 09 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 09 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 09 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 05 p: 00 pc: 026A sp: FD x: 09 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 00 pc: 026C sp: FD x: 09 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 09 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 09 y: 02 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 09 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 09 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 09 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 09 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 09 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 02 pc: 0229 sp: FF x: 09 y: 02 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 05 p: 02 pc: 022E sp: FF x: 09 y: 02 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 1D p: 00 pc: 0231 sp: FF x: 09 y: 02 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 1D p: 00 pc: 0232 sp: FF x: 0A y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 1D p: 00 pc: 0235 sp: FF x: 0A y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 1D p: 00 pc: 0238 sp: FF x: 0A y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 1D p: 00 pc: 023B sp: FF x: 0A y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 1F p: 00 pc: 023E sp: FF x: 0A y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 1F p: 81 pc: 0240 sp: FF x: 0A y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 1F p: 81 pc: 0211 sp: FF x: 0A y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 1F p: 01 pc: 0213 sp: FF x: 0A y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 1F p: 01 pc: 0216 sp: FF x: 0A y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 1F p: 01 pc: 0218 sp: FF x: 0A y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 0A y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 0A y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 0A y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0A y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0A y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0A y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 0A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 0A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 0A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 0A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 0A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 0A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 0A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 0A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 0A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 0A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 0A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 0A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 0A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 0A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 0A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 0A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 0A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 0A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 0A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 0A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 0A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 00 pc: 0250 sp: FD x: 0A y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 30 p: 00 pc: 0257 sp: FD x: 0A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 0A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 0A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 81 pc: 025D sp: FD x: 0A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 81 pc: 026C sp: FD x: 0A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 00 pc: 026E sp: FD x: 0A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 00 pc: 0270 sp: FD x: 0A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1F p: 00 pc: 0259 sp: FD x: 0A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 0A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 0A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 0A y: 01 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 0A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 0A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 0A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 0A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 0A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 0A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 0A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 0A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 0A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 0A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 0A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 0A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 0A y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 0A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 0A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 0A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 0A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 0A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 0A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 0A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 0A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 0A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 0A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 0A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 0A y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 0A y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 0A y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 0A y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 0A y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 0A y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 0A y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 0A y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 0A y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 0A y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 1F p: 01 pc: 0216 sp: FF x: 0A y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 1F p: 01 pc: 0218 sp: FF x: 0A y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 0A y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 0A y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 0A y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0A y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0A y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0A y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 0A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 0A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 0A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 0A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 0A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 0A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 0A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 0A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 0A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 0A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 0A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 0A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 0A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 0A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 0A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 0A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 00 pc: 0250 sp: FD x: 0A y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 28 p: 00 pc: 0257 sp: FD x: 0A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 0A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 0A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 81 pc: 025D sp: FD x: 0A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 81 pc: 026C sp: FD x: 0A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 00 pc: 026E sp: FD x: 0A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 00 pc: 0270 sp: FD x: 0A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1F p: 00 pc: 0259 sp: FD x: 0A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 0A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 0A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 0A y: 02 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 0A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 0A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 0A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 0A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 0A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 0A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 0A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 0A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 0A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 0A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 0A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 0A y: 02 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 0A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 0A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 0A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 0A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 0A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 0A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 0A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 0A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 0A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 0A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 0A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 0A y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 0A y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 0A y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 0A y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 0A y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 0A y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 0A y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 0A y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 0A y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 0A y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 1F p: 01 pc: 0216 sp: FF x: 0A y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 1F p: 01 pc: 0218 sp: FF x: 0A y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 0A y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 0A y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 0A y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0A y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0A y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0A y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 0A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 0A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 0A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 0A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 0A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 0A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 0A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 0A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 0A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 0A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 0A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 0A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 0A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 0A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 0A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 0A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 00 pc: 0250 sp: FD x: 0A y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 38 p: 00 pc: 0257 sp: FD x: 0A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 0A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 0A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 81 pc: 025D sp: FD x: 0A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 81 pc: 026C sp: FD x: 0A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 00 pc: 026E sp: FD x: 0A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 00 pc: 0270 sp: FD x: 0A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1F p: 00 pc: 0259 sp: FD x: 0A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 0A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 0A y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 0A y: 03 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 0A y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 0A y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 0A y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 0A y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0A y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 0A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 0A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 0A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 0A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 0A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 0A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 0A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 0A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 0A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 0A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 0A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 0A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 0A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 0A y: 03 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 0A y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 0A y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 0A y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 0A y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 0A y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 00 pc: 0229 sp: FF x: 0A y: 03 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 07 p: 00 pc: 022E sp: FF x: 0A y: 03 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 1F p: 00 pc: 0231 sp: FF x: 0A y: 03 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 1F p: 00 pc: 0232 sp: FF x: 0B y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 1F p: 00 pc: 0235 sp: FF x: 0B y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 1F p: 00 pc: 0238 sp: FF x: 0B y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 1F p: 00 pc: 023B sp: FF x: 0B y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 21 p: 00 pc: 023E sp: FF x: 0B y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: 21 p: 81 pc: 0240 sp: FF x: 0B y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 21 p: 81 pc: 0211 sp: FF x: 0B y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 21 p: 01 pc: 0213 sp: FF x: 0B y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 21 p: 01 pc: 0216 sp: FF x: 0B y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 21 p: 01 pc: 0218 sp: FF x: 0B y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 0B y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 0B y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 0B y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0B y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0B y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0B y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 0B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 0B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 0B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 0B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 0B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 0B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 0B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 0B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 00 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 30 p: 00 pc: 0257 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 0B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 0B y: 01 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 0B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 0B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 0B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 0B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 0B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 0B y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 0B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 0B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 0B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 0B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 0B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 0B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 0B y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 0B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 0B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 0B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 0B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 0B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 0B y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 0B y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 0B y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 0B y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 0B y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 0B y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 23 p: 01 pc: 023E sp: FF x: 0B y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 23 p: 81 pc: 0240 sp: FF x: 0B y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 23 p: 81 pc: 0211 sp: FF x: 0B y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 23 p: 01 pc: 0213 sp: FF x: 0B y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 23 p: 01 pc: 0216 sp: FF x: 0B y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 23 p: 01 pc: 0218 sp: FF x: 0B y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 0B y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 0B y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 0B y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0B y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0B y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0B y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 0B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 0B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 0B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 0B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 0B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 0B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 0B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 0B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 00 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 30 p: 00 pc: 0257 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 81 pc: 025D sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 81 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 00 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 00 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 23 p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 0B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 0B y: 01 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 0B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 0B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 0B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 0B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 0B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 0B y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 0B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 0B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 0B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 0B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 0B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 0B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 0B y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 0B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 0B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 0B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 0B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 0B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 0B y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 0B y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 0B y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 0B y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 0B y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 0B y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 0B y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 0B y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 0B y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 23 p: 01 pc: 0216 sp: FF x: 0B y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 23 p: 01 pc: 0218 sp: FF x: 0B y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 0B y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 0B y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 0B y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0B y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0B y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0B y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 0B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 0B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 0B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 0B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 0B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 0B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 0B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 0B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 0B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 0B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 0B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 0B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 0B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 0B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 0B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 0B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 00 pc: 0250 sp: FD x: 0B y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 28 p: 00 pc: 0257 sp: FD x: 0B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 0B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 0B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 81 pc: 025D sp: FD x: 0B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 81 pc: 026C sp: FD x: 0B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 00 pc: 026E sp: FD x: 0B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 00 pc: 0270 sp: FD x: 0B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 23 p: 00 pc: 0259 sp: FD x: 0B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 0B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 0B y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 0B y: 02 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 0B y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 0B y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 0B y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 0B y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0B y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 0B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 0B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 0B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 0B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 0B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 0B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 0B y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 0B y: 02 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 0B y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 0B y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 0B y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 0B y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 0B y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 0B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 0B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 0B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 0B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 0B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 0B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 0B y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 0B y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 0B y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 0B y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 0B y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 0B y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 06 p: 00 pc: 0268 sp: FD x: 0B y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 07 p: 00 pc: 026A sp: FD x: 0B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 00 pc: 026C sp: FD x: 0B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 0B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 0B y: 02 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 0B y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 0B y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 0B y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 0B y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 0B y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 0B y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 25 p: 01 pc: 023E sp: FF x: 0B y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 25 p: 81 pc: 0240 sp: FF x: 0B y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 25 p: 81 pc: 0211 sp: FF x: 0B y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 25 p: 01 pc: 0213 sp: FF x: 0B y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 25 p: 01 pc: 0216 sp: FF x: 0B y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 25 p: 01 pc: 0218 sp: FF x: 0B y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 0B y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 0B y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 0B y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0B y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0B y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0B y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 0B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 0B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 0B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 0B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 0B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 0B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 0B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 0B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 0B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 0B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 00 pc: 0250 sp: FD x: 0B y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 30 p: 00 pc: 0257 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 81 pc: 025D sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 81 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 00 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 00 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 25 p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 0B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 0B y: 01 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 0B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 0B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 0B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 0B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 0B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 0B y: 01 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 0B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 0B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 0B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 0B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 0B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 0B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 0B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 0B y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 0B y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 0B y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 0B y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 0B y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 0B y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 0B y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 0B y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 0B y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 0B y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 25 p: 01 pc: 0216 sp: FF x: 0B y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 25 p: 01 pc: 0218 sp: FF x: 0B y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 0B y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 0B y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 0B y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0B y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0B y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0B y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 0B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 0B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 0B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 0B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 0B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 0B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 0B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 0B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 0B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 0B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 0B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 0B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 0B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 0B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 0B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 0B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 00 pc: 0250 sp: FD x: 0B y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 28 p: 00 pc: 0257 sp: FD x: 0B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 0B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 0B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 81 pc: 025D sp: FD x: 0B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 81 pc: 026C sp: FD x: 0B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 00 pc: 026E sp: FD x: 0B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 00 pc: 0270 sp: FD x: 0B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 25 p: 00 pc: 0259 sp: FD x: 0B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 0B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 0B y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 0B y: 02 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 0B y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 0B y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 0B y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 0B y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0B y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 0B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 0B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 0B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 0B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 0B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 0B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 0B y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 0B y: 02 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 0B y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 0B y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 0B y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 0B y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 0B y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 0B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 0B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 0B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 0B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 0B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 0B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 0B y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 0B y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 0B y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 0B y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 0B y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 0B y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 06 p: 00 pc: 0268 sp: FD x: 0B y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 07 p: 00 pc: 026A sp: FD x: 0B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 00 pc: 026C sp: FD x: 0B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 0B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 0B y: 02 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 0B y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 0B y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 0B y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 0B y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 0B y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 0B y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 0B y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 0B y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 0B y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 25 p: 01 pc: 0216 sp: FF x: 0B y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 25 p: 01 pc: 0218 sp: FF x: 0B y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 0B y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 0B y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 0B y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0B y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0B y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0B y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 0B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 0B y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 0B y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 0B y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 0B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 0B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 0B y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 0B y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 0B y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 0B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 0B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 0B y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 0B y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 0B y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 0B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 0B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 00 pc: 0250 sp: FD x: 0B y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 38 p: 00 pc: 0257 sp: FD x: 0B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 0B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 0B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 81 pc: 025D sp: FD x: 0B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 81 pc: 026C sp: FD x: 0B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 00 pc: 026E sp: FD x: 0B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 00 pc: 0270 sp: FD x: 0B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 25 p: 00 pc: 0259 sp: FD x: 0B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 0B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 0B y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 0B y: 03 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 0B y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 0B y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 0B y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 0B y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0B y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 0B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 0B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 0B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 0B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 0B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 0B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 0B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 0B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 0B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 0B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 0B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 0B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 0B y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 0B y: 03 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 0B y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 0B y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 0B y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 0B y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 0B y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 05 p: 00 pc: 026A sp: FD x: 0B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 00 pc: 026C sp: FD x: 0B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 0B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 0B y: 03 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 0B y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 0B y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 0B y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 0B y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 0B y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 00 pc: 0229 sp: FF x: 0B y: 03 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 07 p: 00 pc: 022E sp: FF x: 0B y: 03 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 25 p: 00 pc: 0231 sp: FF x: 0B y: 03 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 25 p: 00 pc: 0232 sp: FF x: 0C y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 25 p: 00 pc: 0235 sp: FF x: 0C y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 25 p: 00 pc: 0238 sp: FF x: 0C y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 25 p: 00 pc: 023B sp: FF x: 0C y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 27 p: 00 pc: 023E sp: FF x: 0C y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: 27 p: 81 pc: 0240 sp: FF x: 0C y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 27 p: 81 pc: 0211 sp: FF x: 0C y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 27 p: 01 pc: 0213 sp: FF x: 0C y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 27 p: 01 pc: 0216 sp: FF x: 0C y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 27 p: 01 pc: 0218 sp: FF x: 0C y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 0C y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 0C y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 0C y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0C y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0C y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0C y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 0C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 0C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 0C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 0C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 0C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 0C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 0C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 0C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 0C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 0C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 0C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 0C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 0C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 0C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 0C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 0C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 0C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 0C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 0C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 0C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 0C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 00 pc: 0250 sp: FD x: 0C y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 30 p: 00 pc: 0257 sp: FD x: 0C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 0C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 0C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 81 pc: 025D sp: FD x: 0C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 81 pc: 026C sp: FD x: 0C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 00 pc: 026E sp: FD x: 0C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 00 pc: 0270 sp: FD x: 0C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 27 p: 00 pc: 0259 sp: FD x: 0C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 0C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 0C y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 0C y: 01 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 0C y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 0C y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 0C y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 0C y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0C y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 0C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 0C y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 0C y: 01 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 0C y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 0C y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 0C y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 0C y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 0C y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 0C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 0C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 0C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 0C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 0C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 0C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 0C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 0C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 0C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 0C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 0C y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 0C y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 0C y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 0C y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 0C y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 0C y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 0C y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 0C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 0C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 0C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 0C y: 01 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 0C y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 0C y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 0C y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 0C y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 0C y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 0C y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 29 p: 01 pc: 023E sp: FF x: 0C y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 29 p: 81 pc: 0240 sp: FF x: 0C y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 29 p: 81 pc: 0211 sp: FF x: 0C y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 29 p: 01 pc: 0213 sp: FF x: 0C y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 29 p: 01 pc: 0216 sp: FF x: 0C y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 29 p: 01 pc: 0218 sp: FF x: 0C y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 0C y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 0C y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 0C y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0C y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0C y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0C y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 0C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 0C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 0C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 0C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 0C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 0C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 0C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 0C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 0C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 0C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 0C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 0C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 0C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 0C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 0C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 0C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 0C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 0C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 0C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 0C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 0C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 00 pc: 0250 sp: FD x: 0C y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 30 p: 00 pc: 0257 sp: FD x: 0C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 0C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 0C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 81 pc: 025D sp: FD x: 0C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 29 p: 81 pc: 026C sp: FD x: 0C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 29 p: 00 pc: 026E sp: FD x: 0C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 29 p: 00 pc: 0270 sp: FD x: 0C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 29 p: 00 pc: 0259 sp: FD x: 0C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 0C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 00 pc: 025D sp: FD x: 0C y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 29 p: 00 pc: 025F sp: FD x: 0C y: 01 
---
[1]    55 0261: 	sec
[2] a: 29 p: 00 pc: 0261 sp: FD x: 0C y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 29 p: 01 pc: 0262 sp: FD x: 0C y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 0C y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 0C y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0C y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 0C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 0C y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 0C y: 01 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 0C y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 0C y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 0C y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 0C y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 0C y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 0C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 0C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 0C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 0C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 0C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 0C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 0C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 0C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 0C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 0C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 0C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 0C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 0C y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 0C y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 0C y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 0C y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 0C y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 0C y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 0C y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 0C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 0C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 0C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 0C y: 01 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 0C y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 0C y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 0C y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 0C y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 0C y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 0C y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 0C y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 0C y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 0C y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 29 p: 01 pc: 0216 sp: FF x: 0C y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 29 p: 01 pc: 0218 sp: FF x: 0C y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 0C y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 0C y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 0C y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0C y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0C y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0C y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 0C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 0C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 0C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 0C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 0C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 0C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 0C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 0C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 0C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 0C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 0C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 0C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 0C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 0C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 0C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 0C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 0C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 0C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 0C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 0C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 0C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 0C y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 0C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 0C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 0C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 81 pc: 025D sp: FD x: 0C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 29 p: 81 pc: 026C sp: FD x: 0C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 29 p: 00 pc: 026E sp: FD x: 0C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 29 p: 00 pc: 0270 sp: FD x: 0C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 29 p: 00 pc: 0259 sp: FD x: 0C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 0C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 00 pc: 025D sp: FD x: 0C y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 29 p: 00 pc: 025F sp: FD x: 0C y: 02 
---
[1]    55 0261: 	sec
[2] a: 29 p: 00 pc: 0261 sp: FD x: 0C y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 29 p: 01 pc: 0262 sp: FD x: 0C y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 0C y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 0C y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0C y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 0C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 0C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 0C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 0C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 0C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 0C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 0C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 0C y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 0C y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 0C y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 0C y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 0C y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 0C y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 0C y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 0C y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 0C y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 0C y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 29 p: 01 pc: 0216 sp: FF x: 0C y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 29 p: 01 pc: 0218 sp: FF x: 0C y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 0C y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 0C y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 0C y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0C y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0C y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0C y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 0C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 0C y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 0C y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 0C y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 0C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 0C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 0C y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 0C y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 0C y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 0C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 0C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 0C y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 0C y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 0C y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 0C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 0C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 00 pc: 0250 sp: FD x: 0C y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 38 p: 00 pc: 0257 sp: FD x: 0C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 0C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 0C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 81 pc: 025D sp: FD x: 0C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 29 p: 81 pc: 026C sp: FD x: 0C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 29 p: 00 pc: 026E sp: FD x: 0C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 29 p: 00 pc: 0270 sp: FD x: 0C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 29 p: 00 pc: 0259 sp: FD x: 0C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 0C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 00 pc: 025D sp: FD x: 0C y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 29 p: 00 pc: 025F sp: FD x: 0C y: 03 
---
[1]    55 0261: 	sec
[2] a: 29 p: 00 pc: 0261 sp: FD x: 0C y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 29 p: 01 pc: 0262 sp: FD x: 0C y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 0C y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 0C y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0C y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 0C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 0C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 0C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 0C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 0C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 0C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 0C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 0C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 0C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 0C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 0C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 0C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 0C y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 0C y: 03 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 0C y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 0C y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 0C y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 0C y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 0C y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 05 p: 00 pc: 026A sp: FD x: 0C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 00 pc: 026C sp: FD x: 0C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 0C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 0C y: 03 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 0C y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 0C y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 0C y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 0C y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 0C y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 00 pc: 0229 sp: FF x: 0C y: 03 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 07 p: 00 pc: 022E sp: FF x: 0C y: 03 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 29 p: 00 pc: 0231 sp: FF x: 0C y: 03 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 29 p: 00 pc: 0232 sp: FF x: 0D y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 29 p: 00 pc: 0235 sp: FF x: 0D y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 29 p: 00 pc: 0238 sp: FF x: 0D y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 29 p: 00 pc: 023B sp: FF x: 0D y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 2B p: 00 pc: 023E sp: FF x: 0D y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: 2B p: 81 pc: 0240 sp: FF x: 0D y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 2B p: 81 pc: 0211 sp: FF x: 0D y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 2B p: 01 pc: 0213 sp: FF x: 0D y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 2B p: 01 pc: 0216 sp: FF x: 0D y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 2B p: 01 pc: 0218 sp: FF x: 0D y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 0D y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 0D y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 0D y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0D y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0D y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0D y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 0D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 0D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 0D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 0D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 0D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 0D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 0D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 0D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 0D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 0D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 0D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 0D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 0D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 0D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 0D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 0D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 0D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 0D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 0D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 0D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 0D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 00 pc: 0250 sp: FD x: 0D y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 30 p: 00 pc: 0257 sp: FD x: 0D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 0D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 0D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 81 pc: 025D sp: FD x: 0D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 81 pc: 026C sp: FD x: 0D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 00 pc: 026E sp: FD x: 0D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 00 pc: 0270 sp: FD x: 0D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2B p: 00 pc: 0259 sp: FD x: 0D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 0D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 00 pc: 025D sp: FD x: 0D y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2B p: 00 pc: 025F sp: FD x: 0D y: 01 
---
[1]    55 0261: 	sec
[2] a: 2B p: 00 pc: 0261 sp: FD x: 0D y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2B p: 01 pc: 0262 sp: FD x: 0D y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 0D y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 0D y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0D y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 0D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 0D y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 0D y: 01 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 0D y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 0D y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 0D y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 0D y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 0D y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 0D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 0D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 0D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 0D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 0D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 0D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 0D y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 0D y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 0D y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 0D y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 0D y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 0D y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 0D y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 0D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 0D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 0D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 0D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 0D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 0D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 0D y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 0D y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 0D y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 0D y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 0D y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 0D y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 0D y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 0D y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 0D y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 0D y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 2B p: 01 pc: 0216 sp: FF x: 0D y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 2B p: 01 pc: 0218 sp: FF x: 0D y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 0D y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 0D y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 0D y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0D y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0D y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0D y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 0D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 0D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 0D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 0D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 0D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 0D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 0D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 0D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 0D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 0D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 0D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 0D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 0D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 0D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 0D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 0D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 0D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 0D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 0D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 0D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 0D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 0D y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 0D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 0D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 0D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 81 pc: 025D sp: FD x: 0D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 81 pc: 026C sp: FD x: 0D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 00 pc: 026E sp: FD x: 0D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 00 pc: 0270 sp: FD x: 0D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2B p: 00 pc: 0259 sp: FD x: 0D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 0D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 00 pc: 025D sp: FD x: 0D y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 2B p: 00 pc: 025F sp: FD x: 0D y: 02 
---
[1]    55 0261: 	sec
[2] a: 2B p: 00 pc: 0261 sp: FD x: 0D y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2B p: 01 pc: 0262 sp: FD x: 0D y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 0D y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 0D y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0D y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 0D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 0D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 0D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 0D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 0D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 0D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 0D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 0D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 0D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 0D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 0D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 0D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 0D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 0D y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 0D y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 0D y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 0D y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 0D y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 0D y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 0D y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 0D y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 0D y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 0D y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 2B p: 01 pc: 0216 sp: FF x: 0D y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 2B p: 01 pc: 0218 sp: FF x: 0D y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 0D y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 0D y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 0D y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0D y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0D y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0D y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 0D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 0D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 0D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 0D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 0D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 0D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 0D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 0D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 0D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 0D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 0D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 0D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 0D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 0D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 0D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 0D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 00 pc: 0250 sp: FD x: 0D y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 38 p: 00 pc: 0257 sp: FD x: 0D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 0D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 0D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 81 pc: 025D sp: FD x: 0D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 81 pc: 026C sp: FD x: 0D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 00 pc: 026E sp: FD x: 0D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 00 pc: 0270 sp: FD x: 0D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2B p: 00 pc: 0259 sp: FD x: 0D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 0D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 00 pc: 025D sp: FD x: 0D y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 2B p: 00 pc: 025F sp: FD x: 0D y: 03 
---
[1]    55 0261: 	sec
[2] a: 2B p: 00 pc: 0261 sp: FD x: 0D y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2B p: 01 pc: 0262 sp: FD x: 0D y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 0D y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 0D y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0D y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 0D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 0D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 0D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 0D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 0D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 0D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 0D y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 0D y: 03 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 0D y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 0D y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 0D y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 0D y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 0D y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 0D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 0D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 0D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 0D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 0D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 0D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 0D y: 03 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 0D y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 0D y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 0D y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 0D y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 0D y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 00 pc: 0229 sp: FF x: 0D y: 03 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 07 p: 00 pc: 022E sp: FF x: 0D y: 03 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 2B p: 00 pc: 0231 sp: FF x: 0D y: 03 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 2B p: 00 pc: 0232 sp: FF x: 0E y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 2B p: 00 pc: 0235 sp: FF x: 0E y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 2B p: 00 pc: 0238 sp: FF x: 0E y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 2B p: 00 pc: 023B sp: FF x: 0E y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 2D p: 00 pc: 023E sp: FF x: 0E y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: 2D p: 81 pc: 0240 sp: FF x: 0E y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 2D p: 81 pc: 0211 sp: FF x: 0E y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 2D p: 01 pc: 0213 sp: FF x: 0E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 2D p: 01 pc: 0216 sp: FF x: 0E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 2D p: 01 pc: 0218 sp: FF x: 0E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 0E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 0E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 0E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 0E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 0E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 0E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 0E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 0E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 0E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 0E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 0E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 0E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 0E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 0E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 0E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 0E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 0E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 0E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 0E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 0E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 0E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 0E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 0E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 0E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 00 pc: 0250 sp: FD x: 0E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 30 p: 00 pc: 0257 sp: FD x: 0E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 0E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 0E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 81 pc: 025D sp: FD x: 0E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2D p: 81 pc: 026C sp: FD x: 0E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2D p: 00 pc: 026E sp: FD x: 0E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2D p: 00 pc: 0270 sp: FD x: 0E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2D p: 00 pc: 0259 sp: FD x: 0E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 0E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 00 pc: 025D sp: FD x: 0E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2D p: 00 pc: 025F sp: FD x: 0E y: 01 
---
[1]    55 0261: 	sec
[2] a: 2D p: 00 pc: 0261 sp: FD x: 0E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2D p: 01 pc: 0262 sp: FD x: 0E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 0E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 0E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 0E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 0E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 0E y: 01 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 0E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 0E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 0E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 0E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 0E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 0E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 0E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 0E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 0E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 0E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 0E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 0E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 0E y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 0E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 0E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 0E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 0E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 0E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 0E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 0E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 0E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 0E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 0E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 0E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 0E y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 0E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 0E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 0E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 0E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0E p: 00 pc: 0268 sp: FD x: 0E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0F p: 00 pc: 026A sp: FD x: 0E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 00 pc: 026C sp: FD x: 0E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 01 pc: 026E sp: FD x: 0E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 03 pc: 0270 sp: FD x: 0E y: 01 
---
[1]    64 0272: 	rts
[2] a: 0F p: 03 pc: 0272 sp: FD x: 0E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0F p: 03 pc: 0220 sp: FF x: 0E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 0E y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 0E y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 0E y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 0E y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 2F p: 01 pc: 023E sp: FF x: 0E y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 2F p: 81 pc: 0240 sp: FF x: 0E y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 2F p: 81 pc: 0211 sp: FF x: 0E y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 2F p: 01 pc: 0213 sp: FF x: 0E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 2F p: 01 pc: 0216 sp: FF x: 0E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 2F p: 01 pc: 0218 sp: FF x: 0E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 0E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 0E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 0E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 0E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 0E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 0E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 0E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 0E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 0E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 0E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 0E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 0E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 0E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 0E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 0E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 0E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 0E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 0E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 0E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 0E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 0E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 0E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 0E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 0E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 00 pc: 0250 sp: FD x: 0E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 30 p: 00 pc: 0257 sp: FD x: 0E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 0E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 0E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 81 pc: 025D sp: FD x: 0E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2F p: 81 pc: 026C sp: FD x: 0E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2F p: 00 pc: 026E sp: FD x: 0E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2F p: 00 pc: 0270 sp: FD x: 0E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2F p: 00 pc: 0259 sp: FD x: 0E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 0E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 00 pc: 025D sp: FD x: 0E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2F p: 00 pc: 025F sp: FD x: 0E y: 01 
---
[1]    55 0261: 	sec
[2] a: 2F p: 00 pc: 0261 sp: FD x: 0E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2F p: 01 pc: 0262 sp: FD x: 0E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 0E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 0E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 0E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 0E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 0E y: 01 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 0E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 0E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 0E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 0E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 0E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 0E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 0E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 0E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 0E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 0E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 0E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 0E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 0E y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 0E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 0E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 0E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 0E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 0E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 0E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 0E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 0E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 0E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 0E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 0E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 0E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 0E y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 0E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 0E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 0E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 0E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0E p: 00 pc: 0268 sp: FD x: 0E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0F p: 00 pc: 026A sp: FD x: 0E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 00 pc: 026C sp: FD x: 0E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 01 pc: 026E sp: FD x: 0E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 03 pc: 0270 sp: FD x: 0E y: 01 
---
[1]    64 0272: 	rts
[2] a: 0F p: 03 pc: 0272 sp: FD x: 0E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0F p: 03 pc: 0220 sp: FF x: 0E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 0E y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 0E y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 0E y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 0E y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 0E y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 0E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 0E y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 2F p: 01 pc: 0216 sp: FF x: 0E y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 2F p: 01 pc: 0218 sp: FF x: 0E y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 0E y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 0E y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 0E y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0E y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0E y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0E y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 0E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 0E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 0E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 0E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 0E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 0E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 0E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 0E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 0E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 0E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 0E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 0E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 0E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 0E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 0E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 0E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 0E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 0E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 0E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 0E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 0E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 0E y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 0E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 0E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 0E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 81 pc: 025D sp: FD x: 0E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2F p: 81 pc: 026C sp: FD x: 0E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2F p: 00 pc: 026E sp: FD x: 0E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2F p: 00 pc: 0270 sp: FD x: 0E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2F p: 00 pc: 0259 sp: FD x: 0E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 0E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 00 pc: 025D sp: FD x: 0E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 2F p: 00 pc: 025F sp: FD x: 0E y: 02 
---
[1]    55 0261: 	sec
[2] a: 2F p: 00 pc: 0261 sp: FD x: 0E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2F p: 01 pc: 0262 sp: FD x: 0E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 0E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 0E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 0E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 0E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 0E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 0E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 0E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 0E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 0E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 0E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 0E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 0E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 0E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 0E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 0E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 0E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 0E y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 0E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 0E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 0E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 0E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 0E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 09 p: 00 pc: 026A sp: FD x: 0E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 00 pc: 026C sp: FD x: 0E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 0E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 0E y: 02 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 0E y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 0E y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 0E y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 0E y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 0E y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 0E y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 0E y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 0E y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 0E y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 2F p: 01 pc: 0216 sp: FF x: 0E y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 2F p: 01 pc: 0218 sp: FF x: 0E y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 0E y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 0E y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 0E y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0E y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0E y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0E y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 0E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 0E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 0E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 0E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 0E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 0E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 0E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 0E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 0E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 0E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 0E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 0E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 0E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 0E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 0E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 0E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 00 pc: 0250 sp: FD x: 0E y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 38 p: 00 pc: 0257 sp: FD x: 0E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 0E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 0E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 81 pc: 025D sp: FD x: 0E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2F p: 81 pc: 026C sp: FD x: 0E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 2F p: 00 pc: 026E sp: FD x: 0E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2F p: 00 pc: 0270 sp: FD x: 0E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2F p: 00 pc: 0259 sp: FD x: 0E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 0E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 00 pc: 025D sp: FD x: 0E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 2F p: 00 pc: 025F sp: FD x: 0E y: 03 
---
[1]    55 0261: 	sec
[2] a: 2F p: 00 pc: 0261 sp: FD x: 0E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2F p: 01 pc: 0262 sp: FD x: 0E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 0E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 0E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 0E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 0E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 0E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 0E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 0E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 0E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 0E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 0E y: 03 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 0E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 0E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 0E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 0E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 0E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 0E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 0E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 0E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 0E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 0E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 0E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 0E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 0E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 0E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 0E y: 03 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 0E y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 0E y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 0E y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 0E y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 0E y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 00 pc: 0229 sp: FF x: 0E y: 03 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 07 p: 00 pc: 022E sp: FF x: 0E y: 03 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 2F p: 00 pc: 0231 sp: FF x: 0E y: 03 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 2F p: 00 pc: 0232 sp: FF x: 0F y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 2F p: 00 pc: 0235 sp: FF x: 0F y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 2F p: 00 pc: 0238 sp: FF x: 0F y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 2F p: 00 pc: 023B sp: FF x: 0F y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 31 p: 00 pc: 023E sp: FF x: 0F y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: 31 p: 81 pc: 0240 sp: FF x: 0F y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 31 p: 81 pc: 0211 sp: FF x: 0F y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 31 p: 01 pc: 0213 sp: FF x: 0F y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 31 p: 01 pc: 0216 sp: FF x: 0F y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 31 p: 01 pc: 0218 sp: FF x: 0F y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 0F y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 0F y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 0F y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0F y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0F y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0F y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 31 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 31 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 31 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 31 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 00 pc: 025D sp: FD x: 0F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 31 p: 00 pc: 025F sp: FD x: 0F y: 01 
---
[1]    55 0261: 	sec
[2] a: 31 p: 00 pc: 0261 sp: FD x: 0F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 31 p: 01 pc: 0262 sp: FD x: 0F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 0F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 0F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 0F y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 0F y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 0F y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 0F y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 0F y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 0F y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 0F y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 0F y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 0F y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 31 p: 01 pc: 0216 sp: FF x: 0F y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 31 p: 01 pc: 0218 sp: FF x: 0F y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 0F y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 0F y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 0F y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0F y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0F y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0F y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 0F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 0F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 0F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 0F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 0F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 0F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 0F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 0F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 0F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 0F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 0F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 0F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 0F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 0F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 0F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 0F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 0F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 0F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 0F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 0F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 0F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 0F y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 0F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 0F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 0F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 81 pc: 025D sp: FD x: 0F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 31 p: 81 pc: 026C sp: FD x: 0F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 31 p: 00 pc: 026E sp: FD x: 0F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 31 p: 00 pc: 0270 sp: FD x: 0F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 31 p: 00 pc: 0259 sp: FD x: 0F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 0F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 00 pc: 025D sp: FD x: 0F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 31 p: 00 pc: 025F sp: FD x: 0F y: 02 
---
[1]    55 0261: 	sec
[2] a: 31 p: 00 pc: 0261 sp: FD x: 0F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 31 p: 01 pc: 0262 sp: FD x: 0F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 0F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 0F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 0F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 0F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 0F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 0F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 0F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 0F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 0F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 0F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 0F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 0F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 0F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 0F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 0F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 0F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 0F y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 0F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 0F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 0F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 0F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 0F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 09 p: 00 pc: 026A sp: FD x: 0F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 00 pc: 026C sp: FD x: 0F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 0F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 0F y: 02 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 0F y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 0F y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 0F y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 0F y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 0F y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 0F y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 0F y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 0F y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 0F y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 31 p: 01 pc: 0216 sp: FF x: 0F y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 31 p: 01 pc: 0218 sp: FF x: 0F y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 0F y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 0F y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 0F y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0F y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0F y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0F y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 0F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 0F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 0F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 0F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 0F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 0F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 0F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 0F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 0F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 0F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 0F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 0F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 0F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 0F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 0F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 0F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 00 pc: 0250 sp: FD x: 0F y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 38 p: 00 pc: 0257 sp: FD x: 0F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 0F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 0F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 81 pc: 025D sp: FD x: 0F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 31 p: 81 pc: 026C sp: FD x: 0F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 31 p: 00 pc: 026E sp: FD x: 0F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 31 p: 00 pc: 0270 sp: FD x: 0F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 31 p: 00 pc: 0259 sp: FD x: 0F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 0F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 00 pc: 025D sp: FD x: 0F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 31 p: 00 pc: 025F sp: FD x: 0F y: 03 
---
[1]    55 0261: 	sec
[2] a: 31 p: 00 pc: 0261 sp: FD x: 0F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 31 p: 01 pc: 0262 sp: FD x: 0F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 0F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 0F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 0F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 0F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 0F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 0F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 0F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 0F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 0F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 0F y: 03 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 0F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 0F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 0F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 0F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 0F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 0F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 0F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 0F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 0F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 0F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 0F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 02 pc: 025D sp: FD x: 0F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 02 pc: 025F sp: FD x: 0F y: 03 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 0F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 0F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 0F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 0F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 06 p: 00 pc: 0268 sp: FD x: 0F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 07 p: 00 pc: 026A sp: FD x: 0F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 00 pc: 026C sp: FD x: 0F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 0F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 0F y: 03 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 0F y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 0F y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 0F y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 0F y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 0F y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 0F y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 33 p: 01 pc: 023E sp: FF x: 0F y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: 33 p: 81 pc: 0240 sp: FF x: 0F y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 33 p: 81 pc: 0211 sp: FF x: 0F y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 33 p: 01 pc: 0213 sp: FF x: 0F y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 33 p: 01 pc: 0216 sp: FF x: 0F y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 33 p: 01 pc: 0218 sp: FF x: 0F y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 0F y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 0F y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 0F y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0F y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0F y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0F y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 33 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 33 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 33 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 33 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 00 pc: 025D sp: FD x: 0F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 33 p: 00 pc: 025F sp: FD x: 0F y: 01 
---
[1]    55 0261: 	sec
[2] a: 33 p: 00 pc: 0261 sp: FD x: 0F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 33 p: 01 pc: 0262 sp: FD x: 0F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 0F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 0F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 0F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 0F y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 0F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 0F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 0F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 0F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 0F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 0F y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 0F y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 0F y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 0F y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 0F y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 0F y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 35 p: 01 pc: 023E sp: FF x: 0F y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 35 p: 81 pc: 0240 sp: FF x: 0F y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 35 p: 81 pc: 0211 sp: FF x: 0F y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 35 p: 01 pc: 0213 sp: FF x: 0F y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 35 p: 01 pc: 0216 sp: FF x: 0F y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 35 p: 01 pc: 0218 sp: FF x: 0F y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 0F y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 0F y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 0F y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0F y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0F y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0F y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 0F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 0F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 0F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 0F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 0F y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 35 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 35 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 35 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 35 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 00 pc: 025D sp: FD x: 0F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 35 p: 00 pc: 025F sp: FD x: 0F y: 01 
---
[1]    55 0261: 	sec
[2] a: 35 p: 00 pc: 0261 sp: FD x: 0F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 35 p: 01 pc: 0262 sp: FD x: 0F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 0F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 0F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 0F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 0F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 0F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 0F y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 0F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 0F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 0F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 0F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 0F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 0F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 0F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 0F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 0F y: 01 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 0F y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 0F y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 0F y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 0F y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 0F y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 0F y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 0F y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 0F y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 0F y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 35 p: 01 pc: 0216 sp: FF x: 0F y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 35 p: 01 pc: 0218 sp: FF x: 0F y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 0F y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 0F y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 0F y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0F y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0F y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0F y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 0F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 0F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 0F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 0F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 0F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 0F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 0F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 0F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 0F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 0F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 0F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 0F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 0F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 0F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 0F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 0F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 0F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 0F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 0F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 0F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 0F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 0F y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 0F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 0F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 0F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 81 pc: 025D sp: FD x: 0F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 35 p: 81 pc: 026C sp: FD x: 0F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 35 p: 00 pc: 026E sp: FD x: 0F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 35 p: 00 pc: 0270 sp: FD x: 0F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 35 p: 00 pc: 0259 sp: FD x: 0F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 0F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 00 pc: 025D sp: FD x: 0F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 35 p: 00 pc: 025F sp: FD x: 0F y: 02 
---
[1]    55 0261: 	sec
[2] a: 35 p: 00 pc: 0261 sp: FD x: 0F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 35 p: 01 pc: 0262 sp: FD x: 0F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 0F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 0F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 0F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 0F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 0F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 0F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 0F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 0F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 0F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 0F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 0F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 0F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 0F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 0F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 0F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 0F y: 02 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 0F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 0F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 0F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 0F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 0F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 0F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 0F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 0F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 0F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 0F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 0F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 0F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 0F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 0F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 0F y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 0F y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 0F y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 0F y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 0F y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 0F y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 0F y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 0F y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 0F y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 0F y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 35 p: 01 pc: 0216 sp: FF x: 0F y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 35 p: 01 pc: 0218 sp: FF x: 0F y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 0F y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 0F y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 0F y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 0F y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 0F y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 0F y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 0F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 0F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 0F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 0F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 0F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 0F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 0F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 0F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 0F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 0F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 0F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 0F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 0F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 0F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 0F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 0F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 0F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 00 pc: 0250 sp: FD x: 0F y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 38 p: 00 pc: 0257 sp: FD x: 0F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 0F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 0F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 81 pc: 025D sp: FD x: 0F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 35 p: 81 pc: 026C sp: FD x: 0F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 35 p: 00 pc: 026E sp: FD x: 0F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 35 p: 00 pc: 0270 sp: FD x: 0F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 35 p: 00 pc: 0259 sp: FD x: 0F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 0F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 00 pc: 025D sp: FD x: 0F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 35 p: 00 pc: 025F sp: FD x: 0F y: 03 
---
[1]    55 0261: 	sec
[2] a: 35 p: 00 pc: 0261 sp: FD x: 0F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 35 p: 01 pc: 0262 sp: FD x: 0F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 0F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 0F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 0F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 0F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 0F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 0F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 0F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 0F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 0F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 0F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 0F y: 03 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 0F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 0F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 0F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 0F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 0F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 0F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 0F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 0F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 0F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 0F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 0F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 0F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 0F y: 03 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 0F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 0F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 0F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 0F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 06 p: 00 pc: 0268 sp: FD x: 0F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 07 p: 00 pc: 026A sp: FD x: 0F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 00 pc: 026C sp: FD x: 0F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 0F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 0F y: 03 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 0F y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 0F y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 0F y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 0F y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 0F y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 02 pc: 0229 sp: FF x: 0F y: 03 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 07 p: 02 pc: 022E sp: FF x: 0F y: 03 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 35 p: 00 pc: 0231 sp: FF x: 0F y: 03 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 35 p: 00 pc: 0232 sp: FF x: 10 y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 35 p: 00 pc: 0235 sp: FF x: 10 y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 35 p: 00 pc: 0238 sp: FF x: 10 y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 35 p: 00 pc: 023B sp: FF x: 10 y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 37 p: 00 pc: 023E sp: FF x: 10 y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: 37 p: 81 pc: 0240 sp: FF x: 10 y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 37 p: 81 pc: 0211 sp: FF x: 10 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 37 p: 01 pc: 0213 sp: FF x: 10 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 37 p: 01 pc: 0216 sp: FF x: 10 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 37 p: 01 pc: 0218 sp: FF x: 10 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 10 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 10 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 10 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 10 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 10 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 10 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 81 pc: 025D sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 37 p: 81 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 37 p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 37 p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 37 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 00 pc: 025D sp: FD x: 10 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 37 p: 00 pc: 025F sp: FD x: 10 y: 01 
---
[1]    55 0261: 	sec
[2] a: 37 p: 00 pc: 0261 sp: FD x: 10 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 37 p: 01 pc: 0262 sp: FD x: 10 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 10 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 10 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 10 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 10 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 10 y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 10 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 10 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 10 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 10 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 10 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 10 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 10 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 10 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 10 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 10 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 10 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 10 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 10 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 10 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 37 p: 01 pc: 0216 sp: FF x: 10 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 37 p: 01 pc: 0218 sp: FF x: 10 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 10 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 10 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 10 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 10 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 10 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 10 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 10 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 10 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 10 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 10 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 10 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 10 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 10 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 10 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 10 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 10 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 10 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 10 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 10 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 10 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 10 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 10 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 10 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 10 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 10 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 10 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 10 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 10 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 10 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 10 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 10 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 10 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 81 pc: 025D sp: FD x: 10 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 37 p: 81 pc: 026C sp: FD x: 10 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 37 p: 00 pc: 026E sp: FD x: 10 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 37 p: 00 pc: 0270 sp: FD x: 10 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 37 p: 00 pc: 0259 sp: FD x: 10 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 10 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 00 pc: 025D sp: FD x: 10 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 37 p: 00 pc: 025F sp: FD x: 10 y: 02 
---
[1]    55 0261: 	sec
[2] a: 37 p: 00 pc: 0261 sp: FD x: 10 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 37 p: 01 pc: 0262 sp: FD x: 10 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 10 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 10 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 10 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 10 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 10 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 10 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 10 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 10 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 10 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 10 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 10 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 10 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 10 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 10 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 10 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 10 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 10 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 10 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 10 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 10 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 10 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 10 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 10 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 10 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 10 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 10 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 10 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 10 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 10 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 10 y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 10 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 10 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 10 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 10 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 10 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 10 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 10 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 10 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 10 y: 02 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 10 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 10 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 10 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 10 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 10 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 10 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 39 p: 01 pc: 023E sp: FF x: 10 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 39 p: 81 pc: 0240 sp: FF x: 10 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 39 p: 81 pc: 0211 sp: FF x: 10 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 39 p: 01 pc: 0213 sp: FF x: 10 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 39 p: 01 pc: 0216 sp: FF x: 10 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 39 p: 01 pc: 0218 sp: FF x: 10 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 10 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 10 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 10 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 10 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 10 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 10 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 81 pc: 025D sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 39 p: 81 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 39 p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 39 p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 39 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 00 pc: 025D sp: FD x: 10 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 39 p: 00 pc: 025F sp: FD x: 10 y: 01 
---
[1]    55 0261: 	sec
[2] a: 39 p: 00 pc: 0261 sp: FD x: 10 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 39 p: 01 pc: 0262 sp: FD x: 10 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 10 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 10 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 10 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 10 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 10 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 10 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 10 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 10 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 10 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 10 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 10 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 10 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 10 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 10 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 10 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 10 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 12 p: 00 pc: 0268 sp: FD x: 10 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 13 p: 00 pc: 026A sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 00 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 01 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 03 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    64 0272: 	rts
[2] a: 13 p: 03 pc: 0272 sp: FD x: 10 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 13 p: 03 pc: 0220 sp: FF x: 10 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 10 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 10 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 10 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 10 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 3B p: 01 pc: 023E sp: FF x: 10 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 3B p: 81 pc: 0240 sp: FF x: 10 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 3B p: 81 pc: 0211 sp: FF x: 10 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 3B p: 01 pc: 0213 sp: FF x: 10 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 3B p: 01 pc: 0216 sp: FF x: 10 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 3B p: 01 pc: 0218 sp: FF x: 10 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 10 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 10 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 10 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 10 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 10 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 10 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 10 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 10 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 10 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 10 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 10 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 81 pc: 025D sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3B p: 81 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3B p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3B p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3B p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 00 pc: 025D sp: FD x: 10 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 3B p: 00 pc: 025F sp: FD x: 10 y: 01 
---
[1]    55 0261: 	sec
[2] a: 3B p: 00 pc: 0261 sp: FD x: 10 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3B p: 01 pc: 0262 sp: FD x: 10 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 10 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 10 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 10 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 10 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 10 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 10 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 10 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 10 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 10 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 10 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 10 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 10 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 10 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 10 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 10 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 10 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 10 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 10 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 12 p: 00 pc: 0268 sp: FD x: 10 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 13 p: 00 pc: 026A sp: FD x: 10 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 00 pc: 026C sp: FD x: 10 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 01 pc: 026E sp: FD x: 10 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 03 pc: 0270 sp: FD x: 10 y: 01 
---
[1]    64 0272: 	rts
[2] a: 13 p: 03 pc: 0272 sp: FD x: 10 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 13 p: 03 pc: 0220 sp: FF x: 10 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 10 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 10 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 10 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 10 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 10 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 10 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 10 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 3B p: 01 pc: 0216 sp: FF x: 10 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 3B p: 01 pc: 0218 sp: FF x: 10 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 10 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 10 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 10 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 10 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 10 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 10 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 10 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 10 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 10 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 10 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 10 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 10 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 10 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 10 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 10 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 10 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 10 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 10 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 10 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 10 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 10 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 10 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 10 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 10 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 10 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 10 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 10 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 10 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 10 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 10 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 10 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 10 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 81 pc: 025D sp: FD x: 10 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3B p: 81 pc: 026C sp: FD x: 10 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 3B p: 00 pc: 026E sp: FD x: 10 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3B p: 00 pc: 0270 sp: FD x: 10 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3B p: 00 pc: 0259 sp: FD x: 10 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 10 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 00 pc: 025D sp: FD x: 10 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 3B p: 00 pc: 025F sp: FD x: 10 y: 02 
---
[1]    55 0261: 	sec
[2] a: 3B p: 00 pc: 0261 sp: FD x: 10 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3B p: 01 pc: 0262 sp: FD x: 10 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 10 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 10 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 10 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 10 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 10 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 10 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 10 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 10 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 10 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 10 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 10 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 10 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 10 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 10 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 10 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 10 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 10 y: 02 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 10 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 10 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 10 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 10 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 10 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 10 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 10 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 10 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 10 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 10 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 10 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 10 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 10 y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 10 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 10 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 10 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 10 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 10 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 10 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 10 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 10 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 10 y: 02 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 10 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 10 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 10 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 10 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 10 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 10 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 10 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 10 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 10 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 3B p: 01 pc: 0216 sp: FF x: 10 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 3B p: 01 pc: 0218 sp: FF x: 10 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 10 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 10 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 10 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 10 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 10 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 10 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 10 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 10 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 10 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 10 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 10 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 10 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 10 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 10 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 10 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 10 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 10 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 10 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 10 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 10 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 10 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 10 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 10 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 10 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 10 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 10 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 10 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 10 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 10 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 10 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 10 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 10 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 81 pc: 025D sp: FD x: 10 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3B p: 81 pc: 026C sp: FD x: 10 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 3B p: 00 pc: 026E sp: FD x: 10 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3B p: 00 pc: 0270 sp: FD x: 10 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3B p: 00 pc: 0259 sp: FD x: 10 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 10 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 00 pc: 025D sp: FD x: 10 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 3B p: 00 pc: 025F sp: FD x: 10 y: 03 
---
[1]    55 0261: 	sec
[2] a: 3B p: 00 pc: 0261 sp: FD x: 10 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3B p: 01 pc: 0262 sp: FD x: 10 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 10 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 10 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 10 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 10 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 10 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 10 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 10 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 10 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 10 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 10 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 10 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 10 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 10 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 10 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 10 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 10 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 10 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 10 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 10 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 10 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 10 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 10 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 10 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 10 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 10 y: 03 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 10 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 10 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 10 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 10 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 10 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 10 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 10 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 10 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 10 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 3B p: 01 pc: 0216 sp: FF x: 10 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 3B p: 01 pc: 0218 sp: FF x: 10 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 10 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 10 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 10 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 10 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 10 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 10 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 10 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 10 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 10 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 10 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 10 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 10 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 10 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 10 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 10 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 10 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 10 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 10 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 10 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 10 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 10 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 10 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 10 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 00 pc: 0250 sp: FD x: 10 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 58 p: 00 pc: 0257 sp: FD x: 10 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 58 p: 00 pc: 0259 sp: FD x: 10 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 10 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 81 pc: 025D sp: FD x: 10 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3B p: 81 pc: 026C sp: FD x: 10 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 3B p: 00 pc: 026E sp: FD x: 10 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3B p: 00 pc: 0270 sp: FD x: 10 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3B p: 00 pc: 0259 sp: FD x: 10 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 10 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 00 pc: 025D sp: FD x: 10 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 3B p: 00 pc: 025F sp: FD x: 10 y: 04 
---
[1]    55 0261: 	sec
[2] a: 3B p: 00 pc: 0261 sp: FD x: 10 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3B p: 01 pc: 0262 sp: FD x: 10 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 10 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 10 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 10 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 10 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 10 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 10 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 10 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 10 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 10 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 10 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 10 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 10 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 10 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 10 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 10 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 10 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 10 y: 04 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 10 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 10 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 10 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 10 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 10 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 05 p: 00 pc: 026A sp: FD x: 10 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 00 pc: 026C sp: FD x: 10 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 10 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 10 y: 04 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 10 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 10 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 10 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 10 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 10 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 10 y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 10 y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 3B p: 00 pc: 0231 sp: FF x: 10 y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 3B p: 00 pc: 0232 sp: FF x: 11 y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 3B p: 00 pc: 0235 sp: FF x: 11 y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 3B p: 00 pc: 0238 sp: FF x: 11 y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 3B p: 00 pc: 023B sp: FF x: 11 y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 3D p: 00 pc: 023E sp: FF x: 11 y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 3D p: 81 pc: 0240 sp: FF x: 11 y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 3D p: 81 pc: 0211 sp: FF x: 11 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 3D p: 01 pc: 0213 sp: FF x: 11 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 3D p: 01 pc: 0216 sp: FF x: 11 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 3D p: 01 pc: 0218 sp: FF x: 11 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 11 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 11 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 11 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 11 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 11 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 11 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 11 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 11 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 11 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 11 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 11 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 11 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 11 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 11 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 11 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 11 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 11 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 11 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 11 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 11 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 11 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 11 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 11 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 11 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 11 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 11 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 11 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 11 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 11 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 11 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 11 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 11 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 11 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 11 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 11 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 11 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 11 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 81 pc: 025D sp: FD x: 11 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3D p: 81 pc: 026C sp: FD x: 11 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3D p: 00 pc: 026E sp: FD x: 11 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3D p: 00 pc: 0270 sp: FD x: 11 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3D p: 00 pc: 0259 sp: FD x: 11 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 11 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 00 pc: 025D sp: FD x: 11 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 3D p: 00 pc: 025F sp: FD x: 11 y: 01 
---
[1]    55 0261: 	sec
[2] a: 3D p: 00 pc: 0261 sp: FD x: 11 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3D p: 01 pc: 0262 sp: FD x: 11 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 11 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 11 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 11 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 11 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 11 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 11 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 11 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 11 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 11 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 11 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 11 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 11 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 11 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 11 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 11 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 11 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 11 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 11 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 11 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 11 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 11 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 11 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 11 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 11 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 11 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 11 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 11 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 11 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 11 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 11 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 11 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 11 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 11 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 11 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 11 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 11 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 11 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 11 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 11 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 11 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 11 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 11 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 11 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 11 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 11 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 11 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 11 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 3D p: 01 pc: 0216 sp: FF x: 11 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 3D p: 01 pc: 0218 sp: FF x: 11 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 11 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 11 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 11 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 11 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 11 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 11 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 11 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 11 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 11 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 11 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 11 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 11 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 11 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 11 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 11 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 11 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 11 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 11 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 11 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 11 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 11 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 11 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 11 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 11 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 11 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 11 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 11 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 11 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 11 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 11 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 11 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 11 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 81 pc: 025D sp: FD x: 11 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3D p: 81 pc: 026C sp: FD x: 11 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 3D p: 00 pc: 026E sp: FD x: 11 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3D p: 00 pc: 0270 sp: FD x: 11 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3D p: 00 pc: 0259 sp: FD x: 11 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 11 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 00 pc: 025D sp: FD x: 11 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 3D p: 00 pc: 025F sp: FD x: 11 y: 02 
---
[1]    55 0261: 	sec
[2] a: 3D p: 00 pc: 0261 sp: FD x: 11 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3D p: 01 pc: 0262 sp: FD x: 11 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 11 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 11 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 11 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 11 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 11 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 11 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 11 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 11 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 11 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 11 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 11 y: 02 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 11 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 11 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 11 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 11 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 11 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 11 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 11 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 11 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 11 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 11 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 11 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 11 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 11 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 11 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 11 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 11 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 11 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 11 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 11 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 11 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 11 y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 11 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 11 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 11 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 11 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 11 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 11 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 11 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 11 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 11 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 3D p: 01 pc: 0216 sp: FF x: 11 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 3D p: 01 pc: 0218 sp: FF x: 11 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 11 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 11 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 11 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 11 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 11 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 11 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 11 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 11 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 11 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 11 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 11 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 11 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 11 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 11 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 11 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 11 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 11 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 11 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 11 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 11 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 11 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 11 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 11 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 11 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 11 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 11 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 11 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 11 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 11 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 11 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 11 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 11 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 81 pc: 025D sp: FD x: 11 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3D p: 81 pc: 026C sp: FD x: 11 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 3D p: 00 pc: 026E sp: FD x: 11 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3D p: 00 pc: 0270 sp: FD x: 11 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3D p: 00 pc: 0259 sp: FD x: 11 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 11 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 00 pc: 025D sp: FD x: 11 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 3D p: 00 pc: 025F sp: FD x: 11 y: 03 
---
[1]    55 0261: 	sec
[2] a: 3D p: 00 pc: 0261 sp: FD x: 11 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3D p: 01 pc: 0262 sp: FD x: 11 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 11 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 11 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 11 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 11 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 11 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 11 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 11 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 11 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 11 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 11 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 11 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 11 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 11 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 11 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 11 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 11 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 11 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 11 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 11 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 11 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 11 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 11 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 11 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 11 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 11 y: 03 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 11 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 11 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 11 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 11 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 11 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 11 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 11 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 11 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 11 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 3D p: 01 pc: 0216 sp: FF x: 11 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 3D p: 01 pc: 0218 sp: FF x: 11 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 11 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 11 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 11 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 11 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 11 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 11 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 11 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 11 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 11 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 11 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 11 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 11 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 11 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 11 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 11 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 11 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 11 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 11 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 11 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 11 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 11 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 11 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 11 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 00 pc: 0250 sp: FD x: 11 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 58 p: 00 pc: 0257 sp: FD x: 11 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 58 p: 00 pc: 0259 sp: FD x: 11 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 11 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 81 pc: 025D sp: FD x: 11 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3D p: 81 pc: 026C sp: FD x: 11 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 3D p: 00 pc: 026E sp: FD x: 11 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3D p: 00 pc: 0270 sp: FD x: 11 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3D p: 00 pc: 0259 sp: FD x: 11 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 11 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 00 pc: 025D sp: FD x: 11 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 3D p: 00 pc: 025F sp: FD x: 11 y: 04 
---
[1]    55 0261: 	sec
[2] a: 3D p: 00 pc: 0261 sp: FD x: 11 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3D p: 01 pc: 0262 sp: FD x: 11 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 11 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 11 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 11 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 11 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 11 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 11 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 11 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 11 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 11 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 11 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 11 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 11 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 11 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 11 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 11 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 11 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 11 y: 04 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 11 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 11 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 11 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 11 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 11 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 05 p: 00 pc: 026A sp: FD x: 11 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 00 pc: 026C sp: FD x: 11 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 11 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 11 y: 04 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 11 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 11 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 11 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 11 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 11 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 11 y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 11 y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 3D p: 00 pc: 0231 sp: FF x: 11 y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 3D p: 00 pc: 0232 sp: FF x: 12 y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 3D p: 00 pc: 0235 sp: FF x: 12 y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 3D p: 00 pc: 0238 sp: FF x: 12 y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 3D p: 00 pc: 023B sp: FF x: 12 y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 3F p: 00 pc: 023E sp: FF x: 12 y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 3F p: 81 pc: 0240 sp: FF x: 12 y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 3F p: 81 pc: 0211 sp: FF x: 12 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 3F p: 01 pc: 0213 sp: FF x: 12 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 3F p: 01 pc: 0216 sp: FF x: 12 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 3F p: 01 pc: 0218 sp: FF x: 12 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 12 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 12 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 12 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 12 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 12 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 12 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3F p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3F p: 81 pc: 025D sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3F p: 81 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3F p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3F p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3F p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3F p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3F p: 00 pc: 025D sp: FD x: 12 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 3F p: 00 pc: 025F sp: FD x: 12 y: 01 
---
[1]    55 0261: 	sec
[2] a: 3F p: 00 pc: 0261 sp: FD x: 12 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3F p: 01 pc: 0262 sp: FD x: 12 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 12 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 12 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 12 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 12 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 12 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 12 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 12 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 12 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 12 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 12 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 12 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 12 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 12 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 12 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 12 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 12 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 12 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 15 p: 00 pc: 026A sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 00 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 01 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 03 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    64 0272: 	rts
[2] a: 15 p: 03 pc: 0272 sp: FD x: 12 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 15 p: 03 pc: 0220 sp: FF x: 12 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 12 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 12 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 12 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 12 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 41 p: 01 pc: 023E sp: FF x: 12 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 41 p: 81 pc: 0240 sp: FF x: 12 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 41 p: 81 pc: 0211 sp: FF x: 12 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 41 p: 01 pc: 0213 sp: FF x: 12 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 41 p: 01 pc: 0216 sp: FF x: 12 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 41 p: 01 pc: 0218 sp: FF x: 12 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 12 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 12 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 12 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 12 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 12 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 12 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 41 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 41 p: 81 pc: 025D sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 41 p: 81 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 41 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 41 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 41 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 41 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 41 p: 00 pc: 025D sp: FD x: 12 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 41 p: 00 pc: 025F sp: FD x: 12 y: 01 
---
[1]    55 0261: 	sec
[2] a: 41 p: 00 pc: 0261 sp: FD x: 12 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 41 p: 01 pc: 0262 sp: FD x: 12 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 12 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 12 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 12 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 12 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 12 y: 01 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 12 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 12 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 12 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 12 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 12 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 12 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 12 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 12 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 12 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 12 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 12 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 12 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 15 p: 00 pc: 026A sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 00 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 01 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 03 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    64 0272: 	rts
[2] a: 15 p: 03 pc: 0272 sp: FD x: 12 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 15 p: 03 pc: 0220 sp: FF x: 12 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 12 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 12 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 12 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 12 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 12 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 12 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 12 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 41 p: 01 pc: 0216 sp: FF x: 12 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 41 p: 01 pc: 0218 sp: FF x: 12 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 12 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 12 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 12 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 12 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 12 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 12 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 12 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 12 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 12 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 12 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 12 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 12 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 12 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 12 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 12 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 12 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 12 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 12 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 12 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 12 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 12 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 12 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 12 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 12 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 12 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 12 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 12 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 12 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 12 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 12 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 12 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 41 p: 00 pc: 025B sp: FD x: 12 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 41 p: 81 pc: 025D sp: FD x: 12 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 41 p: 81 pc: 026C sp: FD x: 12 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 41 p: 00 pc: 026E sp: FD x: 12 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 41 p: 00 pc: 0270 sp: FD x: 12 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 41 p: 00 pc: 0259 sp: FD x: 12 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 41 p: 00 pc: 025B sp: FD x: 12 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 41 p: 00 pc: 025D sp: FD x: 12 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 41 p: 00 pc: 025F sp: FD x: 12 y: 02 
---
[1]    55 0261: 	sec
[2] a: 41 p: 00 pc: 0261 sp: FD x: 12 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 41 p: 01 pc: 0262 sp: FD x: 12 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 12 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 12 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 12 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 12 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 12 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 12 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 12 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 12 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 12 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 12 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 12 y: 02 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 12 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 12 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 12 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 12 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 12 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 12 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 12 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 12 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 12 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 12 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 12 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 12 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 12 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 12 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 12 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 12 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 12 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 12 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 12 y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 12 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 12 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 12 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 12 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 12 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 12 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 12 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 12 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 12 y: 02 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 12 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 12 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 12 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 12 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 12 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 12 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 43 p: 01 pc: 023E sp: FF x: 12 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 43 p: 81 pc: 0240 sp: FF x: 12 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 43 p: 81 pc: 0211 sp: FF x: 12 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 43 p: 01 pc: 0213 sp: FF x: 12 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 43 p: 01 pc: 0216 sp: FF x: 12 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 43 p: 01 pc: 0218 sp: FF x: 12 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 12 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 12 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 12 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 12 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 12 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 12 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 12 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 12 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 12 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 12 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 12 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 43 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 43 p: 81 pc: 025D sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 43 p: 81 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 43 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 43 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 43 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 43 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 43 p: 00 pc: 025D sp: FD x: 12 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 43 p: 00 pc: 025F sp: FD x: 12 y: 01 
---
[1]    55 0261: 	sec
[2] a: 43 p: 00 pc: 0261 sp: FD x: 12 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 43 p: 01 pc: 0262 sp: FD x: 12 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 12 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 12 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 12 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 12 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 12 y: 01 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 12 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 12 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 12 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 12 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 12 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 12 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 12 y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 12 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 12 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 12 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 12 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 12 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 12 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 12 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 12 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 12 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 12 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 12 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 12 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 12 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 12 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 12 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 12 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 12 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 12 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 12 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 12 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 43 p: 01 pc: 0216 sp: FF x: 12 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 43 p: 01 pc: 0218 sp: FF x: 12 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 12 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 12 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 12 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 12 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 12 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 12 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 12 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 12 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 12 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 12 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 12 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 12 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 12 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 12 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 12 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 12 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 12 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 12 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 12 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 12 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 12 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 12 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 12 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 12 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 12 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 12 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 12 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 12 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 12 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 12 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 12 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 43 p: 00 pc: 025B sp: FD x: 12 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 43 p: 81 pc: 025D sp: FD x: 12 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 43 p: 81 pc: 026C sp: FD x: 12 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 43 p: 00 pc: 026E sp: FD x: 12 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 43 p: 00 pc: 0270 sp: FD x: 12 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 43 p: 00 pc: 0259 sp: FD x: 12 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 43 p: 00 pc: 025B sp: FD x: 12 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 43 p: 00 pc: 025D sp: FD x: 12 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 43 p: 00 pc: 025F sp: FD x: 12 y: 02 
---
[1]    55 0261: 	sec
[2] a: 43 p: 00 pc: 0261 sp: FD x: 12 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 43 p: 01 pc: 0262 sp: FD x: 12 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 12 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 12 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 12 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 12 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 12 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 12 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 12 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 12 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 12 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 12 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 12 y: 02 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 12 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 12 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 12 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 12 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 12 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 12 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 12 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 12 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 12 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 12 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 12 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 12 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 12 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 12 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 12 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 12 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 12 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 12 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 12 y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 12 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 12 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 12 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 12 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 12 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 12 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 12 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 12 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 12 y: 02 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 12 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 12 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 12 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 12 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 12 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 12 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 12 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 12 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 12 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 43 p: 01 pc: 0216 sp: FF x: 12 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 43 p: 01 pc: 0218 sp: FF x: 12 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 12 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 12 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 12 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 12 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 12 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 12 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 12 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 12 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 12 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 12 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 12 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 12 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 12 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 12 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 12 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 12 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 12 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 12 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 12 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 12 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 12 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 12 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 12 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 12 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 12 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 12 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 12 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 12 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 12 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 12 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 12 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 43 p: 00 pc: 025B sp: FD x: 12 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 43 p: 81 pc: 025D sp: FD x: 12 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 43 p: 81 pc: 026C sp: FD x: 12 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 43 p: 00 pc: 026E sp: FD x: 12 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 43 p: 00 pc: 0270 sp: FD x: 12 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 43 p: 00 pc: 0259 sp: FD x: 12 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 43 p: 00 pc: 025B sp: FD x: 12 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 43 p: 00 pc: 025D sp: FD x: 12 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 43 p: 00 pc: 025F sp: FD x: 12 y: 03 
---
[1]    55 0261: 	sec
[2] a: 43 p: 00 pc: 0261 sp: FD x: 12 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 43 p: 01 pc: 0262 sp: FD x: 12 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 12 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 12 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 12 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 12 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 12 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 12 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 12 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 12 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 12 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 12 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 12 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 12 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 12 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 12 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 12 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 12 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 12 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 12 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 12 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 12 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 12 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 12 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 12 y: 03 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 12 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 12 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 12 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 12 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 12 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 09 p: 00 pc: 026A sp: FD x: 12 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 00 pc: 026C sp: FD x: 12 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 12 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 12 y: 03 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 12 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 12 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 12 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 12 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 12 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 12 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 12 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 12 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 12 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 43 p: 01 pc: 0216 sp: FF x: 12 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 43 p: 01 pc: 0218 sp: FF x: 12 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 12 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 12 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 12 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 12 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 12 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 12 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 12 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 12 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 12 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 12 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 12 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 12 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 12 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 12 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 12 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 12 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 12 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 12 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 12 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 12 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 12 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 12 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 12 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 00 pc: 0250 sp: FD x: 12 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 58 p: 00 pc: 0257 sp: FD x: 12 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 58 p: 00 pc: 0259 sp: FD x: 12 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 43 p: 00 pc: 025B sp: FD x: 12 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 43 p: 81 pc: 025D sp: FD x: 12 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 43 p: 81 pc: 026C sp: FD x: 12 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 43 p: 00 pc: 026E sp: FD x: 12 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 43 p: 00 pc: 0270 sp: FD x: 12 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 43 p: 00 pc: 0259 sp: FD x: 12 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 43 p: 00 pc: 025B sp: FD x: 12 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 43 p: 00 pc: 025D sp: FD x: 12 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 43 p: 00 pc: 025F sp: FD x: 12 y: 04 
---
[1]    55 0261: 	sec
[2] a: 43 p: 00 pc: 0261 sp: FD x: 12 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 43 p: 01 pc: 0262 sp: FD x: 12 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 12 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 12 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 12 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 12 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 12 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 12 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 12 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 12 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 12 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 12 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 12 y: 04 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 12 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 12 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 12 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 12 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 12 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 12 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 12 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 12 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 12 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 12 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 12 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 12 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 12 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 12 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 12 y: 04 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 12 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 12 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 12 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 12 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 12 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 12 y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 12 y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 43 p: 00 pc: 0231 sp: FF x: 12 y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 43 p: 00 pc: 0232 sp: FF x: 13 y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 43 p: 00 pc: 0235 sp: FF x: 13 y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 43 p: 00 pc: 0238 sp: FF x: 13 y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 43 p: 00 pc: 023B sp: FF x: 13 y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 45 p: 00 pc: 023E sp: FF x: 13 y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 45 p: 81 pc: 0240 sp: FF x: 13 y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 45 p: 81 pc: 0211 sp: FF x: 13 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 45 p: 01 pc: 0213 sp: FF x: 13 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 45 p: 01 pc: 0216 sp: FF x: 13 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 45 p: 01 pc: 0218 sp: FF x: 13 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 13 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 13 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 13 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 13 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 13 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 13 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 13 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 13 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 13 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 13 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 13 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 13 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 13 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 13 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 13 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 13 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 13 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 13 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 13 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 13 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 13 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 13 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 13 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 13 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 13 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 13 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 13 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 13 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 13 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 13 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 13 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 13 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 13 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 13 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 13 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 13 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 45 p: 00 pc: 025B sp: FD x: 13 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 45 p: 81 pc: 025D sp: FD x: 13 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 45 p: 81 pc: 026C sp: FD x: 13 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 45 p: 00 pc: 026E sp: FD x: 13 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 45 p: 00 pc: 0270 sp: FD x: 13 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 45 p: 00 pc: 0259 sp: FD x: 13 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 45 p: 00 pc: 025B sp: FD x: 13 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 45 p: 00 pc: 025D sp: FD x: 13 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 45 p: 00 pc: 025F sp: FD x: 13 y: 01 
---
[1]    55 0261: 	sec
[2] a: 45 p: 00 pc: 0261 sp: FD x: 13 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 45 p: 01 pc: 0262 sp: FD x: 13 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 13 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 13 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 13 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 13 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 13 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 13 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 13 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 13 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 13 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 13 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 13 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 13 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 13 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 13 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 13 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 13 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 13 y: 01 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 13 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 13 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 13 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 13 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 13 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 13 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 13 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 13 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 13 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 13 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 13 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 13 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 13 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 13 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 13 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 13 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 13 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 13 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 13 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 13 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 13 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 13 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 13 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 13 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 13 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 13 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 13 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 13 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 13 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 13 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 16 p: 00 pc: 0268 sp: FD x: 13 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 17 p: 00 pc: 026A sp: FD x: 13 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 00 pc: 026C sp: FD x: 13 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 01 pc: 026E sp: FD x: 13 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 03 pc: 0270 sp: FD x: 13 y: 01 
---
[1]    64 0272: 	rts
[2] a: 17 p: 03 pc: 0272 sp: FD x: 13 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 17 p: 03 pc: 0220 sp: FF x: 13 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 13 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 13 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 13 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 13 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 47 p: 01 pc: 023E sp: FF x: 13 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 47 p: 81 pc: 0240 sp: FF x: 13 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 47 p: 81 pc: 0211 sp: FF x: 13 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 47 p: 01 pc: 0213 sp: FF x: 13 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 47 p: 01 pc: 0216 sp: FF x: 13 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 47 p: 01 pc: 0218 sp: FF x: 13 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 13 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 13 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 13 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 13 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 13 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 13 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 13 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 13 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 13 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 13 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 13 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 13 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 13 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 13 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 13 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 13 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 13 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 13 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 13 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 13 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 13 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 13 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 13 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 13 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 13 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 13 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 13 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 13 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 13 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 13 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 13 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 13 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 13 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 13 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 13 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 13 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 47 p: 00 pc: 025B sp: FD x: 13 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 47 p: 81 pc: 025D sp: FD x: 13 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 47 p: 81 pc: 026C sp: FD x: 13 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 47 p: 00 pc: 026E sp: FD x: 13 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 47 p: 00 pc: 0270 sp: FD x: 13 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 47 p: 00 pc: 0259 sp: FD x: 13 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 47 p: 00 pc: 025B sp: FD x: 13 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 47 p: 00 pc: 025D sp: FD x: 13 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 47 p: 00 pc: 025F sp: FD x: 13 y: 01 
---
[1]    55 0261: 	sec
[2] a: 47 p: 00 pc: 0261 sp: FD x: 13 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 47 p: 01 pc: 0262 sp: FD x: 13 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 13 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 13 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 13 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 13 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 13 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 13 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 13 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 13 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 13 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 13 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 13 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 13 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 13 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 13 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 13 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 13 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 13 y: 01 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 13 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 13 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 13 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 13 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 13 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 13 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 13 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 13 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 13 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 13 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 13 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 13 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 13 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 13 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 13 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 13 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 13 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 13 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 13 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 13 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 13 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 13 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 13 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 13 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 13 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 13 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 13 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 13 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 13 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 13 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 16 p: 00 pc: 0268 sp: FD x: 13 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 17 p: 00 pc: 026A sp: FD x: 13 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 00 pc: 026C sp: FD x: 13 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 01 pc: 026E sp: FD x: 13 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 03 pc: 0270 sp: FD x: 13 y: 01 
---
[1]    64 0272: 	rts
[2] a: 17 p: 03 pc: 0272 sp: FD x: 13 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 17 p: 03 pc: 0220 sp: FF x: 13 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 13 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 13 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 13 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 13 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 13 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 13 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 13 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 47 p: 01 pc: 0216 sp: FF x: 13 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 47 p: 01 pc: 0218 sp: FF x: 13 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 13 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 13 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 13 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 13 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 13 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 13 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 13 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 13 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 13 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 13 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 13 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 13 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 13 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 13 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 13 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 13 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 13 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 13 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 13 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 13 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 13 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 13 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 13 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 13 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 13 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 13 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 13 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 13 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 13 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 13 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 13 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 47 p: 00 pc: 025B sp: FD x: 13 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 47 p: 81 pc: 025D sp: FD x: 13 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 47 p: 81 pc: 026C sp: FD x: 13 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 47 p: 00 pc: 026E sp: FD x: 13 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 47 p: 00 pc: 0270 sp: FD x: 13 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 47 p: 00 pc: 0259 sp: FD x: 13 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 47 p: 00 pc: 025B sp: FD x: 13 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 47 p: 00 pc: 025D sp: FD x: 13 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 47 p: 00 pc: 025F sp: FD x: 13 y: 02 
---
[1]    55 0261: 	sec
[2] a: 47 p: 00 pc: 0261 sp: FD x: 13 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 47 p: 01 pc: 0262 sp: FD x: 13 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 1F p: 00 pc: 0264 sp: FD x: 13 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 1F p: 00 pc: 0266 sp: FD x: 13 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 13 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 13 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 13 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 13 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 13 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 13 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 13 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 13 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 13 y: 02 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 13 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 13 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 13 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 13 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 13 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 13 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 13 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 13 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 13 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 13 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 13 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 13 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 13 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 13 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 13 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 13 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 13 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 13 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 13 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 13 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 13 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 13 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 13 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 13 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 13 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 13 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 13 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 13 y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 13 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 13 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 13 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 13 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 13 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 13 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 13 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 13 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 13 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 47 p: 01 pc: 0216 sp: FF x: 13 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 47 p: 01 pc: 0218 sp: FF x: 13 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 13 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 13 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 13 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 13 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 13 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 13 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 13 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 13 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 13 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 13 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 13 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 13 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 13 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 13 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 13 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 13 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 13 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 13 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 13 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 13 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 13 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 13 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 13 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 13 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 13 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 13 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 13 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 13 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 13 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 13 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 13 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 47 p: 00 pc: 025B sp: FD x: 13 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 47 p: 81 pc: 025D sp: FD x: 13 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 47 p: 81 pc: 026C sp: FD x: 13 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 47 p: 00 pc: 026E sp: FD x: 13 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 47 p: 00 pc: 0270 sp: FD x: 13 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 47 p: 00 pc: 0259 sp: FD x: 13 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 47 p: 00 pc: 025B sp: FD x: 13 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 47 p: 00 pc: 025D sp: FD x: 13 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 47 p: 00 pc: 025F sp: FD x: 13 y: 03 
---
[1]    55 0261: 	sec
[2] a: 47 p: 00 pc: 0261 sp: FD x: 13 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 47 p: 01 pc: 0262 sp: FD x: 13 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 13 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 13 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 13 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 13 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 13 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 13 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 13 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 13 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 13 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 13 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 13 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 13 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 13 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 13 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 13 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 13 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 13 y: 03 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 13 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 13 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 13 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 13 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 13 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 13 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 13 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 13 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 13 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 13 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 13 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 13 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 13 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 13 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 13 y: 03 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 13 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 13 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 13 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 13 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 13 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 13 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 13 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 13 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 13 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 47 p: 01 pc: 0216 sp: FF x: 13 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 47 p: 01 pc: 0218 sp: FF x: 13 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 13 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 13 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 13 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 13 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 13 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 13 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 13 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 13 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 13 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 13 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 13 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 13 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 13 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 13 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 13 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 13 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 13 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 13 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 13 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 13 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 13 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 13 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 13 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 00 pc: 0250 sp: FD x: 13 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 58 p: 00 pc: 0257 sp: FD x: 13 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 58 p: 00 pc: 0259 sp: FD x: 13 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 47 p: 00 pc: 025B sp: FD x: 13 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 47 p: 81 pc: 025D sp: FD x: 13 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 47 p: 81 pc: 026C sp: FD x: 13 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 47 p: 00 pc: 026E sp: FD x: 13 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 47 p: 00 pc: 0270 sp: FD x: 13 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 47 p: 00 pc: 0259 sp: FD x: 13 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 47 p: 00 pc: 025B sp: FD x: 13 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 47 p: 00 pc: 025D sp: FD x: 13 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 47 p: 00 pc: 025F sp: FD x: 13 y: 04 
---
[1]    55 0261: 	sec
[2] a: 47 p: 00 pc: 0261 sp: FD x: 13 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 47 p: 01 pc: 0262 sp: FD x: 13 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 13 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 13 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 13 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 13 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 13 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 13 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 13 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 13 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 13 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 13 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 13 y: 04 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 13 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 13 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 13 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 13 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 13 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 13 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 13 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 13 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 13 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 13 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 13 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 13 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 13 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 13 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 13 y: 04 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 13 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 13 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 13 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 13 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 13 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 13 y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 13 y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 47 p: 00 pc: 0231 sp: FF x: 13 y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 47 p: 00 pc: 0232 sp: FF x: 14 y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 47 p: 00 pc: 0235 sp: FF x: 14 y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 47 p: 00 pc: 0238 sp: FF x: 14 y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 47 p: 00 pc: 023B sp: FF x: 14 y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 49 p: 00 pc: 023E sp: FF x: 14 y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 49 p: 81 pc: 0240 sp: FF x: 14 y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 49 p: 81 pc: 0211 sp: FF x: 14 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 49 p: 01 pc: 0213 sp: FF x: 14 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 49 p: 01 pc: 0216 sp: FF x: 14 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 49 p: 01 pc: 0218 sp: FF x: 14 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 14 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 14 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 14 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 14 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 14 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 14 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 14 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 14 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 14 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 14 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 14 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 14 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 14 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 14 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 14 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 14 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 14 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 14 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 14 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 14 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 14 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 14 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 14 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 14 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 14 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 14 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 14 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 14 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 14 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 14 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 14 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 14 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 14 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 14 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 14 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 14 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 49 p: 00 pc: 025B sp: FD x: 14 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 49 p: 81 pc: 025D sp: FD x: 14 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 49 p: 81 pc: 026C sp: FD x: 14 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 49 p: 00 pc: 026E sp: FD x: 14 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 49 p: 00 pc: 0270 sp: FD x: 14 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 49 p: 00 pc: 0259 sp: FD x: 14 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 49 p: 00 pc: 025B sp: FD x: 14 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 49 p: 00 pc: 025D sp: FD x: 14 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 49 p: 00 pc: 025F sp: FD x: 14 y: 01 
---
[1]    55 0261: 	sec
[2] a: 49 p: 00 pc: 0261 sp: FD x: 14 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 49 p: 01 pc: 0262 sp: FD x: 14 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 14 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 14 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 14 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 14 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 14 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 14 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 14 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 14 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 14 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 14 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 14 y: 01 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 14 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 14 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 14 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 14 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 14 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 14 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 14 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 14 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 14 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 14 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 14 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 14 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 14 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 14 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 14 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 14 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 14 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 14 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 14 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 14 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 14 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 14 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 14 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 14 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 14 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 14 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 14 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 14 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 14 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 14 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 14 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 14 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 14 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 14 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 14 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 14 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 49 p: 01 pc: 0216 sp: FF x: 14 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 49 p: 01 pc: 0218 sp: FF x: 14 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 14 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 14 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 14 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 14 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 14 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 14 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 14 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 14 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 14 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 14 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 14 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 14 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 14 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 14 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 14 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 14 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 14 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 14 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 14 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 14 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 14 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 14 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 14 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 14 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 14 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 14 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 14 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 14 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 14 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 14 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 14 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 49 p: 00 pc: 025B sp: FD x: 14 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 49 p: 81 pc: 025D sp: FD x: 14 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 49 p: 81 pc: 026C sp: FD x: 14 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 49 p: 00 pc: 026E sp: FD x: 14 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 49 p: 00 pc: 0270 sp: FD x: 14 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 49 p: 00 pc: 0259 sp: FD x: 14 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 49 p: 00 pc: 025B sp: FD x: 14 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 49 p: 00 pc: 025D sp: FD x: 14 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 49 p: 00 pc: 025F sp: FD x: 14 y: 02 
---
[1]    55 0261: 	sec
[2] a: 49 p: 00 pc: 0261 sp: FD x: 14 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 49 p: 01 pc: 0262 sp: FD x: 14 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 14 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 14 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 14 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 14 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 14 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 14 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 14 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 14 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 14 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 14 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 14 y: 02 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 14 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 14 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 14 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 14 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 14 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 14 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 14 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 14 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 14 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 14 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 14 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 14 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 14 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 14 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 14 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 14 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 14 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 14 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 14 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 14 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 14 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 14 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 14 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 14 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 14 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 14 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 14 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 14 y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 14 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 14 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 14 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 14 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 14 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 14 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 14 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 14 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 14 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 49 p: 01 pc: 0216 sp: FF x: 14 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 49 p: 01 pc: 0218 sp: FF x: 14 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 14 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 14 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 14 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 14 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 14 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 14 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 14 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 14 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 14 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 14 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 14 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 14 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 14 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 14 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 14 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 14 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 14 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 14 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 14 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 14 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 14 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 14 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 14 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 14 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 14 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 14 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 14 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 14 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 14 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 14 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 14 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 49 p: 00 pc: 025B sp: FD x: 14 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 49 p: 81 pc: 025D sp: FD x: 14 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 49 p: 81 pc: 026C sp: FD x: 14 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 49 p: 00 pc: 026E sp: FD x: 14 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 49 p: 00 pc: 0270 sp: FD x: 14 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 49 p: 00 pc: 0259 sp: FD x: 14 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 49 p: 00 pc: 025B sp: FD x: 14 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 49 p: 00 pc: 025D sp: FD x: 14 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 49 p: 00 pc: 025F sp: FD x: 14 y: 03 
---
[1]    55 0261: 	sec
[2] a: 49 p: 00 pc: 0261 sp: FD x: 14 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 49 p: 01 pc: 0262 sp: FD x: 14 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 14 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 14 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 14 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 14 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 14 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 14 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 14 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 14 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 14 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 14 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 14 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 14 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 14 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 14 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 14 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 14 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 14 y: 03 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 14 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 14 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 14 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 14 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 14 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 14 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 14 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 14 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 14 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 14 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 14 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 14 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 14 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 14 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 14 y: 03 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 14 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 14 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 14 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 14 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 14 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 14 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 14 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 14 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 14 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 49 p: 01 pc: 0216 sp: FF x: 14 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 49 p: 01 pc: 0218 sp: FF x: 14 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 14 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 14 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 14 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 14 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 14 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 14 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 14 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 14 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 14 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 14 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 14 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 14 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 14 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 14 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 14 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 14 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 14 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 14 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 14 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 14 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 14 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 14 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 14 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 00 pc: 0250 sp: FD x: 14 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 58 p: 00 pc: 0257 sp: FD x: 14 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 58 p: 00 pc: 0259 sp: FD x: 14 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 49 p: 00 pc: 025B sp: FD x: 14 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 49 p: 81 pc: 025D sp: FD x: 14 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 49 p: 81 pc: 026C sp: FD x: 14 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 49 p: 00 pc: 026E sp: FD x: 14 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 49 p: 00 pc: 0270 sp: FD x: 14 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 49 p: 00 pc: 0259 sp: FD x: 14 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 49 p: 00 pc: 025B sp: FD x: 14 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 49 p: 00 pc: 025D sp: FD x: 14 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 49 p: 00 pc: 025F sp: FD x: 14 y: 04 
---
[1]    55 0261: 	sec
[2] a: 49 p: 00 pc: 0261 sp: FD x: 14 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 49 p: 01 pc: 0262 sp: FD x: 14 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 1D p: 00 pc: 0264 sp: FD x: 14 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 1D p: 00 pc: 0266 sp: FD x: 14 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 14 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 14 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 14 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 14 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 14 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 14 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 14 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 14 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 14 y: 04 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 14 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 14 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 14 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 14 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 14 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 14 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 14 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 14 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 14 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 14 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 14 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 14 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 14 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 14 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 14 y: 04 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 14 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 14 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 07 p: 01 pc: 0222 sp: FF x: 14 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 07 p: 01 pc: 0224 sp: FF x: 14 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 14 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 14 y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 14 y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 49 p: 00 pc: 0231 sp: FF x: 14 y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 49 p: 00 pc: 0232 sp: FF x: 15 y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 49 p: 00 pc: 0235 sp: FF x: 15 y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 49 p: 00 pc: 0238 sp: FF x: 15 y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 49 p: 00 pc: 023B sp: FF x: 15 y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 4B p: 00 pc: 023E sp: FF x: 15 y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 4B p: 81 pc: 0240 sp: FF x: 15 y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 4B p: 81 pc: 0211 sp: FF x: 15 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 4B p: 01 pc: 0213 sp: FF x: 15 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 4B p: 01 pc: 0216 sp: FF x: 15 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 4B p: 01 pc: 0218 sp: FF x: 15 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 15 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 15 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 15 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 15 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 15 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 15 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4B p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4B p: 81 pc: 025D sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4B p: 81 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4B p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4B p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4B p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4B p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4B p: 00 pc: 025D sp: FD x: 15 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 4B p: 00 pc: 025F sp: FD x: 15 y: 01 
---
[1]    55 0261: 	sec
[2] a: 4B p: 00 pc: 0261 sp: FD x: 15 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4B p: 01 pc: 0262 sp: FD x: 15 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 15 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 15 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 15 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 15 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 15 y: 01 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 15 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 15 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 15 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 15 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 15 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 15 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 15 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 15 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 15 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 15 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 15 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 15 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 19 p: 00 pc: 026A sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 00 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 01 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 03 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    64 0272: 	rts
[2] a: 19 p: 03 pc: 0272 sp: FD x: 15 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 19 p: 03 pc: 0220 sp: FF x: 15 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 15 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 15 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 15 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 15 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 4D p: 01 pc: 023E sp: FF x: 15 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 4D p: 81 pc: 0240 sp: FF x: 15 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 4D p: 81 pc: 0211 sp: FF x: 15 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 4D p: 01 pc: 0213 sp: FF x: 15 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 4D p: 01 pc: 0216 sp: FF x: 15 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 4D p: 01 pc: 0218 sp: FF x: 15 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 15 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 15 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 15 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 15 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 15 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 15 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4D p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4D p: 81 pc: 025D sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4D p: 81 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4D p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4D p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4D p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4D p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4D p: 00 pc: 025D sp: FD x: 15 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 4D p: 00 pc: 025F sp: FD x: 15 y: 01 
---
[1]    55 0261: 	sec
[2] a: 4D p: 00 pc: 0261 sp: FD x: 15 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4D p: 01 pc: 0262 sp: FD x: 15 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 1D p: 00 pc: 0264 sp: FD x: 15 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 1D p: 00 pc: 0266 sp: FD x: 15 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 15 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 15 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 15 y: 01 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 15 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 15 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 15 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 15 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 15 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 15 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 15 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 15 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 15 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 15 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 15 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 15 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 19 p: 00 pc: 026A sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 00 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 01 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 03 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    64 0272: 	rts
[2] a: 19 p: 03 pc: 0272 sp: FD x: 15 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 19 p: 03 pc: 0220 sp: FF x: 15 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 15 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 15 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 15 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 15 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 15 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 15 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 15 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 4D p: 01 pc: 0216 sp: FF x: 15 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 4D p: 01 pc: 0218 sp: FF x: 15 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 15 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 15 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 15 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 15 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 15 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 15 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 15 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 15 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 15 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 15 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 15 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 15 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 15 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 15 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 15 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 15 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 15 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 15 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 15 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 15 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 15 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 15 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 15 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 15 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 15 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 15 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 15 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 15 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 15 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 15 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 15 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4D p: 00 pc: 025B sp: FD x: 15 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4D p: 81 pc: 025D sp: FD x: 15 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4D p: 81 pc: 026C sp: FD x: 15 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 4D p: 00 pc: 026E sp: FD x: 15 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4D p: 00 pc: 0270 sp: FD x: 15 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4D p: 00 pc: 0259 sp: FD x: 15 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4D p: 00 pc: 025B sp: FD x: 15 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4D p: 00 pc: 025D sp: FD x: 15 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 4D p: 00 pc: 025F sp: FD x: 15 y: 02 
---
[1]    55 0261: 	sec
[2] a: 4D p: 00 pc: 0261 sp: FD x: 15 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4D p: 01 pc: 0262 sp: FD x: 15 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 25 p: 00 pc: 0264 sp: FD x: 15 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 25 p: 00 pc: 0266 sp: FD x: 15 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 15 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 15 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 15 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 15 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 15 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 15 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 15 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 15 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 15 y: 02 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 15 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 15 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 15 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 15 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 15 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 15 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 15 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 15 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 15 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 15 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 15 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 15 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 15 y: 02 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 15 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 15 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 15 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 15 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 15 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 15 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 15 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 15 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 15 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 15 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 15 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 15 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 15 y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 15 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 15 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 15 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 15 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0E p: 00 pc: 0268 sp: FD x: 15 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0F p: 00 pc: 026A sp: FD x: 15 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 00 pc: 026C sp: FD x: 15 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 01 pc: 026E sp: FD x: 15 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 03 pc: 0270 sp: FD x: 15 y: 02 
---
[1]    64 0272: 	rts
[2] a: 0F p: 03 pc: 0272 sp: FD x: 15 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0F p: 03 pc: 0220 sp: FF x: 15 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 15 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 15 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 15 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 15 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 15 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 15 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 15 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 4D p: 01 pc: 0216 sp: FF x: 15 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 4D p: 01 pc: 0218 sp: FF x: 15 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 15 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 15 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 15 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 15 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 15 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 15 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 15 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 15 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 15 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 15 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 15 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 15 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 15 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 15 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 15 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 15 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 15 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 15 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 15 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 15 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 15 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 15 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 15 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 15 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 15 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 15 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 15 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 15 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 15 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 15 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 15 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4D p: 00 pc: 025B sp: FD x: 15 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4D p: 81 pc: 025D sp: FD x: 15 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4D p: 81 pc: 026C sp: FD x: 15 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 4D p: 00 pc: 026E sp: FD x: 15 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4D p: 00 pc: 0270 sp: FD x: 15 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4D p: 00 pc: 0259 sp: FD x: 15 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4D p: 00 pc: 025B sp: FD x: 15 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4D p: 00 pc: 025D sp: FD x: 15 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 4D p: 00 pc: 025F sp: FD x: 15 y: 03 
---
[1]    55 0261: 	sec
[2] a: 4D p: 00 pc: 0261 sp: FD x: 15 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4D p: 01 pc: 0262 sp: FD x: 15 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 15 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 15 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 15 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 15 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 15 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 15 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 15 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 15 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 15 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 15 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 15 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 15 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 15 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 15 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 15 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 15 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 15 y: 03 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 15 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 15 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 15 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 15 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 15 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 15 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 15 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 15 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 15 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 15 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 15 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 02 pc: 025D sp: FD x: 15 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 02 pc: 025F sp: FD x: 15 y: 03 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 15 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 15 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 15 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 15 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 15 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 15 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 15 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 15 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 15 y: 03 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 15 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 15 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 15 y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 15 y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 15 y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 15 y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 4F p: 01 pc: 023E sp: FF x: 15 y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: 4F p: 81 pc: 0240 sp: FF x: 15 y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 4F p: 81 pc: 0211 sp: FF x: 15 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 4F p: 01 pc: 0213 sp: FF x: 15 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 4F p: 01 pc: 0216 sp: FF x: 15 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 4F p: 01 pc: 0218 sp: FF x: 15 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 15 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 15 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 15 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 15 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 15 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 15 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 15 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 15 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 15 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 15 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 15 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: 81 pc: 025D sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4F p: 81 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4F p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4F p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4F p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: 00 pc: 025D sp: FD x: 15 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 4F p: 00 pc: 025F sp: FD x: 15 y: 01 
---
[1]    55 0261: 	sec
[2] a: 4F p: 00 pc: 0261 sp: FD x: 15 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4F p: 01 pc: 0262 sp: FD x: 15 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 1F p: 00 pc: 0264 sp: FD x: 15 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 1F p: 00 pc: 0266 sp: FD x: 15 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 15 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 15 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 15 y: 01 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 15 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 15 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 15 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 15 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 15 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 15 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 15 y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 15 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 15 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 15 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 15 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 15 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1A p: 00 pc: 026A sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1A p: 00 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1A p: 00 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1A p: 00 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1A p: 00 pc: 0259 sp: FD x: 15 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 15 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 15 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 15 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 15 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 15 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 15 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 15 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 15 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 15 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 15 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 15 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 15 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 15 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 15 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 4F p: 01 pc: 0216 sp: FF x: 15 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 4F p: 01 pc: 0218 sp: FF x: 15 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 15 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 15 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 15 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 15 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 15 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 15 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 15 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 15 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 15 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 15 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 15 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 15 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 15 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 15 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 15 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 15 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 15 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 15 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 15 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 15 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 15 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 15 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 15 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 15 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 15 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 15 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 15 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 15 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 00 pc: 0250 sp: FD x: 15 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 50 p: 00 pc: 0257 sp: FD x: 15 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 15 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 00 pc: 025B sp: FD x: 15 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: 81 pc: 025D sp: FD x: 15 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4F p: 81 pc: 026C sp: FD x: 15 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 4F p: 00 pc: 026E sp: FD x: 15 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4F p: 00 pc: 0270 sp: FD x: 15 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4F p: 00 pc: 0259 sp: FD x: 15 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 00 pc: 025B sp: FD x: 15 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: 00 pc: 025D sp: FD x: 15 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 4F p: 00 pc: 025F sp: FD x: 15 y: 02 
---
[1]    55 0261: 	sec
[2] a: 4F p: 00 pc: 0261 sp: FD x: 15 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4F p: 01 pc: 0262 sp: FD x: 15 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 27 p: 00 pc: 0264 sp: FD x: 15 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 27 p: 00 pc: 0266 sp: FD x: 15 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 15 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 15 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 15 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 15 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 15 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 15 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 15 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 15 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 15 y: 02 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 15 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 15 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 15 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 15 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 15 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 15 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 15 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 15 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 15 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 15 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 15 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 15 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 15 y: 02 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 15 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 15 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 15 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 15 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 15 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 15 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 15 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 15 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 15 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 15 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 15 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 15 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 15 y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 15 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 15 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 15 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 15 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0E p: 00 pc: 0268 sp: FD x: 15 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0F p: 00 pc: 026A sp: FD x: 15 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 00 pc: 026C sp: FD x: 15 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 01 pc: 026E sp: FD x: 15 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 03 pc: 0270 sp: FD x: 15 y: 02 
---
[1]    64 0272: 	rts
[2] a: 0F p: 03 pc: 0272 sp: FD x: 15 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0F p: 03 pc: 0220 sp: FF x: 15 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 15 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 15 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 15 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 15 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 15 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 15 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 15 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 4F p: 01 pc: 0216 sp: FF x: 15 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 4F p: 01 pc: 0218 sp: FF x: 15 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 15 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 15 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 15 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 15 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 15 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 15 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 15 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 15 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 15 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 15 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 15 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 15 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 15 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 15 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 15 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 15 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 15 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 15 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 15 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 15 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 15 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 15 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 15 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 15 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 15 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 15 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 15 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 15 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 15 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 15 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 15 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 00 pc: 025B sp: FD x: 15 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: 81 pc: 025D sp: FD x: 15 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4F p: 81 pc: 026C sp: FD x: 15 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 4F p: 00 pc: 026E sp: FD x: 15 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4F p: 00 pc: 0270 sp: FD x: 15 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4F p: 00 pc: 0259 sp: FD x: 15 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 00 pc: 025B sp: FD x: 15 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: 00 pc: 025D sp: FD x: 15 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 4F p: 00 pc: 025F sp: FD x: 15 y: 03 
---
[1]    55 0261: 	sec
[2] a: 4F p: 00 pc: 0261 sp: FD x: 15 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4F p: 01 pc: 0262 sp: FD x: 15 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 15 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 15 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 15 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 15 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 15 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 15 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 15 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 15 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 15 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 15 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 15 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 15 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 15 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 15 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 15 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 15 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 15 y: 03 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 15 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 15 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 15 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 15 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 15 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 15 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 15 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 15 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 15 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 15 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 15 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 15 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 15 y: 03 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 15 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 15 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 15 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 15 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 15 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 15 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 15 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 15 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 15 y: 03 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 15 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 15 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 15 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 15 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 15 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 15 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 15 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 15 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 15 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 4F p: 01 pc: 0216 sp: FF x: 15 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 4F p: 01 pc: 0218 sp: FF x: 15 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 15 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 15 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 15 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 15 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 15 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 15 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 15 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 15 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 15 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 15 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 15 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 15 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 15 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 15 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 15 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 15 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 15 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 15 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 15 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 15 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 15 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 15 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 15 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 00 pc: 0250 sp: FD x: 15 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 58 p: 00 pc: 0257 sp: FD x: 15 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 58 p: 00 pc: 0259 sp: FD x: 15 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 00 pc: 025B sp: FD x: 15 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: 81 pc: 025D sp: FD x: 15 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4F p: 81 pc: 026C sp: FD x: 15 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 4F p: 00 pc: 026E sp: FD x: 15 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4F p: 00 pc: 0270 sp: FD x: 15 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4F p: 00 pc: 0259 sp: FD x: 15 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 00 pc: 025B sp: FD x: 15 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: 00 pc: 025D sp: FD x: 15 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 4F p: 00 pc: 025F sp: FD x: 15 y: 04 
---
[1]    55 0261: 	sec
[2] a: 4F p: 00 pc: 0261 sp: FD x: 15 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4F p: 01 pc: 0262 sp: FD x: 15 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 15 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 15 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 15 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 15 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 15 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 15 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 15 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 15 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 15 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 15 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 15 y: 04 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 15 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 15 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 15 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 15 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 15 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 15 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 15 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 15 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 15 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 15 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 15 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 15 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 15 y: 04 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 15 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 15 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 15 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 15 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 06 p: 00 pc: 0268 sp: FD x: 15 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 07 p: 00 pc: 026A sp: FD x: 15 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 00 pc: 026C sp: FD x: 15 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 15 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 15 y: 04 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 15 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 15 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 15 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 15 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 15 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 15 y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 15 y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 4F p: 00 pc: 0231 sp: FF x: 15 y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 4F p: 00 pc: 0232 sp: FF x: 16 y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 4F p: 00 pc: 0235 sp: FF x: 16 y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 4F p: 00 pc: 0238 sp: FF x: 16 y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 4F p: 00 pc: 023B sp: FF x: 16 y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 51 p: 00 pc: 023E sp: FF x: 16 y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 51 p: 81 pc: 0240 sp: FF x: 16 y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 51 p: 81 pc: 0211 sp: FF x: 16 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 51 p: 01 pc: 0213 sp: FF x: 16 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 51 p: 01 pc: 0216 sp: FF x: 16 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 51 p: 01 pc: 0218 sp: FF x: 16 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 16 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 16 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 16 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 16 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 16 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 16 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 16 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 16 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 16 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 16 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 16 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 16 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 16 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 16 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 16 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 16 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 16 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 16 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 16 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 16 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 16 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 16 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 16 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 16 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 16 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 16 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 16 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 16 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 16 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 16 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 16 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 16 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 16 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 16 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 16 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 16 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 51 p: 00 pc: 025B sp: FD x: 16 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 51 p: 81 pc: 025D sp: FD x: 16 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 51 p: 81 pc: 026C sp: FD x: 16 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 51 p: 00 pc: 026E sp: FD x: 16 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 51 p: 00 pc: 0270 sp: FD x: 16 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 51 p: 00 pc: 0259 sp: FD x: 16 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 51 p: 00 pc: 025B sp: FD x: 16 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 51 p: 00 pc: 025D sp: FD x: 16 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 51 p: 00 pc: 025F sp: FD x: 16 y: 01 
---
[1]    55 0261: 	sec
[2] a: 51 p: 00 pc: 0261 sp: FD x: 16 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 51 p: 01 pc: 0262 sp: FD x: 16 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 16 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 16 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 16 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 16 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 16 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 16 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 16 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 16 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 16 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 16 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 16 y: 01 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 16 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 16 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 16 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 16 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 16 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 16 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 16 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 16 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 16 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 16 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 16 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 16 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 16 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 16 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 16 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 16 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 16 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 16 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 16 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 16 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 16 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 16 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 16 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 16 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1A p: 00 pc: 026A sp: FD x: 16 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1A p: 00 pc: 026C sp: FD x: 16 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1A p: 00 pc: 026E sp: FD x: 16 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1A p: 00 pc: 0270 sp: FD x: 16 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1A p: 00 pc: 0259 sp: FD x: 16 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 16 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 16 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 16 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 16 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 16 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 16 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 16 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1A p: 00 pc: 0268 sp: FD x: 16 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1B p: 00 pc: 026A sp: FD x: 16 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 00 pc: 026C sp: FD x: 16 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 01 pc: 026E sp: FD x: 16 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 03 pc: 0270 sp: FD x: 16 y: 01 
---
[1]    64 0272: 	rts
[2] a: 1B p: 03 pc: 0272 sp: FD x: 16 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1B p: 03 pc: 0220 sp: FF x: 16 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 16 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 16 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 16 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 16 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 53 p: 01 pc: 023E sp: FF x: 16 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 53 p: 81 pc: 0240 sp: FF x: 16 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 53 p: 81 pc: 0211 sp: FF x: 16 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 53 p: 01 pc: 0213 sp: FF x: 16 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 53 p: 01 pc: 0216 sp: FF x: 16 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 53 p: 01 pc: 0218 sp: FF x: 16 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 16 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 16 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 16 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 16 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 16 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 16 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 16 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 16 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 16 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 16 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 16 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 16 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 16 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 16 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 16 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 16 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 16 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 16 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 16 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 16 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 16 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 16 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 16 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 16 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 16 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 16 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 16 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 16 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 16 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 16 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 16 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 16 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 16 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 16 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 16 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 16 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 53 p: 00 pc: 025B sp: FD x: 16 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 53 p: 81 pc: 025D sp: FD x: 16 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 53 p: 81 pc: 026C sp: FD x: 16 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 53 p: 00 pc: 026E sp: FD x: 16 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 53 p: 00 pc: 0270 sp: FD x: 16 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 53 p: 00 pc: 0259 sp: FD x: 16 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 53 p: 00 pc: 025B sp: FD x: 16 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 53 p: 00 pc: 025D sp: FD x: 16 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 53 p: 00 pc: 025F sp: FD x: 16 y: 01 
---
[1]    55 0261: 	sec
[2] a: 53 p: 00 pc: 0261 sp: FD x: 16 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 53 p: 01 pc: 0262 sp: FD x: 16 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 16 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 16 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 16 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 16 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 16 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 16 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 16 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 16 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 16 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 16 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 16 y: 01 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 16 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 16 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 16 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 16 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 16 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 16 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 16 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 16 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 16 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 16 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 16 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 16 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 16 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 16 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 16 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 16 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 16 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 16 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 16 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 16 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 16 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 16 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 16 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 16 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1A p: 00 pc: 026A sp: FD x: 16 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1A p: 00 pc: 026C sp: FD x: 16 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1A p: 00 pc: 026E sp: FD x: 16 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1A p: 00 pc: 0270 sp: FD x: 16 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1A p: 00 pc: 0259 sp: FD x: 16 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 16 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 16 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 16 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 16 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 16 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 16 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 16 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1A p: 00 pc: 0268 sp: FD x: 16 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1B p: 00 pc: 026A sp: FD x: 16 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 00 pc: 026C sp: FD x: 16 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 01 pc: 026E sp: FD x: 16 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 03 pc: 0270 sp: FD x: 16 y: 01 
---
[1]    64 0272: 	rts
[2] a: 1B p: 03 pc: 0272 sp: FD x: 16 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1B p: 03 pc: 0220 sp: FF x: 16 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 16 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 16 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 16 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 16 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 16 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 16 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 16 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 53 p: 01 pc: 0216 sp: FF x: 16 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 53 p: 01 pc: 0218 sp: FF x: 16 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 16 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 16 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 16 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 16 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 16 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 16 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 16 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 16 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 16 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 16 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 16 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 16 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 16 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 16 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 16 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 16 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 16 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 16 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 16 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 16 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 16 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 16 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 16 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 16 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 16 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 16 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 16 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 16 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 16 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 16 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 16 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 16 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 16 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 16 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 53 p: 00 pc: 025B sp: FD x: 16 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 53 p: 81 pc: 025D sp: FD x: 16 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 53 p: 81 pc: 026C sp: FD x: 16 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 53 p: 00 pc: 026E sp: FD x: 16 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 53 p: 00 pc: 0270 sp: FD x: 16 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 53 p: 00 pc: 0259 sp: FD x: 16 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 53 p: 00 pc: 025B sp: FD x: 16 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 53 p: 00 pc: 025D sp: FD x: 16 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 53 p: 00 pc: 025F sp: FD x: 16 y: 02 
---
[1]    55 0261: 	sec
[2] a: 53 p: 00 pc: 0261 sp: FD x: 16 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 53 p: 01 pc: 0262 sp: FD x: 16 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 16 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 16 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 16 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 16 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 16 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 16 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 16 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 16 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 16 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 16 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 16 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 16 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 16 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 16 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 16 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 16 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 16 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 16 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 16 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 16 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 16 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 16 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 16 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 16 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 16 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 16 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 16 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 16 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 16 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 16 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 16 y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 16 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 16 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 16 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 16 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 16 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 16 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 16 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 16 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 16 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 53 p: 01 pc: 0216 sp: FF x: 16 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 53 p: 01 pc: 0218 sp: FF x: 16 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 16 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 16 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 16 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 16 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 16 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 16 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 16 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 16 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 16 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 16 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 16 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 16 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 16 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 16 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 16 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 16 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 16 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 16 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 16 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 16 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 16 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 16 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 16 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 16 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 16 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 16 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 16 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 16 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 16 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 16 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 16 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 53 p: 00 pc: 025B sp: FD x: 16 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 53 p: 81 pc: 025D sp: FD x: 16 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 53 p: 81 pc: 026C sp: FD x: 16 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 53 p: 00 pc: 026E sp: FD x: 16 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 53 p: 00 pc: 0270 sp: FD x: 16 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 53 p: 00 pc: 0259 sp: FD x: 16 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 53 p: 00 pc: 025B sp: FD x: 16 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 53 p: 00 pc: 025D sp: FD x: 16 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 53 p: 00 pc: 025F sp: FD x: 16 y: 03 
---
[1]    55 0261: 	sec
[2] a: 53 p: 00 pc: 0261 sp: FD x: 16 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 53 p: 01 pc: 0262 sp: FD x: 16 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 16 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 16 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 16 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 16 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 16 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 16 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 16 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 16 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 16 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 16 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 16 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 16 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 16 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 16 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 16 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 16 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 16 y: 03 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 16 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 16 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 16 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 16 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 16 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 16 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 16 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 16 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 16 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 16 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 16 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 16 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 16 y: 03 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 16 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 16 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 16 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 16 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 16 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 16 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 16 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 16 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 16 y: 03 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 16 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 16 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 16 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 16 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 16 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 16 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 16 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 16 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 16 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 53 p: 01 pc: 0216 sp: FF x: 16 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 53 p: 01 pc: 0218 sp: FF x: 16 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 16 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 16 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 16 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 16 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 16 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 16 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 16 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 16 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 16 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 16 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 16 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 16 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 16 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 16 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 16 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 16 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 16 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 16 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 16 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 16 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 16 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 16 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 16 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 00 pc: 0250 sp: FD x: 16 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 58 p: 00 pc: 0257 sp: FD x: 16 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 58 p: 00 pc: 0259 sp: FD x: 16 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 53 p: 00 pc: 025B sp: FD x: 16 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 53 p: 81 pc: 025D sp: FD x: 16 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 53 p: 81 pc: 026C sp: FD x: 16 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 53 p: 00 pc: 026E sp: FD x: 16 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 53 p: 00 pc: 0270 sp: FD x: 16 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 53 p: 00 pc: 0259 sp: FD x: 16 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 53 p: 00 pc: 025B sp: FD x: 16 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 53 p: 00 pc: 025D sp: FD x: 16 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 53 p: 00 pc: 025F sp: FD x: 16 y: 04 
---
[1]    55 0261: 	sec
[2] a: 53 p: 00 pc: 0261 sp: FD x: 16 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 53 p: 01 pc: 0262 sp: FD x: 16 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 27 p: 00 pc: 0264 sp: FD x: 16 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 27 p: 00 pc: 0266 sp: FD x: 16 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 16 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 04 p: 00 pc: 026A sp: FD x: 16 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 04 p: 00 pc: 026C sp: FD x: 16 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 04 p: 00 pc: 026E sp: FD x: 16 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 04 p: 00 pc: 0270 sp: FD x: 16 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 04 p: 00 pc: 0259 sp: FD x: 16 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 16 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 16 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 16 y: 04 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 16 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 16 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 16 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 16 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 04 p: 00 pc: 0268 sp: FD x: 16 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 06 p: 00 pc: 026A sp: FD x: 16 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 06 p: 00 pc: 026C sp: FD x: 16 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 06 p: 00 pc: 026E sp: FD x: 16 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 06 p: 00 pc: 0270 sp: FD x: 16 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 06 p: 00 pc: 0259 sp: FD x: 16 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 16 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 16 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 16 y: 04 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 16 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 16 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 16 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 16 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 06 p: 00 pc: 0268 sp: FD x: 16 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 07 p: 00 pc: 026A sp: FD x: 16 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 00 pc: 026C sp: FD x: 16 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 16 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 16 y: 04 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 16 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 16 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 16 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 16 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 16 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 16 y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 16 y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 53 p: 00 pc: 0231 sp: FF x: 16 y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 53 p: 00 pc: 0232 sp: FF x: 17 y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 53 p: 00 pc: 0235 sp: FF x: 17 y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 53 p: 00 pc: 0238 sp: FF x: 17 y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 53 p: 00 pc: 023B sp: FF x: 17 y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 55 p: 00 pc: 023E sp: FF x: 17 y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 55 p: 81 pc: 0240 sp: FF x: 17 y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 55 p: 81 pc: 0211 sp: FF x: 17 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 55 p: 01 pc: 0213 sp: FF x: 17 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 55 p: 01 pc: 0216 sp: FF x: 17 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 55 p: 01 pc: 0218 sp: FF x: 17 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 17 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 17 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 17 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 17 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 17 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 17 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 55 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 55 p: 81 pc: 025D sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 55 p: 81 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 55 p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 55 p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 55 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 55 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 55 p: 00 pc: 025D sp: FD x: 17 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 55 p: 00 pc: 025F sp: FD x: 17 y: 01 
---
[1]    55 0261: 	sec
[2] a: 55 p: 00 pc: 0261 sp: FD x: 17 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 55 p: 01 pc: 0262 sp: FD x: 17 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 25 p: 00 pc: 0264 sp: FD x: 17 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 25 p: 00 pc: 0266 sp: FD x: 17 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 17 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 17 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 17 y: 01 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 17 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 17 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 17 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 17 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 17 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 17 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 17 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 17 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 17 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 17 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 17 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 17 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 17 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 17 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 17 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 17 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 17 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 17 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 17 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 17 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 17 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 55 p: 01 pc: 0216 sp: FF x: 17 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 55 p: 01 pc: 0218 sp: FF x: 17 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 17 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 17 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 17 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 17 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 17 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 17 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 17 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 17 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 17 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 17 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 17 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 17 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 17 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 17 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 17 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 17 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 17 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 17 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 17 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 17 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 17 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 17 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 17 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 17 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 17 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 17 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 17 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 17 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 17 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 17 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 17 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 17 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 17 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 17 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 55 p: 00 pc: 025B sp: FD x: 17 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 55 p: 81 pc: 025D sp: FD x: 17 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 55 p: 81 pc: 026C sp: FD x: 17 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 55 p: 00 pc: 026E sp: FD x: 17 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 55 p: 00 pc: 0270 sp: FD x: 17 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 55 p: 00 pc: 0259 sp: FD x: 17 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 55 p: 00 pc: 025B sp: FD x: 17 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 55 p: 00 pc: 025D sp: FD x: 17 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 55 p: 00 pc: 025F sp: FD x: 17 y: 02 
---
[1]    55 0261: 	sec
[2] a: 55 p: 00 pc: 0261 sp: FD x: 17 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 55 p: 01 pc: 0262 sp: FD x: 17 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 17 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 17 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 17 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 17 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 17 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 17 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 17 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 17 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 17 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 17 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 17 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 17 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 17 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 17 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 17 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 17 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 17 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 17 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 17 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 17 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 17 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 17 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 17 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 17 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 17 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 17 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 17 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 17 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 17 y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 17 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 17 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 17 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 17 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 17 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 17 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 17 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 17 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 17 y: 02 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 17 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 17 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 17 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 17 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 17 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 17 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 57 p: 01 pc: 023E sp: FF x: 17 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 57 p: 81 pc: 0240 sp: FF x: 17 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 57 p: 81 pc: 0211 sp: FF x: 17 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 57 p: 01 pc: 0213 sp: FF x: 17 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 57 p: 01 pc: 0216 sp: FF x: 17 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 57 p: 01 pc: 0218 sp: FF x: 17 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 17 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 17 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 17 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 17 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 17 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 17 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 57 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 57 p: 81 pc: 025D sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 57 p: 81 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 57 p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 57 p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 57 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 57 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 57 p: 00 pc: 025D sp: FD x: 17 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 57 p: 00 pc: 025F sp: FD x: 17 y: 01 
---
[1]    55 0261: 	sec
[2] a: 57 p: 00 pc: 0261 sp: FD x: 17 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 57 p: 01 pc: 0262 sp: FD x: 17 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 27 p: 00 pc: 0264 sp: FD x: 17 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 27 p: 00 pc: 0266 sp: FD x: 17 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 17 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 17 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 17 y: 01 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 17 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 17 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 17 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 17 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 17 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 17 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 17 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 17 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 17 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 17 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 17 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 17 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 17 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 17 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 17 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 17 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 17 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 17 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 17 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1D p: 00 pc: 026A sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 00 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 01 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 03 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    64 0272: 	rts
[2] a: 1D p: 03 pc: 0272 sp: FD x: 17 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1D p: 03 pc: 0220 sp: FF x: 17 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 17 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 17 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 17 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 17 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 59 p: 01 pc: 023E sp: FF x: 17 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 59 p: 81 pc: 0240 sp: FF x: 17 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 59 p: 81 pc: 0211 sp: FF x: 17 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 59 p: 01 pc: 0213 sp: FF x: 17 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 59 p: 01 pc: 0216 sp: FF x: 17 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 59 p: 01 pc: 0218 sp: FF x: 17 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 17 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 17 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 17 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 17 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 17 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 17 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 17 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 17 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 17 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 17 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 17 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 59 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 59 p: 81 pc: 025D sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 59 p: 81 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 59 p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 59 p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 59 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 59 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 59 p: 00 pc: 025D sp: FD x: 17 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 59 p: 00 pc: 025F sp: FD x: 17 y: 01 
---
[1]    55 0261: 	sec
[2] a: 59 p: 00 pc: 0261 sp: FD x: 17 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 59 p: 01 pc: 0262 sp: FD x: 17 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 29 p: 00 pc: 0264 sp: FD x: 17 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 29 p: 00 pc: 0266 sp: FD x: 17 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 17 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 00 pc: 025D sp: FD x: 17 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 29 p: 00 pc: 025F sp: FD x: 17 y: 01 
---
[1]    55 0261: 	sec
[2] a: 29 p: 00 pc: 0261 sp: FD x: 17 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 29 p: 01 pc: 0262 sp: FD x: 17 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 17 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 17 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 17 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 17 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 17 y: 01 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 17 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 17 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 17 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 17 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 17 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 17 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 17 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 17 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 17 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 17 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 17 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 17 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 17 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 17 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1D p: 00 pc: 026A sp: FD x: 17 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 00 pc: 026C sp: FD x: 17 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 01 pc: 026E sp: FD x: 17 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 03 pc: 0270 sp: FD x: 17 y: 01 
---
[1]    64 0272: 	rts
[2] a: 1D p: 03 pc: 0272 sp: FD x: 17 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1D p: 03 pc: 0220 sp: FF x: 17 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 17 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 17 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 17 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 17 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 17 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 17 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 17 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 59 p: 01 pc: 0216 sp: FF x: 17 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 59 p: 01 pc: 0218 sp: FF x: 17 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 17 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 17 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 17 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 17 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 17 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 17 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 17 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 17 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 17 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 17 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 17 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 17 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 17 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 17 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 17 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 17 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 17 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 17 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 17 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 17 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 17 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 17 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 17 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 17 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 17 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 17 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 17 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 17 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 17 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 17 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 17 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 17 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 17 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 17 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 59 p: 00 pc: 025B sp: FD x: 17 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 59 p: 81 pc: 025D sp: FD x: 17 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 59 p: 81 pc: 026C sp: FD x: 17 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 59 p: 00 pc: 026E sp: FD x: 17 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 59 p: 00 pc: 0270 sp: FD x: 17 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 59 p: 00 pc: 0259 sp: FD x: 17 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 59 p: 00 pc: 025B sp: FD x: 17 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 59 p: 00 pc: 025D sp: FD x: 17 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 59 p: 00 pc: 025F sp: FD x: 17 y: 02 
---
[1]    55 0261: 	sec
[2] a: 59 p: 00 pc: 0261 sp: FD x: 17 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 59 p: 01 pc: 0262 sp: FD x: 17 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 17 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 17 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 17 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 17 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 17 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 17 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 17 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 17 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 17 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 17 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 17 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 17 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 17 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 17 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 17 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 17 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 17 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 17 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 17 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 17 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 17 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 17 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 17 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 17 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 17 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 17 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 17 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 17 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 17 y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 17 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 17 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 17 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 17 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 17 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 17 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 17 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 17 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 17 y: 02 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 17 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 17 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 17 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 17 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 17 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 17 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 17 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 17 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 17 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 59 p: 01 pc: 0216 sp: FF x: 17 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 59 p: 01 pc: 0218 sp: FF x: 17 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 17 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 17 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 17 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 17 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 17 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 17 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 17 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 17 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 17 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 17 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 17 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 17 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 17 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 17 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 17 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 17 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 17 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 17 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 17 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 17 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 17 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 17 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 17 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 17 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 17 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 17 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 17 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 17 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 17 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 17 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 17 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 59 p: 00 pc: 025B sp: FD x: 17 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 59 p: 81 pc: 025D sp: FD x: 17 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 59 p: 81 pc: 026C sp: FD x: 17 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 59 p: 00 pc: 026E sp: FD x: 17 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 59 p: 00 pc: 0270 sp: FD x: 17 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 59 p: 00 pc: 0259 sp: FD x: 17 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 59 p: 00 pc: 025B sp: FD x: 17 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 59 p: 00 pc: 025D sp: FD x: 17 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 59 p: 00 pc: 025F sp: FD x: 17 y: 03 
---
[1]    55 0261: 	sec
[2] a: 59 p: 00 pc: 0261 sp: FD x: 17 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 59 p: 01 pc: 0262 sp: FD x: 17 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 17 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 17 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 17 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 17 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 17 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 17 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 17 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 17 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 17 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 17 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 17 y: 03 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 17 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 17 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 17 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 17 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 17 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 17 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 17 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 17 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 17 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 17 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 17 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 17 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 17 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 17 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 17 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 17 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 17 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 17 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 17 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 17 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 17 y: 03 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 17 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 17 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 17 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 17 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 17 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 17 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 17 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 17 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 17 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 59 p: 01 pc: 0216 sp: FF x: 17 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 59 p: 01 pc: 0218 sp: FF x: 17 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 17 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 17 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 17 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 17 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 17 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 17 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 17 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 17 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 17 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 17 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 17 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 17 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 17 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 17 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 17 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 17 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 17 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 17 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 17 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 17 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 17 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 17 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 17 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 17 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 17 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 17 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 17 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 17 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 17 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 59 p: 00 pc: 025B sp: FD x: 17 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 59 p: 81 pc: 025D sp: FD x: 17 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 59 p: 81 pc: 026C sp: FD x: 17 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 59 p: 00 pc: 026E sp: FD x: 17 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 59 p: 00 pc: 0270 sp: FD x: 17 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 59 p: 00 pc: 0259 sp: FD x: 17 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 59 p: 00 pc: 025B sp: FD x: 17 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 59 p: 00 pc: 025D sp: FD x: 17 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 59 p: 00 pc: 025F sp: FD x: 17 y: 04 
---
[1]    55 0261: 	sec
[2] a: 59 p: 00 pc: 0261 sp: FD x: 17 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 59 p: 01 pc: 0262 sp: FD x: 17 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 17 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 17 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 17 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 17 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 17 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 17 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 17 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 17 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 17 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 17 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 17 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 17 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 17 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 17 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 17 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 17 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 17 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 17 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 17 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 17 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 17 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 17 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 17 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 17 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 17 y: 04 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 17 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 17 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 17 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 17 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 17 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 17 y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 17 y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 59 p: 00 pc: 0231 sp: FF x: 17 y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 59 p: 00 pc: 0232 sp: FF x: 18 y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 59 p: 00 pc: 0235 sp: FF x: 18 y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 59 p: 00 pc: 0238 sp: FF x: 18 y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 59 p: 00 pc: 023B sp: FF x: 18 y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 5B p: 00 pc: 023E sp: FF x: 18 y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 5B p: 81 pc: 0240 sp: FF x: 18 y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 5B p: 81 pc: 0211 sp: FF x: 18 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 5B p: 01 pc: 0213 sp: FF x: 18 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 5B p: 01 pc: 0216 sp: FF x: 18 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 5B p: 01 pc: 0218 sp: FF x: 18 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 18 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 18 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 18 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 18 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 18 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 18 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5B p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5B p: 81 pc: 025D sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 5B p: 81 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 5B p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 5B p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 5B p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5B p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5B p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 5B p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 5B p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5B p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 2B p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 2B p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2B p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 2B p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2B p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1E p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1E p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1E p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1E p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1E p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 18 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 18 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 18 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 18 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 18 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 18 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 18 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 18 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 18 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 5B p: 01 pc: 0216 sp: FF x: 18 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 5B p: 01 pc: 0218 sp: FF x: 18 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 18 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 18 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 18 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 18 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 18 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 18 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5B p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5B p: 81 pc: 025D sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 5B p: 81 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 5B p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 5B p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 5B p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5B p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5B p: 00 pc: 025D sp: FD x: 18 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 5B p: 00 pc: 025F sp: FD x: 18 y: 02 
---
[1]    55 0261: 	sec
[2] a: 5B p: 00 pc: 0261 sp: FD x: 18 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5B p: 01 pc: 0262 sp: FD x: 18 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 18 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 18 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 18 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 18 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 18 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 18 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 18 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 18 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 18 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 18 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 18 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 18 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 18 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 18 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 18 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 18 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 18 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 18 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 18 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 5B p: 01 pc: 0216 sp: FF x: 18 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 5B p: 01 pc: 0218 sp: FF x: 18 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 18 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 18 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 18 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 18 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 18 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 18 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 18 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 18 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 18 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 18 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 18 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 18 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 18 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 18 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 18 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 18 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 18 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 18 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 18 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 18 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 18 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 18 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 18 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 18 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 18 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 18 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 18 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 18 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 18 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 18 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 18 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5B p: 00 pc: 025B sp: FD x: 18 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5B p: 81 pc: 025D sp: FD x: 18 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 5B p: 81 pc: 026C sp: FD x: 18 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 5B p: 00 pc: 026E sp: FD x: 18 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 5B p: 00 pc: 0270 sp: FD x: 18 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 5B p: 00 pc: 0259 sp: FD x: 18 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5B p: 00 pc: 025B sp: FD x: 18 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5B p: 00 pc: 025D sp: FD x: 18 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 5B p: 00 pc: 025F sp: FD x: 18 y: 03 
---
[1]    55 0261: 	sec
[2] a: 5B p: 00 pc: 0261 sp: FD x: 18 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5B p: 01 pc: 0262 sp: FD x: 18 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 18 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 18 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 18 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 18 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 18 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 18 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 18 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 18 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 18 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 18 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 18 y: 03 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 18 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 18 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 18 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 18 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 18 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 18 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 18 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 18 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 18 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 18 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 18 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 18 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 18 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 18 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 18 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 18 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 18 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 02 pc: 025D sp: FD x: 18 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 02 pc: 025F sp: FD x: 18 y: 03 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 18 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 18 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 18 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 18 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 18 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 18 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 18 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 18 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 18 y: 03 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 18 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 18 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 18 y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 18 y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 18 y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 18 y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 5D p: 01 pc: 023E sp: FF x: 18 y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: 5D p: 81 pc: 0240 sp: FF x: 18 y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 5D p: 81 pc: 0211 sp: FF x: 18 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 5D p: 01 pc: 0213 sp: FF x: 18 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 5D p: 01 pc: 0216 sp: FF x: 18 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 5D p: 01 pc: 0218 sp: FF x: 18 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 18 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 18 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 18 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 18 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 18 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 18 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5D p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5D p: 81 pc: 025D sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 5D p: 81 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 5D p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 5D p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 5D p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5D p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5D p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 5D p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 5D p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5D p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 2D p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 2D p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2D p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 2D p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2D p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1E p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1E p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1E p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1E p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1E p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1E p: 00 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1F p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 01 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 03 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    64 0272: 	rts
[2] a: 1F p: 03 pc: 0272 sp: FD x: 18 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1F p: 03 pc: 0220 sp: FF x: 18 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 18 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 18 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 18 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 18 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 5F p: 01 pc: 023E sp: FF x: 18 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 5F p: 81 pc: 0240 sp: FF x: 18 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 5F p: 81 pc: 0211 sp: FF x: 18 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 5F p: 01 pc: 0213 sp: FF x: 18 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 5F p: 01 pc: 0216 sp: FF x: 18 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 5F p: 01 pc: 0218 sp: FF x: 18 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 18 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 18 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 18 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 18 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 18 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 18 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 00 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 60 p: 00 pc: 0257 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 60 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5F p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5F p: 81 pc: 025D sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 5F p: 81 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 5F p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 5F p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 5F p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5F p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5F p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 5F p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 5F p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5F p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 2F p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 2F p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2F p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 2F p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2F p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1E p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1E p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1E p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1E p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1E p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1E p: 00 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1F p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 01 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 03 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    64 0272: 	rts
[2] a: 1F p: 03 pc: 0272 sp: FD x: 18 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1F p: 03 pc: 0220 sp: FF x: 18 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 18 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 18 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 18 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 18 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 18 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 18 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 18 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 5F p: 01 pc: 0216 sp: FF x: 18 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 5F p: 01 pc: 0218 sp: FF x: 18 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 18 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 18 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 18 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 18 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 18 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 18 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5F p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5F p: 81 pc: 025D sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 5F p: 81 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 5F p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 5F p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 5F p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5F p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5F p: 00 pc: 025D sp: FD x: 18 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 5F p: 00 pc: 025F sp: FD x: 18 y: 02 
---
[1]    55 0261: 	sec
[2] a: 5F p: 00 pc: 0261 sp: FD x: 18 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5F p: 01 pc: 0262 sp: FD x: 18 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 18 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 18 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 18 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 18 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 18 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 18 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 18 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 18 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 18 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 18 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 18 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 18 y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 18 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 18 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 18 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 18 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 12 p: 00 pc: 0268 sp: FD x: 18 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 13 p: 00 pc: 026A sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 00 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 01 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 03 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    64 0272: 	rts
[2] a: 13 p: 03 pc: 0272 sp: FD x: 18 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 13 p: 03 pc: 0220 sp: FF x: 18 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 18 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 18 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 18 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 18 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 61 p: 01 pc: 023E sp: FF x: 18 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 61 p: 81 pc: 0240 sp: FF x: 18 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 61 p: 81 pc: 0211 sp: FF x: 18 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 61 p: 01 pc: 0213 sp: FF x: 18 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 61 p: 01 pc: 0216 sp: FF x: 18 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 61 p: 01 pc: 0218 sp: FF x: 18 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 18 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 18 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 18 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 18 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 18 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 18 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 18 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 18 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 18 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 18 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 18 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 61 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 61 p: 81 pc: 025D sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 61 p: 81 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 61 p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 61 p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 61 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 61 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 61 p: 00 pc: 025D sp: FD x: 18 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 61 p: 00 pc: 025F sp: FD x: 18 y: 01 
---
[1]    55 0261: 	sec
[2] a: 61 p: 00 pc: 0261 sp: FD x: 18 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 61 p: 01 pc: 0262 sp: FD x: 18 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 18 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 18 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 18 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 18 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 18 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 18 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 18 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 18 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 18 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 18 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 18 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 18 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 18 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 18 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 18 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 18 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 18 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 18 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 61 p: 01 pc: 0216 sp: FF x: 18 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 61 p: 01 pc: 0218 sp: FF x: 18 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 18 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 18 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 18 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 18 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 18 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 18 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 18 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 18 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 18 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 18 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 18 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 61 p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 61 p: 81 pc: 025D sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 61 p: 81 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 61 p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 61 p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 61 p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 61 p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 61 p: 00 pc: 025D sp: FD x: 18 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 61 p: 00 pc: 025F sp: FD x: 18 y: 02 
---
[1]    55 0261: 	sec
[2] a: 61 p: 00 pc: 0261 sp: FD x: 18 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 61 p: 01 pc: 0262 sp: FD x: 18 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 18 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 18 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 18 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 18 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 18 y: 02 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 18 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 18 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 18 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 18 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 18 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 18 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 18 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 18 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 18 y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 18 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 18 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 18 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 18 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 12 p: 00 pc: 0268 sp: FD x: 18 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 13 p: 00 pc: 026A sp: FD x: 18 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 00 pc: 026C sp: FD x: 18 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 01 pc: 026E sp: FD x: 18 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 03 pc: 0270 sp: FD x: 18 y: 02 
---
[1]    64 0272: 	rts
[2] a: 13 p: 03 pc: 0272 sp: FD x: 18 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 13 p: 03 pc: 0220 sp: FF x: 18 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 18 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 18 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 18 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 18 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 18 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 18 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 18 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 61 p: 01 pc: 0216 sp: FF x: 18 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 61 p: 01 pc: 0218 sp: FF x: 18 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 18 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 18 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 18 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 18 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 18 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 18 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 18 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 18 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 18 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 18 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 18 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 18 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 18 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 18 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 18 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 18 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 18 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 18 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 18 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 18 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 18 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 18 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 18 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 18 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 18 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 18 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 18 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 18 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 18 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 18 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 18 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 61 p: 00 pc: 025B sp: FD x: 18 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 61 p: 81 pc: 025D sp: FD x: 18 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 61 p: 81 pc: 026C sp: FD x: 18 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 61 p: 00 pc: 026E sp: FD x: 18 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 61 p: 00 pc: 0270 sp: FD x: 18 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 61 p: 00 pc: 0259 sp: FD x: 18 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 61 p: 00 pc: 025B sp: FD x: 18 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 61 p: 00 pc: 025D sp: FD x: 18 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 61 p: 00 pc: 025F sp: FD x: 18 y: 03 
---
[1]    55 0261: 	sec
[2] a: 61 p: 00 pc: 0261 sp: FD x: 18 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 61 p: 01 pc: 0262 sp: FD x: 18 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 29 p: 00 pc: 0264 sp: FD x: 18 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 29 p: 00 pc: 0266 sp: FD x: 18 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 18 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 18 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 18 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 18 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 18 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 18 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 18 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 00 pc: 025D sp: FD x: 18 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 29 p: 00 pc: 025F sp: FD x: 18 y: 03 
---
[1]    55 0261: 	sec
[2] a: 29 p: 00 pc: 0261 sp: FD x: 18 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 29 p: 01 pc: 0262 sp: FD x: 18 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 18 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 18 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 18 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 18 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 18 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 18 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 18 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 18 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 18 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 18 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 18 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 18 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 18 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 18 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 18 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 18 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 18 y: 03 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 18 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 18 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 18 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 18 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 18 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 18 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 18 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 18 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 18 y: 03 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 18 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 18 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 18 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 18 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 18 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 18 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 18 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 18 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 18 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 61 p: 01 pc: 0216 sp: FF x: 18 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 61 p: 01 pc: 0218 sp: FF x: 18 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 18 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 18 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 18 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 18 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 18 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 18 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 18 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 18 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 18 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 18 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 18 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 18 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 18 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 18 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 18 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 18 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 18 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 18 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 18 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 18 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 18 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 18 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 18 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 18 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 18 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 18 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 18 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 18 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 18 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 61 p: 00 pc: 025B sp: FD x: 18 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 61 p: 81 pc: 025D sp: FD x: 18 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 61 p: 81 pc: 026C sp: FD x: 18 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 61 p: 00 pc: 026E sp: FD x: 18 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 61 p: 00 pc: 0270 sp: FD x: 18 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 61 p: 00 pc: 0259 sp: FD x: 18 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 61 p: 00 pc: 025B sp: FD x: 18 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 61 p: 00 pc: 025D sp: FD x: 18 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 61 p: 00 pc: 025F sp: FD x: 18 y: 04 
---
[1]    55 0261: 	sec
[2] a: 61 p: 00 pc: 0261 sp: FD x: 18 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 61 p: 01 pc: 0262 sp: FD x: 18 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 18 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 18 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 18 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 18 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 18 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 18 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 18 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 18 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 18 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 18 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 18 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 18 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 18 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 18 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 18 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 18 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 18 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 18 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 18 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 18 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 18 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 18 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 18 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 18 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 18 y: 04 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 18 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 18 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 09 p: 01 pc: 0222 sp: FF x: 18 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 09 p: 01 pc: 0224 sp: FF x: 18 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 18 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 18 y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 18 y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 61 p: 00 pc: 0231 sp: FF x: 18 y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 61 p: 00 pc: 0232 sp: FF x: 19 y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 61 p: 00 pc: 0235 sp: FF x: 19 y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 61 p: 00 pc: 0238 sp: FF x: 19 y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 61 p: 00 pc: 023B sp: FF x: 19 y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 63 p: 00 pc: 023E sp: FF x: 19 y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 63 p: 81 pc: 0240 sp: FF x: 19 y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 63 p: 81 pc: 0211 sp: FF x: 19 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 63 p: 01 pc: 0213 sp: FF x: 19 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 63 p: 01 pc: 0216 sp: FF x: 19 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 63 p: 01 pc: 0218 sp: FF x: 19 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 19 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 19 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 19 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 19 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 19 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 19 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 19 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 19 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 19 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 19 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 19 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 19 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 19 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 19 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 19 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 19 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 19 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 19 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 19 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 19 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 19 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 19 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 19 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 19 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 19 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 19 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 19 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 19 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 19 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 19 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 19 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 19 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 19 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 19 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 19 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 19 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 19 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 63 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 63 p: 81 pc: 025D sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 63 p: 81 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 63 p: 00 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 63 p: 00 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 63 p: 00 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 63 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 63 p: 00 pc: 025D sp: FD x: 19 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 63 p: 00 pc: 025F sp: FD x: 19 y: 01 
---
[1]    55 0261: 	sec
[2] a: 63 p: 00 pc: 0261 sp: FD x: 19 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 63 p: 01 pc: 0262 sp: FD x: 19 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 19 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 19 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 19 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 19 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 19 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 19 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 19 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 19 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 19 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 19 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 21 p: 00 pc: 026A sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 00 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 01 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 03 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    64 0272: 	rts
[2] a: 21 p: 03 pc: 0272 sp: FD x: 19 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 21 p: 03 pc: 0220 sp: FF x: 19 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 19 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 19 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 19 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 19 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 65 p: 01 pc: 023E sp: FF x: 19 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 65 p: 81 pc: 0240 sp: FF x: 19 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 65 p: 81 pc: 0211 sp: FF x: 19 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 65 p: 01 pc: 0213 sp: FF x: 19 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 65 p: 01 pc: 0216 sp: FF x: 19 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 65 p: 01 pc: 0218 sp: FF x: 19 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 19 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 19 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 19 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 19 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 19 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 19 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 19 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 19 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 19 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 19 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 19 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 19 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 19 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 19 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 19 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 19 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 19 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 19 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 19 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 19 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 19 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 19 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 19 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 19 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 19 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 19 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 19 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 19 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 19 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 19 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 19 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 19 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 19 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 19 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 19 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 19 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 19 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 65 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 65 p: 81 pc: 025D sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 65 p: 81 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 65 p: 00 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 65 p: 00 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 65 p: 00 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 65 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 65 p: 00 pc: 025D sp: FD x: 19 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 65 p: 00 pc: 025F sp: FD x: 19 y: 01 
---
[1]    55 0261: 	sec
[2] a: 65 p: 00 pc: 0261 sp: FD x: 19 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 65 p: 01 pc: 0262 sp: FD x: 19 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 19 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 19 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 19 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 19 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 19 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 19 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 19 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 19 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 19 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 19 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 19 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 19 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 21 p: 00 pc: 026A sp: FD x: 19 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 00 pc: 026C sp: FD x: 19 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 01 pc: 026E sp: FD x: 19 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 03 pc: 0270 sp: FD x: 19 y: 01 
---
[1]    64 0272: 	rts
[2] a: 21 p: 03 pc: 0272 sp: FD x: 19 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 21 p: 03 pc: 0220 sp: FF x: 19 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 19 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 19 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 19 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 19 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 19 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 19 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 19 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 65 p: 01 pc: 0216 sp: FF x: 19 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 65 p: 01 pc: 0218 sp: FF x: 19 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 19 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 19 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 19 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 19 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 19 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 19 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 19 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 19 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 19 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 19 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 19 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 19 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 19 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 19 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 19 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 19 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 19 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 19 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 19 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 19 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 19 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 19 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 19 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 19 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 19 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 19 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 19 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 19 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 19 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 19 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 19 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 19 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 19 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 19 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 65 p: 00 pc: 025B sp: FD x: 19 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 65 p: 81 pc: 025D sp: FD x: 19 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 65 p: 81 pc: 026C sp: FD x: 19 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 65 p: 00 pc: 026E sp: FD x: 19 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 65 p: 00 pc: 0270 sp: FD x: 19 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 65 p: 00 pc: 0259 sp: FD x: 19 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 65 p: 00 pc: 025B sp: FD x: 19 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 65 p: 00 pc: 025D sp: FD x: 19 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 65 p: 00 pc: 025F sp: FD x: 19 y: 02 
---
[1]    55 0261: 	sec
[2] a: 65 p: 00 pc: 0261 sp: FD x: 19 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 65 p: 01 pc: 0262 sp: FD x: 19 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 19 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 19 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 19 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 19 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 19 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 19 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 19 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 19 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 19 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 19 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 19 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 19 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 19 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 19 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 19 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 19 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 19 y: 02 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 19 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 19 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 19 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 19 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 19 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 19 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 19 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 19 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 19 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 19 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 19 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 19 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 19 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 19 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 19 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 19 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 19 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 19 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 19 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 19 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 19 y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 19 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 19 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 19 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 19 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 19 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 19 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 19 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 19 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 19 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 65 p: 01 pc: 0216 sp: FF x: 19 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 65 p: 01 pc: 0218 sp: FF x: 19 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 19 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 19 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 19 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 19 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 19 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 19 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 19 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 19 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 19 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 19 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 19 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 19 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 19 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 19 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 19 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 19 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 19 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 19 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 19 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 19 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 19 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 19 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 19 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 19 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 19 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 19 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 19 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 19 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 19 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 19 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 19 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 65 p: 00 pc: 025B sp: FD x: 19 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 65 p: 81 pc: 025D sp: FD x: 19 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 65 p: 81 pc: 026C sp: FD x: 19 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 65 p: 00 pc: 026E sp: FD x: 19 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 65 p: 00 pc: 0270 sp: FD x: 19 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 65 p: 00 pc: 0259 sp: FD x: 19 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 65 p: 00 pc: 025B sp: FD x: 19 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 65 p: 00 pc: 025D sp: FD x: 19 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 65 p: 00 pc: 025F sp: FD x: 19 y: 03 
---
[1]    55 0261: 	sec
[2] a: 65 p: 00 pc: 0261 sp: FD x: 19 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 65 p: 01 pc: 0262 sp: FD x: 19 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 2D p: 00 pc: 0264 sp: FD x: 19 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 2D p: 00 pc: 0266 sp: FD x: 19 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 19 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 19 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 19 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 19 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 19 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 19 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 19 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 00 pc: 025D sp: FD x: 19 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 2D p: 00 pc: 025F sp: FD x: 19 y: 03 
---
[1]    55 0261: 	sec
[2] a: 2D p: 00 pc: 0261 sp: FD x: 19 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2D p: 01 pc: 0262 sp: FD x: 19 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 19 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 19 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 19 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 19 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 19 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 19 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 19 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 19 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 19 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 19 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 19 y: 03 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 19 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 19 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 19 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 19 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 19 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 19 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 19 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 19 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 19 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 19 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 19 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 19 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 19 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 19 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 19 y: 03 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 19 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 19 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 19 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 19 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 19 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 19 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 19 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 19 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 19 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 65 p: 01 pc: 0216 sp: FF x: 19 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 65 p: 01 pc: 0218 sp: FF x: 19 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 19 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 19 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 19 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 19 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 19 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 19 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 19 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 19 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 19 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 19 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 19 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 19 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 19 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 19 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 19 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 19 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 19 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 19 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 19 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 19 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 19 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 19 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 19 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 19 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 19 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 19 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 19 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 19 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 19 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 65 p: 00 pc: 025B sp: FD x: 19 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 65 p: 81 pc: 025D sp: FD x: 19 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 65 p: 81 pc: 026C sp: FD x: 19 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 65 p: 00 pc: 026E sp: FD x: 19 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 65 p: 00 pc: 0270 sp: FD x: 19 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 65 p: 00 pc: 0259 sp: FD x: 19 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 65 p: 00 pc: 025B sp: FD x: 19 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 65 p: 00 pc: 025D sp: FD x: 19 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 65 p: 00 pc: 025F sp: FD x: 19 y: 04 
---
[1]    55 0261: 	sec
[2] a: 65 p: 00 pc: 0261 sp: FD x: 19 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 65 p: 01 pc: 0262 sp: FD x: 19 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 19 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 19 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 19 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 19 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 19 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 19 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 19 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 19 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 19 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 19 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 19 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 19 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 19 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 19 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 19 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 19 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 19 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 19 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 19 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 19 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 19 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 19 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 19 y: 04 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 19 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 19 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 19 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 19 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 19 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 09 p: 00 pc: 026A sp: FD x: 19 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 00 pc: 026C sp: FD x: 19 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 19 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 19 y: 04 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 19 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 19 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 19 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 19 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 19 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 19 y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 19 y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 65 p: 00 pc: 0231 sp: FF x: 19 y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 65 p: 00 pc: 0232 sp: FF x: 1A y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 65 p: 00 pc: 0235 sp: FF x: 1A y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 65 p: 00 pc: 0238 sp: FF x: 1A y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 65 p: 00 pc: 023B sp: FF x: 1A y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 67 p: 00 pc: 023E sp: FF x: 1A y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 67 p: 81 pc: 0240 sp: FF x: 1A y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 67 p: 81 pc: 0211 sp: FF x: 1A y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 67 p: 01 pc: 0213 sp: FF x: 1A y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 67 p: 01 pc: 0216 sp: FF x: 1A y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 67 p: 01 pc: 0218 sp: FF x: 1A y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1A y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1A y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1A y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1A y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1A y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1A y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1A y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 67 p: 00 pc: 025B sp: FD x: 1A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 67 p: 81 pc: 025D sp: FD x: 1A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 67 p: 81 pc: 026C sp: FD x: 1A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 67 p: 00 pc: 026E sp: FD x: 1A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 67 p: 00 pc: 0270 sp: FD x: 1A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 67 p: 00 pc: 0259 sp: FD x: 1A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 67 p: 00 pc: 025B sp: FD x: 1A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 67 p: 00 pc: 025D sp: FD x: 1A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 67 p: 00 pc: 025F sp: FD x: 1A y: 01 
---
[1]    55 0261: 	sec
[2] a: 67 p: 00 pc: 0261 sp: FD x: 1A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 67 p: 01 pc: 0262 sp: FD x: 1A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 1A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 1A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 1A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 1A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 1A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 1A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 1A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 1A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 1A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 1A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 1A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 1A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 1A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 1A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 1A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 1A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 1A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 1A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 1A y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 1A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 1A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 1A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 1A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 22 p: 00 pc: 026A sp: FD x: 1A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 22 p: 00 pc: 026C sp: FD x: 1A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 22 p: 00 pc: 026E sp: FD x: 1A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 22 p: 00 pc: 0270 sp: FD x: 1A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 22 p: 00 pc: 0259 sp: FD x: 1A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 1A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 1A y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 1A y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 1A y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 1A y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 1A y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 1A y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 1A y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 1A y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 1A y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 1A y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 67 p: 01 pc: 0216 sp: FF x: 1A y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 67 p: 01 pc: 0218 sp: FF x: 1A y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 1A y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 1A y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 1A y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1A y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1A y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1A y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 1A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 1A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 1A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 1A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 1A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 1A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 1A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 1A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 1A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 1A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 1A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 1A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 1A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 1A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 1A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 1A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 1A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 1A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 1A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 1A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 1A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 1A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 1A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 1A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 1A y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 1A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 1A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 67 p: 00 pc: 025B sp: FD x: 1A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 67 p: 81 pc: 025D sp: FD x: 1A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 67 p: 81 pc: 026C sp: FD x: 1A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 67 p: 00 pc: 026E sp: FD x: 1A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 67 p: 00 pc: 0270 sp: FD x: 1A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 67 p: 00 pc: 0259 sp: FD x: 1A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 67 p: 00 pc: 025B sp: FD x: 1A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 67 p: 00 pc: 025D sp: FD x: 1A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 67 p: 00 pc: 025F sp: FD x: 1A y: 02 
---
[1]    55 0261: 	sec
[2] a: 67 p: 00 pc: 0261 sp: FD x: 1A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 67 p: 01 pc: 0262 sp: FD x: 1A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 1A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 1A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 1A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 1A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 1A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 1A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 1A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 1A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 1A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 1A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 1A y: 02 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 1A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 1A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 1A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 1A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 1A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 1A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 1A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 1A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 1A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 1A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 1A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 1A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 1A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 1A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 1A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 1A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 1A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 1A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 1A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 1A y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 1A y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 1A y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 1A y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 1A y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 1A y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 1A y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 1A y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 1A y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 1A y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 67 p: 01 pc: 0216 sp: FF x: 1A y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 67 p: 01 pc: 0218 sp: FF x: 1A y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 1A y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 1A y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 1A y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1A y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1A y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1A y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 1A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 1A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 1A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 1A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 1A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 1A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 1A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 1A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 1A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 1A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 1A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 1A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 1A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 1A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 1A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 1A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 1A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 1A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 1A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 1A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 1A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 1A y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 1A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 1A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 67 p: 00 pc: 025B sp: FD x: 1A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 67 p: 81 pc: 025D sp: FD x: 1A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 67 p: 81 pc: 026C sp: FD x: 1A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 67 p: 00 pc: 026E sp: FD x: 1A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 67 p: 00 pc: 0270 sp: FD x: 1A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 67 p: 00 pc: 0259 sp: FD x: 1A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 67 p: 00 pc: 025B sp: FD x: 1A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 67 p: 00 pc: 025D sp: FD x: 1A y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 67 p: 00 pc: 025F sp: FD x: 1A y: 03 
---
[1]    55 0261: 	sec
[2] a: 67 p: 00 pc: 0261 sp: FD x: 1A y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 67 p: 01 pc: 0262 sp: FD x: 1A y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 2F p: 00 pc: 0264 sp: FD x: 1A y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 2F p: 00 pc: 0266 sp: FD x: 1A y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1A y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 1A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 1A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 1A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 1A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 1A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 1A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 00 pc: 025D sp: FD x: 1A y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 2F p: 00 pc: 025F sp: FD x: 1A y: 03 
---
[1]    55 0261: 	sec
[2] a: 2F p: 00 pc: 0261 sp: FD x: 1A y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2F p: 01 pc: 0262 sp: FD x: 1A y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 1A y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 1A y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 1A y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 1A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 1A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 1A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 1A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 1A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 1A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 1A y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 1A y: 03 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 1A y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 1A y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 1A y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 1A y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 1A y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 1A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 1A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 1A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 1A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 1A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 1A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 1A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 1A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 1A y: 03 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 1A y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 1A y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 1A y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 1A y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 1A y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 1A y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 1A y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 1A y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 1A y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 67 p: 01 pc: 0216 sp: FF x: 1A y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 67 p: 01 pc: 0218 sp: FF x: 1A y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 1A y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 1A y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 1A y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1A y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1A y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1A y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1A y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 1A y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 1A y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 1A y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 1A y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 1A y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 1A y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 1A y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 1A y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 1A y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 1A y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 1A y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 1A y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 1A y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 1A y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 1A y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 1A y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 1A y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 1A y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 1A y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 1A y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 1A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 1A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 67 p: 00 pc: 025B sp: FD x: 1A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 67 p: 81 pc: 025D sp: FD x: 1A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 67 p: 81 pc: 026C sp: FD x: 1A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 67 p: 00 pc: 026E sp: FD x: 1A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 67 p: 00 pc: 0270 sp: FD x: 1A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 67 p: 00 pc: 0259 sp: FD x: 1A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 67 p: 00 pc: 025B sp: FD x: 1A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 67 p: 00 pc: 025D sp: FD x: 1A y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 67 p: 00 pc: 025F sp: FD x: 1A y: 04 
---
[1]    55 0261: 	sec
[2] a: 67 p: 00 pc: 0261 sp: FD x: 1A y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 67 p: 01 pc: 0262 sp: FD x: 1A y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 1A y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 1A y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1A y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 1A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 1A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 1A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 1A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 1A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 1A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 1A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 1A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 1A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 1A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 1A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 1A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 1A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 1A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 1A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 1A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 1A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 1A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 1A y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 1A y: 04 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 1A y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 1A y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 1A y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 1A y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 1A y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 09 p: 00 pc: 026A sp: FD x: 1A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 00 pc: 026C sp: FD x: 1A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 1A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 1A y: 04 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 1A y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 1A y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 1A y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 1A y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 1A y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 1A y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 1A y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 67 p: 00 pc: 0231 sp: FF x: 1A y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 67 p: 00 pc: 0232 sp: FF x: 1B y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 67 p: 00 pc: 0235 sp: FF x: 1B y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 67 p: 00 pc: 0238 sp: FF x: 1B y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 67 p: 00 pc: 023B sp: FF x: 1B y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 69 p: 00 pc: 023E sp: FF x: 1B y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 69 p: 81 pc: 0240 sp: FF x: 1B y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 69 p: 81 pc: 0211 sp: FF x: 1B y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 69 p: 01 pc: 0213 sp: FF x: 1B y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 69 p: 01 pc: 0216 sp: FF x: 1B y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 69 p: 01 pc: 0218 sp: FF x: 1B y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1B y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1B y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1B y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1B y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1B y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1B y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1B y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 69 p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 69 p: 81 pc: 025D sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 69 p: 81 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 69 p: 00 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 69 p: 00 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 69 p: 00 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 69 p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 69 p: 00 pc: 025D sp: FD x: 1B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 69 p: 00 pc: 025F sp: FD x: 1B y: 01 
---
[1]    55 0261: 	sec
[2] a: 69 p: 00 pc: 0261 sp: FD x: 1B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 69 p: 01 pc: 0262 sp: FD x: 1B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 1B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 1B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 1B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 1B y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 1B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 1B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 1B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 1B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 22 p: 00 pc: 026A sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 22 p: 00 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 22 p: 00 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 22 p: 00 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 22 p: 00 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 1B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 1B y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 1B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 1B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 1B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 1B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 22 p: 00 pc: 0268 sp: FD x: 1B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 23 p: 00 pc: 026A sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 00 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 01 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 03 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    64 0272: 	rts
[2] a: 23 p: 03 pc: 0272 sp: FD x: 1B y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 23 p: 03 pc: 0220 sp: FF x: 1B y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 1B y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 1B y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 1B y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 1B y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 6B p: 01 pc: 023E sp: FF x: 1B y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 6B p: 81 pc: 0240 sp: FF x: 1B y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 6B p: 81 pc: 0211 sp: FF x: 1B y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 6B p: 01 pc: 0213 sp: FF x: 1B y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 6B p: 01 pc: 0216 sp: FF x: 1B y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 6B p: 01 pc: 0218 sp: FF x: 1B y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1B y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1B y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1B y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1B y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1B y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1B y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1B y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6B p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6B p: 81 pc: 025D sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 6B p: 81 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 6B p: 00 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 6B p: 00 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 6B p: 00 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6B p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6B p: 00 pc: 025D sp: FD x: 1B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 6B p: 00 pc: 025F sp: FD x: 1B y: 01 
---
[1]    55 0261: 	sec
[2] a: 6B p: 00 pc: 0261 sp: FD x: 1B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 6B p: 01 pc: 0262 sp: FD x: 1B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 1B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 1B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 1B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 1B y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 1B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 1B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 1B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 1B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 22 p: 00 pc: 026A sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 22 p: 00 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 22 p: 00 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 22 p: 00 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 22 p: 00 pc: 0259 sp: FD x: 1B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 1B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 1B y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 1B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 1B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 1B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 1B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 22 p: 00 pc: 0268 sp: FD x: 1B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 23 p: 00 pc: 026A sp: FD x: 1B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 00 pc: 026C sp: FD x: 1B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 01 pc: 026E sp: FD x: 1B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 03 pc: 0270 sp: FD x: 1B y: 01 
---
[1]    64 0272: 	rts
[2] a: 23 p: 03 pc: 0272 sp: FD x: 1B y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 23 p: 03 pc: 0220 sp: FF x: 1B y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 1B y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 1B y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 1B y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 1B y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 1B y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 1B y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 1B y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 6B p: 01 pc: 0216 sp: FF x: 1B y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 6B p: 01 pc: 0218 sp: FF x: 1B y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 1B y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 1B y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 1B y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1B y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1B y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1B y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 1B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 1B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 1B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 1B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 1B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 1B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 1B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 1B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 1B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 1B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 1B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 1B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 1B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 1B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 1B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 1B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 1B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 1B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 1B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 1B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 1B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 1B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 1B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 1B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 1B y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 1B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 1B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6B p: 00 pc: 025B sp: FD x: 1B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6B p: 81 pc: 025D sp: FD x: 1B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 6B p: 81 pc: 026C sp: FD x: 1B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 6B p: 00 pc: 026E sp: FD x: 1B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 6B p: 00 pc: 0270 sp: FD x: 1B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 6B p: 00 pc: 0259 sp: FD x: 1B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6B p: 00 pc: 025B sp: FD x: 1B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6B p: 00 pc: 025D sp: FD x: 1B y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 6B p: 00 pc: 025F sp: FD x: 1B y: 02 
---
[1]    55 0261: 	sec
[2] a: 6B p: 00 pc: 0261 sp: FD x: 1B y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 6B p: 01 pc: 0262 sp: FD x: 1B y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 1B y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 1B y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1B y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 1B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 1B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 1B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 1B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 1B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 1B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 1B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 1B y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 1B y: 02 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 1B y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 1B y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 1B y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 1B y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1B y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 1B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 1B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 1B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 1B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 1B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 1B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 1B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 1B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 1B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 1B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 1B y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 1B y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 1B y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 1B y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 1B y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 1B y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 1B y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 15 p: 00 pc: 026A sp: FD x: 1B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 00 pc: 026C sp: FD x: 1B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 01 pc: 026E sp: FD x: 1B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 03 pc: 0270 sp: FD x: 1B y: 02 
---
[1]    64 0272: 	rts
[2] a: 15 p: 03 pc: 0272 sp: FD x: 1B y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 15 p: 03 pc: 0220 sp: FF x: 1B y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 1B y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 1B y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 1B y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 1B y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 1B y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 1B y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 1B y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 6B p: 01 pc: 0216 sp: FF x: 1B y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 6B p: 01 pc: 0218 sp: FF x: 1B y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 1B y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 1B y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 1B y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1B y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1B y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1B y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 1B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 1B y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 1B y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 1B y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 1B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 1B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 1B y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 1B y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 1B y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 1B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 1B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 1B y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 1B y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 1B y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 1B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 1B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 1B y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 1B y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 1B y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 1B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 1B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 1B y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 1B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 1B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6B p: 00 pc: 025B sp: FD x: 1B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6B p: 81 pc: 025D sp: FD x: 1B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 6B p: 81 pc: 026C sp: FD x: 1B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 6B p: 00 pc: 026E sp: FD x: 1B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 6B p: 00 pc: 0270 sp: FD x: 1B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 6B p: 00 pc: 0259 sp: FD x: 1B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6B p: 00 pc: 025B sp: FD x: 1B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6B p: 00 pc: 025D sp: FD x: 1B y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 6B p: 00 pc: 025F sp: FD x: 1B y: 03 
---
[1]    55 0261: 	sec
[2] a: 6B p: 00 pc: 0261 sp: FD x: 1B y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 6B p: 01 pc: 0262 sp: FD x: 1B y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 33 p: 00 pc: 0264 sp: FD x: 1B y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 33 p: 00 pc: 0266 sp: FD x: 1B y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1B y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 1B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 1B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 1B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 1B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 1B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 1B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 00 pc: 025D sp: FD x: 1B y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 33 p: 00 pc: 025F sp: FD x: 1B y: 03 
---
[1]    55 0261: 	sec
[2] a: 33 p: 00 pc: 0261 sp: FD x: 1B y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 33 p: 01 pc: 0262 sp: FD x: 1B y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 1B y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 1B y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 1B y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 1B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 1B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 1B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 1B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 1B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 1B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 1B y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 1B y: 03 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 1B y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 1B y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 1B y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 1B y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 1B y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 1B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 1B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 1B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 1B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 1B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 1B y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 1B y: 03 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 1B y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 1B y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 1B y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 1B y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0E p: 00 pc: 0268 sp: FD x: 1B y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0F p: 00 pc: 026A sp: FD x: 1B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 00 pc: 026C sp: FD x: 1B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 01 pc: 026E sp: FD x: 1B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 03 pc: 0270 sp: FD x: 1B y: 03 
---
[1]    64 0272: 	rts
[2] a: 0F p: 03 pc: 0272 sp: FD x: 1B y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0F p: 03 pc: 0220 sp: FF x: 1B y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 1B y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 1B y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 1B y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 1B y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 1B y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 1B y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 1B y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 6B p: 01 pc: 0216 sp: FF x: 1B y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 6B p: 01 pc: 0218 sp: FF x: 1B y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 1B y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 1B y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 1B y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1B y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1B y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1B y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1B y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 1B y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 1B y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 1B y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 1B y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 1B y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 1B y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 1B y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 1B y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 1B y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 1B y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 1B y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 1B y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 1B y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 1B y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 1B y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 1B y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 1B y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 1B y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 1B y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 1B y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 1B y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 1B y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6B p: 00 pc: 025B sp: FD x: 1B y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6B p: 81 pc: 025D sp: FD x: 1B y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 6B p: 81 pc: 026C sp: FD x: 1B y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 6B p: 00 pc: 026E sp: FD x: 1B y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 6B p: 00 pc: 0270 sp: FD x: 1B y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 6B p: 00 pc: 0259 sp: FD x: 1B y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6B p: 00 pc: 025B sp: FD x: 1B y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6B p: 00 pc: 025D sp: FD x: 1B y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 6B p: 00 pc: 025F sp: FD x: 1B y: 04 
---
[1]    55 0261: 	sec
[2] a: 6B p: 00 pc: 0261 sp: FD x: 1B y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 6B p: 01 pc: 0262 sp: FD x: 1B y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 1B y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 1B y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1B y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 1B y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 1B y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 1B y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 1B y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 1B y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 1B y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 1B y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 1B y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 1B y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 1B y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 1B y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 1B y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 1B y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 1B y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 1B y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 1B y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 1B y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 1B y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 1B y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 1B y: 04 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 1B y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 1B y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 08 p: 00 pc: 0264 sp: FD x: 1B y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 08 p: 00 pc: 0266 sp: FD x: 1B y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 1B y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 09 p: 00 pc: 026A sp: FD x: 1B y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 00 pc: 026C sp: FD x: 1B y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 1B y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 1B y: 04 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 1B y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 1B y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 08 p: 01 pc: 0222 sp: FF x: 1B y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 08 p: 01 pc: 0224 sp: FF x: 1B y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 1B y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 1B y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 1B y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 6B p: 00 pc: 0231 sp: FF x: 1B y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 6B p: 00 pc: 0232 sp: FF x: 1C y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 6B p: 00 pc: 0235 sp: FF x: 1C y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 6B p: 00 pc: 0238 sp: FF x: 1C y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 6B p: 00 pc: 023B sp: FF x: 1C y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 6D p: 00 pc: 023E sp: FF x: 1C y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 6D p: 81 pc: 0240 sp: FF x: 1C y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 6D p: 81 pc: 0211 sp: FF x: 1C y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 6D p: 01 pc: 0213 sp: FF x: 1C y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 6D p: 01 pc: 0216 sp: FF x: 1C y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 6D p: 01 pc: 0218 sp: FF x: 1C y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1C y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1C y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1C y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1C y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1C y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1C y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1C y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6D p: 00 pc: 025B sp: FD x: 1C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6D p: 81 pc: 025D sp: FD x: 1C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 6D p: 81 pc: 026C sp: FD x: 1C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 6D p: 00 pc: 026E sp: FD x: 1C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 6D p: 00 pc: 0270 sp: FD x: 1C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 6D p: 00 pc: 0259 sp: FD x: 1C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6D p: 00 pc: 025B sp: FD x: 1C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6D p: 00 pc: 025D sp: FD x: 1C y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 6D p: 00 pc: 025F sp: FD x: 1C y: 01 
---
[1]    55 0261: 	sec
[2] a: 6D p: 00 pc: 0261 sp: FD x: 1C y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 6D p: 01 pc: 0262 sp: FD x: 1C y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 1C y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 1C y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1C y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 1C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 1C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 1C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 1C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 1C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 1C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 1C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 1C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 1C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 1C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 1C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 1C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 1C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 1C y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 1C y: 01 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 1C y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 1C y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 1C y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 1C y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1C y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 1C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 1C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 1C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 1C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 1C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 1C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 1C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 1C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 1C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 1C y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 1C y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 1C y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 1C y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 1C y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 1C y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 1C y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 1C y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 1C y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 1C y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 6D p: 01 pc: 0216 sp: FF x: 1C y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 6D p: 01 pc: 0218 sp: FF x: 1C y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 1C y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 1C y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 1C y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1C y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1C y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1C y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 1C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 1C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 1C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 1C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 1C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 1C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 1C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 1C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 1C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 1C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 1C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 1C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 1C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 1C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 1C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 1C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 1C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 1C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 1C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 1C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 1C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 1C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 1C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 1C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 1C y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 1C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 1C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6D p: 00 pc: 025B sp: FD x: 1C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6D p: 81 pc: 025D sp: FD x: 1C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 6D p: 81 pc: 026C sp: FD x: 1C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 6D p: 00 pc: 026E sp: FD x: 1C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 6D p: 00 pc: 0270 sp: FD x: 1C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 6D p: 00 pc: 0259 sp: FD x: 1C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6D p: 00 pc: 025B sp: FD x: 1C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6D p: 00 pc: 025D sp: FD x: 1C y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 6D p: 00 pc: 025F sp: FD x: 1C y: 02 
---
[1]    55 0261: 	sec
[2] a: 6D p: 00 pc: 0261 sp: FD x: 1C y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 6D p: 01 pc: 0262 sp: FD x: 1C y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 1D p: 00 pc: 0264 sp: FD x: 1C y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 1D p: 00 pc: 0266 sp: FD x: 1C y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1C y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 1C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 81 pc: 025D sp: FD x: 1C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 81 pc: 026C sp: FD x: 1C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 00 pc: 026E sp: FD x: 1C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 00 pc: 0270 sp: FD x: 1C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1D p: 00 pc: 0259 sp: FD x: 1C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 1C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 1C y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 1C y: 02 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 1C y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 1C y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 1C y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 1C y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1C y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 1C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 1C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 1C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 1C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 1C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 1C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 1C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 1C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 1C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 1C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 1C y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 1C y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 1C y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 1C y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 1C y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 1C y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 1C y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 15 p: 00 pc: 026A sp: FD x: 1C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 00 pc: 026C sp: FD x: 1C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 01 pc: 026E sp: FD x: 1C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 03 pc: 0270 sp: FD x: 1C y: 02 
---
[1]    64 0272: 	rts
[2] a: 15 p: 03 pc: 0272 sp: FD x: 1C y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 15 p: 03 pc: 0220 sp: FF x: 1C y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 1C y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 1C y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 1C y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 1C y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 1C y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 1C y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 1C y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 6D p: 01 pc: 0216 sp: FF x: 1C y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 6D p: 01 pc: 0218 sp: FF x: 1C y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 1C y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 1C y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 1C y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1C y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1C y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1C y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 1C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 1C y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 1C y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 1C y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 1C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 1C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 1C y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 1C y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 1C y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 1C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 1C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 1C y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 1C y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 1C y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 1C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 1C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 1C y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 1C y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 1C y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 1C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 1C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 00 pc: 0250 sp: FD x: 1C y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 70 p: 00 pc: 0257 sp: FD x: 1C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 70 p: 00 pc: 0259 sp: FD x: 1C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6D p: 00 pc: 025B sp: FD x: 1C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6D p: 81 pc: 025D sp: FD x: 1C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 6D p: 81 pc: 026C sp: FD x: 1C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 6D p: 00 pc: 026E sp: FD x: 1C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 6D p: 00 pc: 0270 sp: FD x: 1C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 6D p: 00 pc: 0259 sp: FD x: 1C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6D p: 00 pc: 025B sp: FD x: 1C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6D p: 00 pc: 025D sp: FD x: 1C y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 6D p: 00 pc: 025F sp: FD x: 1C y: 03 
---
[1]    55 0261: 	sec
[2] a: 6D p: 00 pc: 0261 sp: FD x: 1C y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 6D p: 01 pc: 0262 sp: FD x: 1C y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 35 p: 00 pc: 0264 sp: FD x: 1C y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 35 p: 00 pc: 0266 sp: FD x: 1C y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1C y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 1C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 1C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 1C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 1C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 1C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 1C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 00 pc: 025D sp: FD x: 1C y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 35 p: 00 pc: 025F sp: FD x: 1C y: 03 
---
[1]    55 0261: 	sec
[2] a: 35 p: 00 pc: 0261 sp: FD x: 1C y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 35 p: 01 pc: 0262 sp: FD x: 1C y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 1C y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 1C y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 1C y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 1C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 1C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 1C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 1C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 1C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 1C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 1C y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 1C y: 03 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 1C y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 1C y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 1C y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 1C y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 1C y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 1C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 1C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 1C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 1C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 1C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 1C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 1C y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 1C y: 03 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 1C y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 1C y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 1C y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 1C y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0E p: 00 pc: 0268 sp: FD x: 1C y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0F p: 00 pc: 026A sp: FD x: 1C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 00 pc: 026C sp: FD x: 1C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 01 pc: 026E sp: FD x: 1C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 03 pc: 0270 sp: FD x: 1C y: 03 
---
[1]    64 0272: 	rts
[2] a: 0F p: 03 pc: 0272 sp: FD x: 1C y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0F p: 03 pc: 0220 sp: FF x: 1C y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 1C y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 1C y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 1C y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 1C y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 1C y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 1C y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 1C y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 6D p: 01 pc: 0216 sp: FF x: 1C y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 6D p: 01 pc: 0218 sp: FF x: 1C y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 1C y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 1C y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 1C y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1C y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1C y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1C y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1C y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 1C y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 1C y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 1C y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 1C y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 1C y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 1C y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 1C y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 1C y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 1C y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 1C y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 1C y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 1C y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 1C y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 1C y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 1C y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 1C y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 1C y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 1C y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 1C y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 1C y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 1C y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 1C y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6D p: 00 pc: 025B sp: FD x: 1C y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6D p: 81 pc: 025D sp: FD x: 1C y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 6D p: 81 pc: 026C sp: FD x: 1C y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 6D p: 00 pc: 026E sp: FD x: 1C y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 6D p: 00 pc: 0270 sp: FD x: 1C y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 6D p: 00 pc: 0259 sp: FD x: 1C y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6D p: 00 pc: 025B sp: FD x: 1C y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6D p: 00 pc: 025D sp: FD x: 1C y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 6D p: 00 pc: 025F sp: FD x: 1C y: 04 
---
[1]    55 0261: 	sec
[2] a: 6D p: 00 pc: 0261 sp: FD x: 1C y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 6D p: 01 pc: 0262 sp: FD x: 1C y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 1C y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 1C y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1C y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 1C y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 1C y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 1C y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 1C y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 1C y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 1C y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 1C y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 1C y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 1C y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 1C y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 1C y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 1C y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 1C y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 1C y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 1C y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 1C y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 1C y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 1C y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 1C y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 1C y: 04 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 1C y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 1C y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0A p: 00 pc: 0264 sp: FD x: 1C y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0A p: 00 pc: 0266 sp: FD x: 1C y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 1C y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 09 p: 00 pc: 026A sp: FD x: 1C y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 00 pc: 026C sp: FD x: 1C y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 1C y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 1C y: 04 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 1C y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 1C y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0A p: 01 pc: 0222 sp: FF x: 1C y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0A p: 01 pc: 0224 sp: FF x: 1C y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 1C y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 1C y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 1C y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 6D p: 00 pc: 0231 sp: FF x: 1C y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 6D p: 00 pc: 0232 sp: FF x: 1D y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 6D p: 00 pc: 0235 sp: FF x: 1D y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 6D p: 00 pc: 0238 sp: FF x: 1D y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 6D p: 00 pc: 023B sp: FF x: 1D y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 6F p: 00 pc: 023E sp: FF x: 1D y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 6F p: 81 pc: 0240 sp: FF x: 1D y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 6F p: 81 pc: 0211 sp: FF x: 1D y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 6F p: 01 pc: 0213 sp: FF x: 1D y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 6F p: 01 pc: 0216 sp: FF x: 1D y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 6F p: 01 pc: 0218 sp: FF x: 1D y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1D y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1D y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1D y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1D y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1D y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1D y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1D y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6F p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6F p: 81 pc: 025D sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 6F p: 81 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 6F p: 00 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 6F p: 00 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 6F p: 00 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6F p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6F p: 00 pc: 025D sp: FD x: 1D y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 6F p: 00 pc: 025F sp: FD x: 1D y: 01 
---
[1]    55 0261: 	sec
[2] a: 6F p: 00 pc: 0261 sp: FD x: 1D y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 6F p: 01 pc: 0262 sp: FD x: 1D y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 1D y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 1D y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1D y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 1D y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 1D y: 01 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 1D y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 1D y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 1D y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 1D y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1D y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 1D y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 1D y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 1D y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 1D y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 1D y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 1D y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 24 p: 00 pc: 0268 sp: FD x: 1D y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 25 p: 00 pc: 026A sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 00 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 01 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 03 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    64 0272: 	rts
[2] a: 25 p: 03 pc: 0272 sp: FD x: 1D y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 25 p: 03 pc: 0220 sp: FF x: 1D y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 1D y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 1D y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 1D y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 1D y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 71 p: 01 pc: 023E sp: FF x: 1D y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 71 p: 81 pc: 0240 sp: FF x: 1D y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 71 p: 81 pc: 0211 sp: FF x: 1D y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 71 p: 01 pc: 0213 sp: FF x: 1D y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 71 p: 01 pc: 0216 sp: FF x: 1D y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 71 p: 01 pc: 0218 sp: FF x: 1D y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1D y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1D y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1D y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1D y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1D y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1D y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1D y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 71 p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 71 p: 81 pc: 025D sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 71 p: 81 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 71 p: 00 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 71 p: 00 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 71 p: 00 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 71 p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 71 p: 00 pc: 025D sp: FD x: 1D y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 71 p: 00 pc: 025F sp: FD x: 1D y: 01 
---
[1]    55 0261: 	sec
[2] a: 71 p: 00 pc: 0261 sp: FD x: 1D y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 71 p: 01 pc: 0262 sp: FD x: 1D y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 1D y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 1D y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1D y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 1D y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 1D y: 01 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 1D y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 1D y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 1D y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 1D y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1D y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 1D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 1D y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 1D y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 1D y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 1D y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 1D y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 1D y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 24 p: 00 pc: 0268 sp: FD x: 1D y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 25 p: 00 pc: 026A sp: FD x: 1D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 00 pc: 026C sp: FD x: 1D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 01 pc: 026E sp: FD x: 1D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 03 pc: 0270 sp: FD x: 1D y: 01 
---
[1]    64 0272: 	rts
[2] a: 25 p: 03 pc: 0272 sp: FD x: 1D y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 25 p: 03 pc: 0220 sp: FF x: 1D y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 1D y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 1D y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 1D y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 1D y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 1D y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 1D y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 1D y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 71 p: 01 pc: 0216 sp: FF x: 1D y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 71 p: 01 pc: 0218 sp: FF x: 1D y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 1D y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 1D y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 1D y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1D y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1D y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1D y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 1D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 1D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 1D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 1D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 1D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 1D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 1D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 1D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 1D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 1D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 1D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 1D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 1D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 1D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 1D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 1D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 1D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 1D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 1D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 1D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 1D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 1D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 1D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 1D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 1D y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 1D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 1D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 71 p: 00 pc: 025B sp: FD x: 1D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 71 p: 81 pc: 025D sp: FD x: 1D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 71 p: 81 pc: 026C sp: FD x: 1D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 71 p: 00 pc: 026E sp: FD x: 1D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 71 p: 00 pc: 0270 sp: FD x: 1D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 71 p: 00 pc: 0259 sp: FD x: 1D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 71 p: 00 pc: 025B sp: FD x: 1D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 71 p: 00 pc: 025D sp: FD x: 1D y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 71 p: 00 pc: 025F sp: FD x: 1D y: 02 
---
[1]    55 0261: 	sec
[2] a: 71 p: 00 pc: 0261 sp: FD x: 1D y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 71 p: 01 pc: 0262 sp: FD x: 1D y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 1D y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 1D y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1D y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 1D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 1D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 1D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 1D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 1D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 1D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 1D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 1D y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 1D y: 02 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 1D y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 1D y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 1D y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 1D y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1D y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 1D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 1D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 1D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 1D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 1D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 1D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 1D y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 1D y: 02 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 1D y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 1D y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 1D y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 1D y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 1D y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 1D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 1D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 1D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 1D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 1D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 1D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 1D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 1D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 1D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 1D y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 1D y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 1D y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 1D y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 1D y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 1D y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 1D y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 1D y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 1D y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 1D y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 71 p: 01 pc: 0216 sp: FF x: 1D y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 71 p: 01 pc: 0218 sp: FF x: 1D y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 1D y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 1D y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 1D y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1D y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1D y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1D y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 1D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 1D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 1D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 1D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 1D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 1D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 1D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 1D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 1D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 1D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 1D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 1D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 1D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 1D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 1D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 1D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 1D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 1D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 1D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 1D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 1D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 1D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 1D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 1D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 1D y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 1D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 1D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 71 p: 00 pc: 025B sp: FD x: 1D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 71 p: 81 pc: 025D sp: FD x: 1D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 71 p: 81 pc: 026C sp: FD x: 1D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 71 p: 00 pc: 026E sp: FD x: 1D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 71 p: 00 pc: 0270 sp: FD x: 1D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 71 p: 00 pc: 0259 sp: FD x: 1D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 71 p: 00 pc: 025B sp: FD x: 1D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 71 p: 00 pc: 025D sp: FD x: 1D y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 71 p: 00 pc: 025F sp: FD x: 1D y: 03 
---
[1]    55 0261: 	sec
[2] a: 71 p: 00 pc: 0261 sp: FD x: 1D y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 71 p: 01 pc: 0262 sp: FD x: 1D y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 1D y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 1D y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1D y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 1D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 1D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 1D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 1D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 1D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 1D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 1D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 1D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 1D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 1D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 1D y: 03 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 1D y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 1D y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 1D y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 1D y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 1D y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 1D y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 1D y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 1D y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 1D y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 71 p: 01 pc: 0216 sp: FF x: 1D y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 71 p: 01 pc: 0218 sp: FF x: 1D y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 1D y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 1D y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 1D y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1D y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1D y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1D y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1D y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 1D y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 1D y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 1D y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 1D y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 1D y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 1D y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 1D y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 1D y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 1D y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 1D y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 1D y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 1D y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 1D y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 1D y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 1D y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 1D y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 1D y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 1D y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 1D y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 1D y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 1D y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 1D y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 71 p: 00 pc: 025B sp: FD x: 1D y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 71 p: 81 pc: 025D sp: FD x: 1D y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 71 p: 81 pc: 026C sp: FD x: 1D y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 71 p: 00 pc: 026E sp: FD x: 1D y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 71 p: 00 pc: 0270 sp: FD x: 1D y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 71 p: 00 pc: 0259 sp: FD x: 1D y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 71 p: 00 pc: 025B sp: FD x: 1D y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 71 p: 00 pc: 025D sp: FD x: 1D y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 71 p: 00 pc: 025F sp: FD x: 1D y: 04 
---
[1]    55 0261: 	sec
[2] a: 71 p: 00 pc: 0261 sp: FD x: 1D y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 71 p: 01 pc: 0262 sp: FD x: 1D y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 1D y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 1D y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1D y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 1D y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 1D y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 1D y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 1D y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 1D y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 1D y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 1D y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 1D y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 1D y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 1D y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 1D y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 1D y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 1D y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 1D y: 04 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 1D y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 1D y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 1D y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 1D y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 1D y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 1D y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 1D y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 1D y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 1D y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 1D y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 1D y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 1D y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 1D y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 1D y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 1D y: 04 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 1D y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 1D y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 1D y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 1D y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 1D y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 00 pc: 0229 sp: FF x: 1D y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 00 pc: 022E sp: FF x: 1D y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 71 p: 00 pc: 0231 sp: FF x: 1D y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 71 p: 00 pc: 0232 sp: FF x: 1E y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 71 p: 00 pc: 0235 sp: FF x: 1E y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 71 p: 00 pc: 0238 sp: FF x: 1E y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 71 p: 00 pc: 023B sp: FF x: 1E y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 73 p: 00 pc: 023E sp: FF x: 1E y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 73 p: 81 pc: 0240 sp: FF x: 1E y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 73 p: 81 pc: 0211 sp: FF x: 1E y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 73 p: 01 pc: 0213 sp: FF x: 1E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 73 p: 01 pc: 0216 sp: FF x: 1E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 73 p: 01 pc: 0218 sp: FF x: 1E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 73 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 73 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 73 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 73 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 73 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 73 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 73 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 73 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 73 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 73 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 73 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 24 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 26 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 26 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 26 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 26 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 26 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 1E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 1E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 1E y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 1E y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 1E y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 1E y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 1E y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 1E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 1E y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 73 p: 01 pc: 0216 sp: FF x: 1E y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 73 p: 01 pc: 0218 sp: FF x: 1E y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 1E y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 1E y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 1E y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 73 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 73 p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 73 p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 73 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 73 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 73 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 73 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 73 p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 73 p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 73 p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 73 p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 23 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 16 p: 00 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 17 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 01 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 03 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    64 0272: 	rts
[2] a: 17 p: 03 pc: 0272 sp: FD x: 1E y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 17 p: 03 pc: 0220 sp: FF x: 1E y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 1E y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 1E y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 1E y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 1E y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 75 p: 01 pc: 023E sp: FF x: 1E y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 75 p: 81 pc: 0240 sp: FF x: 1E y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 75 p: 81 pc: 0211 sp: FF x: 1E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 75 p: 01 pc: 0213 sp: FF x: 1E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 75 p: 01 pc: 0216 sp: FF x: 1E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 75 p: 01 pc: 0218 sp: FF x: 1E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 75 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 75 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 75 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 75 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 75 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 75 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 75 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 75 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 75 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 75 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 75 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 24 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 26 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 26 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 26 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 26 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 26 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 26 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 27 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 01 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 03 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    64 0272: 	rts
[2] a: 27 p: 03 pc: 0272 sp: FD x: 1E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 27 p: 03 pc: 0220 sp: FF x: 1E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 1E y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 1E y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 1E y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 1E y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 77 p: 01 pc: 023E sp: FF x: 1E y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 77 p: 81 pc: 0240 sp: FF x: 1E y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 77 p: 81 pc: 0211 sp: FF x: 1E y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 77 p: 01 pc: 0213 sp: FF x: 1E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 77 p: 01 pc: 0216 sp: FF x: 1E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 77 p: 01 pc: 0218 sp: FF x: 1E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 77 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 77 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 77 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 77 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 77 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 77 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 77 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 77 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 77 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 77 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 77 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 24 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 26 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 26 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 26 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 26 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 26 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 26 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 27 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 01 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 03 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    64 0272: 	rts
[2] a: 27 p: 03 pc: 0272 sp: FD x: 1E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 27 p: 03 pc: 0220 sp: FF x: 1E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 1E y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 1E y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 1E y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 1E y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 1E y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 1E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 1E y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 77 p: 01 pc: 0216 sp: FF x: 1E y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 77 p: 01 pc: 0218 sp: FF x: 1E y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 1E y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 1E y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 1E y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 77 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 77 p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 77 p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 77 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 77 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 77 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 77 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 77 p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 77 p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 77 p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 77 p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 27 p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 27 p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 27 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 16 p: 00 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 17 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 01 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 03 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    64 0272: 	rts
[2] a: 17 p: 03 pc: 0272 sp: FD x: 1E y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 17 p: 03 pc: 0220 sp: FF x: 1E y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 1E y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 1E y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 1E y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 1E y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 1E y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 1E y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 1E y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 77 p: 01 pc: 0216 sp: FF x: 1E y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 77 p: 01 pc: 0218 sp: FF x: 1E y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 1E y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 1E y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 1E y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 77 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 77 p: 81 pc: 025D sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 77 p: 81 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 77 p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 77 p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 77 p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 77 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 77 p: 00 pc: 025D sp: FD x: 1E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 77 p: 00 pc: 025F sp: FD x: 1E y: 03 
---
[1]    55 0261: 	sec
[2] a: 77 p: 00 pc: 0261 sp: FD x: 1E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 77 p: 01 pc: 0262 sp: FD x: 1E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 1E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 1E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 02 pc: 025D sp: FD x: 1E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 02 pc: 025F sp: FD x: 1E y: 03 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 1E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 1E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 1E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 1E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 1E y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 1E y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 1E y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 1E y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 1E y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 1E y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 79 p: 01 pc: 023E sp: FF x: 1E y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: 79 p: 81 pc: 0240 sp: FF x: 1E y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 79 p: 81 pc: 0211 sp: FF x: 1E y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 79 p: 01 pc: 0213 sp: FF x: 1E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 79 p: 01 pc: 0216 sp: FF x: 1E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 79 p: 01 pc: 0218 sp: FF x: 1E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 79 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 79 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 79 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 79 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 79 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 79 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 79 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 79 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 79 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 79 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 79 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 1E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 1E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 1E y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 1E y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 1E y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 1E y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 1E y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 1E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 1E y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 79 p: 01 pc: 0216 sp: FF x: 1E y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 79 p: 01 pc: 0218 sp: FF x: 1E y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 1E y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 1E y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 1E y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 79 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 79 p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 79 p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 79 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 79 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 79 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 79 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 79 p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 79 p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 79 p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 79 p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 29 p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 29 p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 29 p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 29 p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 29 p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 1E y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 1E y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 1E y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 1E y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 1E y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 1E y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 1E y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 1E y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 1E y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 79 p: 01 pc: 0216 sp: FF x: 1E y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 79 p: 01 pc: 0218 sp: FF x: 1E y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 1E y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 1E y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 1E y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 79 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 79 p: 81 pc: 025D sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 79 p: 81 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 79 p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 79 p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 79 p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 79 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 79 p: 00 pc: 025D sp: FD x: 1E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 79 p: 00 pc: 025F sp: FD x: 1E y: 03 
---
[1]    55 0261: 	sec
[2] a: 79 p: 00 pc: 0261 sp: FD x: 1E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 79 p: 01 pc: 0262 sp: FD x: 1E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 1E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 1E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 1E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 1E y: 03 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 1E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 1E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 1E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 1E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 1E y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 1E y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 1E y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 1E y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 1E y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 1E y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 1E y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 1E y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 1E y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 79 p: 01 pc: 0216 sp: FF x: 1E y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 79 p: 01 pc: 0218 sp: FF x: 1E y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 1E y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 1E y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 1E y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 1E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 1E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 1E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 1E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 1E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 1E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 1E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 1E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 1E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 1E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 1E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 1E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 1E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 1E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 1E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 1E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 1E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 1E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 1E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 1E y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 1E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 1E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 79 p: 00 pc: 025B sp: FD x: 1E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 79 p: 81 pc: 025D sp: FD x: 1E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 79 p: 81 pc: 026C sp: FD x: 1E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 79 p: 00 pc: 026E sp: FD x: 1E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 79 p: 00 pc: 0270 sp: FD x: 1E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 79 p: 00 pc: 0259 sp: FD x: 1E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 79 p: 00 pc: 025B sp: FD x: 1E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 79 p: 00 pc: 025D sp: FD x: 1E y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 79 p: 00 pc: 025F sp: FD x: 1E y: 04 
---
[1]    55 0261: 	sec
[2] a: 79 p: 00 pc: 0261 sp: FD x: 1E y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 79 p: 01 pc: 0262 sp: FD x: 1E y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 1E y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 1E y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 1E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 1E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 1E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 1E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 1E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 1E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 1E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 1E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 1E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 1E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 1E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 1E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 1E y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 1E y: 04 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 1E y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 1E y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 1E y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 1E y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 1E y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 1E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 1E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 1E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 1E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 1E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 1E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 02 pc: 025D sp: FD x: 1E y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 02 pc: 025F sp: FD x: 1E y: 04 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 1E y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 1E y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 1E y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 1E y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 1E y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 1E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 1E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 1E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 1E y: 04 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 1E y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 1E y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 1E y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 1E y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 1E y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 1E y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 7B p: 01 pc: 023E sp: FF x: 1E y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 7B p: 81 pc: 0240 sp: FF x: 1E y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 7B p: 81 pc: 0211 sp: FF x: 1E y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 7B p: 01 pc: 0213 sp: FF x: 1E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 7B p: 01 pc: 0216 sp: FF x: 1E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 7B p: 01 pc: 0218 sp: FF x: 1E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7B p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7B p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 7B p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 7B p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 7B p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 7B p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7B p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7B p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 7B p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 7B p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 7B p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 29 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 29 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 29 p: 01 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 29 p: 03 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    64 0272: 	rts
[2] a: 29 p: 03 pc: 0272 sp: FD x: 1E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 29 p: 03 pc: 0220 sp: FF x: 1E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 1E y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 1E y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 1E y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 1E y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 7D p: 01 pc: 023E sp: FF x: 1E y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 7D p: 81 pc: 0240 sp: FF x: 1E y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 7D p: 81 pc: 0211 sp: FF x: 1E y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 7D p: 01 pc: 0213 sp: FF x: 1E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 7D p: 01 pc: 0216 sp: FF x: 1E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 7D p: 01 pc: 0218 sp: FF x: 1E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7D p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7D p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 7D p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 7D p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 7D p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 7D p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7D p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7D p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 7D p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 7D p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 7D p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 1D p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 1D p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1D p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 29 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 29 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 29 p: 01 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 29 p: 03 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    64 0272: 	rts
[2] a: 29 p: 03 pc: 0272 sp: FD x: 1E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 29 p: 03 pc: 0220 sp: FF x: 1E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 1E y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 1E y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 1E y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 1E y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 1E y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 1E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 1E y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 7D p: 01 pc: 0216 sp: FF x: 1E y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 7D p: 01 pc: 0218 sp: FF x: 1E y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 1E y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 1E y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 1E y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7D p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7D p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 7D p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 7D p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 7D p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 7D p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7D p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7D p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 7D p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 7D p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 7D p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 2D p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 2D p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 2D p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 2D p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2D p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 19 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 01 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 03 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    64 0272: 	rts
[2] a: 19 p: 03 pc: 0272 sp: FD x: 1E y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 19 p: 03 pc: 0220 sp: FF x: 1E y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 1E y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 1E y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 01 pc: 0238 sp: FF x: 1E y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 01 pc: 023B sp: FF x: 1E y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 7F p: 01 pc: 023E sp: FF x: 1E y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 7F p: 81 pc: 0240 sp: FF x: 1E y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 7F p: 81 pc: 0211 sp: FF x: 1E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 7F p: 01 pc: 0213 sp: FF x: 1E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 7F p: 01 pc: 0216 sp: FF x: 1E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 7F p: 01 pc: 0218 sp: FF x: 1E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7F p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7F p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 7F p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 7F p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 7F p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 7F p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7F p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7F p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 7F p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 7F p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 7F p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 1F p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 1F p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1F p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 1E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 1E y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 1E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 1E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 1E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 1E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 1E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2A p: 00 pc: 026A sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2A p: 00 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2A p: 00 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2A p: 00 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2A p: 00 pc: 0259 sp: FD x: 1E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 1E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 1E y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 1E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 1E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 1E y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 1E y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 1E y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 1E y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 1E y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 1E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 1E y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 7F p: 01 pc: 0216 sp: FF x: 1E y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 7F p: 01 pc: 0218 sp: FF x: 1E y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 1E y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 1E y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 1E y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 1E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 1E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 1E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 1E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 1E y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7F p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7F p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 7F p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 7F p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 7F p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 7F p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7F p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7F p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 7F p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 7F p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 7F p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 2F p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 2F p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 2F p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 2F p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2F p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 1E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 1E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 1E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 1E y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 1E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 1E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 1E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 1E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 1E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 19 p: 00 pc: 026A sp: FD x: 1E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 00 pc: 026C sp: FD x: 1E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 01 pc: 026E sp: FD x: 1E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 03 pc: 0270 sp: FD x: 1E y: 02 
---
[1]    64 0272: 	rts
[2] a: 19 p: 03 pc: 0272 sp: FD x: 1E y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 19 p: 03 pc: 0220 sp: FF x: 1E y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 1E y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 1E y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 1E y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 1E y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 1E y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 1E y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 1E y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 7F p: 01 pc: 0216 sp: FF x: 1E y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 7F p: 01 pc: 0218 sp: FF x: 1E y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 1E y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 1E y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 1E y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 1E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 1E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 1E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 1E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 1E y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7F p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7F p: 81 pc: 025D sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 7F p: 81 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 7F p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 7F p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 7F p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7F p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7F p: 00 pc: 025D sp: FD x: 1E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 7F p: 00 pc: 025F sp: FD x: 1E y: 03 
---
[1]    55 0261: 	sec
[2] a: 7F p: 00 pc: 0261 sp: FD x: 1E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 7F p: 01 pc: 0262 sp: FD x: 1E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 1E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 1E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 1E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 1E y: 03 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 1E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 1E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 1E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 1E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 1E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 1E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 1E y: 03 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 1E y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 1E y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 1E y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 1E y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 1E y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 1E y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 1E y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 1E y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 1E y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 7F p: 01 pc: 0216 sp: FF x: 1E y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 7F p: 01 pc: 0218 sp: FF x: 1E y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 1E y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 1E y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 1E y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1E y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1E y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1E y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 1E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 1E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 1E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 1E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 1E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 1E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 1E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 1E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 1E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 1E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 1E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 1E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 1E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 1E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 1E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 1E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 1E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 1E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 1E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 1E y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 1E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 1E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7F p: 00 pc: 025B sp: FD x: 1E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7F p: 81 pc: 025D sp: FD x: 1E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 7F p: 81 pc: 026C sp: FD x: 1E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 7F p: 00 pc: 026E sp: FD x: 1E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 7F p: 00 pc: 0270 sp: FD x: 1E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 7F p: 00 pc: 0259 sp: FD x: 1E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 7F p: 00 pc: 025B sp: FD x: 1E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 7F p: 00 pc: 025D sp: FD x: 1E y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 7F p: 00 pc: 025F sp: FD x: 1E y: 04 
---
[1]    55 0261: 	sec
[2] a: 7F p: 00 pc: 0261 sp: FD x: 1E y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 7F p: 01 pc: 0262 sp: FD x: 1E y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 27 p: 00 pc: 0264 sp: FD x: 1E y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 27 p: 00 pc: 0266 sp: FD x: 1E y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1E y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 1E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 1E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 1E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 1E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 1E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 1E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 81 pc: 025D sp: FD x: 1E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 81 pc: 026C sp: FD x: 1E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 00 pc: 026E sp: FD x: 1E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 00 pc: 0270 sp: FD x: 1E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 27 p: 00 pc: 0259 sp: FD x: 1E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 1E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 1E y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 1E y: 04 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 1E y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 1E y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 1E y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 1E y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 1E y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 1E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 1E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 1E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 1E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 1E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 1E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 1E y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 1E y: 04 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 1E y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 1E y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 1E y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 1E y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 1E y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 1E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 1E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 1E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 1E y: 04 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 1E y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 1E y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 1E y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 1E y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 1E y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 02 pc: 0229 sp: FF x: 1E y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 02 pc: 022E sp: FF x: 1E y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 7F p: 00 pc: 0231 sp: FF x: 1E y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 7F p: 00 pc: 0232 sp: FF x: 1F y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 7F p: 00 pc: 0235 sp: FF x: 1F y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 7F p: 80 pc: 0238 sp: FF x: 1F y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 7F p: 80 pc: 023B sp: FF x: 1F y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 81 p: 80 pc: 023E sp: FF x: 1F y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 81 p: 81 pc: 0240 sp: FF x: 1F y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 81 p: 81 pc: 0211 sp: FF x: 1F y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 81 p: 01 pc: 0213 sp: FF x: 1F y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 81 p: 81 pc: 0216 sp: FF x: 1F y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 81 p: 81 pc: 0218 sp: FF x: 1F y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1F y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1F y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1F y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1F y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1F y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1F y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1F y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 81 p: 80 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 81 p: 81 pc: 025D sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 81 p: 81 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 81 p: 00 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 81 p: 00 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 81 p: 00 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 81 p: 80 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 81 p: 00 pc: 025D sp: FD x: 1F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 81 p: 00 pc: 025F sp: FD x: 1F y: 01 
---
[1]    55 0261: 	sec
[2] a: 81 p: 80 pc: 0261 sp: FD x: 1F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 81 p: 81 pc: 0262 sp: FD x: 1F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 1F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 1F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 1F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 1F y: 01 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 1F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 1F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 1F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 1F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 1F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 1F y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 1F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 1F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 1F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 1F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 1F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2A p: 00 pc: 026A sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2A p: 00 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2A p: 00 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2A p: 00 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2A p: 00 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 1F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 1F y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 1F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 1F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 1F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 1F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2A p: 00 pc: 0268 sp: FD x: 1F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2B p: 00 pc: 026A sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 00 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 01 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 03 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    64 0272: 	rts
[2] a: 2B p: 03 pc: 0272 sp: FD x: 1F y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 2B p: 03 pc: 0220 sp: FF x: 1F y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 1F y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 1F y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 1F y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 1F y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 83 p: 81 pc: 023E sp: FF x: 1F y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 83 p: 81 pc: 0240 sp: FF x: 1F y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 83 p: 81 pc: 0211 sp: FF x: 1F y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 83 p: 01 pc: 0213 sp: FF x: 1F y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 83 p: 81 pc: 0216 sp: FF x: 1F y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 83 p: 81 pc: 0218 sp: FF x: 1F y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 1F y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 1F y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 1F y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1F y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1F y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1F y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 1F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 1F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 1F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 1F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 1F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 1F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 1F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 1F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 1F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 1F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 1F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 1F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 1F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 1F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 1F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 1F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 1F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 1F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 1F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 1F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 1F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 1F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 1F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 1F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 1F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 1F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 1F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 1F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 1F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 1F y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 83 p: 80 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 83 p: 81 pc: 025D sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 83 p: 81 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 83 p: 00 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 83 p: 00 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 83 p: 00 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 83 p: 80 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 83 p: 00 pc: 025D sp: FD x: 1F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 83 p: 00 pc: 025F sp: FD x: 1F y: 01 
---
[1]    55 0261: 	sec
[2] a: 83 p: 80 pc: 0261 sp: FD x: 1F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 83 p: 81 pc: 0262 sp: FD x: 1F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 1F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 1F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 81 pc: 025D sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 81 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 00 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 00 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 23 p: 00 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 1F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 1F y: 01 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 1F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 1F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 1F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 1F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 1F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 1F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 1F y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 1F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 1F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 1F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 1F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 1F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2A p: 00 pc: 026A sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2A p: 00 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2A p: 00 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2A p: 00 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2A p: 00 pc: 0259 sp: FD x: 1F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 1F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 1F y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 1F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 1F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 1F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 1F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2A p: 00 pc: 0268 sp: FD x: 1F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2B p: 00 pc: 026A sp: FD x: 1F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 00 pc: 026C sp: FD x: 1F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 01 pc: 026E sp: FD x: 1F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 03 pc: 0270 sp: FD x: 1F y: 01 
---
[1]    64 0272: 	rts
[2] a: 2B p: 03 pc: 0272 sp: FD x: 1F y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 2B p: 03 pc: 0220 sp: FF x: 1F y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 1F y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 1F y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 1F y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 1F y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 1F y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 1F y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 1F y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 83 p: 81 pc: 0216 sp: FF x: 1F y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 83 p: 81 pc: 0218 sp: FF x: 1F y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 1F y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 1F y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 1F y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1F y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1F y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1F y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 1F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 1F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 1F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 1F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 1F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 1F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 1F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 1F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 1F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 1F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 1F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 1F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 1F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 1F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 1F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 1F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 1F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 1F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 1F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 1F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 1F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 1F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 1F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 1F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 1F y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 1F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 1F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 83 p: 80 pc: 025B sp: FD x: 1F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 83 p: 81 pc: 025D sp: FD x: 1F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 83 p: 81 pc: 026C sp: FD x: 1F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 83 p: 00 pc: 026E sp: FD x: 1F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 83 p: 00 pc: 0270 sp: FD x: 1F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 83 p: 00 pc: 0259 sp: FD x: 1F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 83 p: 80 pc: 025B sp: FD x: 1F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 83 p: 00 pc: 025D sp: FD x: 1F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 83 p: 00 pc: 025F sp: FD x: 1F y: 02 
---
[1]    55 0261: 	sec
[2] a: 83 p: 80 pc: 0261 sp: FD x: 1F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 83 p: 81 pc: 0262 sp: FD x: 1F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 33 p: 00 pc: 0264 sp: FD x: 1F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 33 p: 00 pc: 0266 sp: FD x: 1F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 1F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 00 pc: 025D sp: FD x: 1F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 33 p: 00 pc: 025F sp: FD x: 1F y: 02 
---
[1]    55 0261: 	sec
[2] a: 33 p: 00 pc: 0261 sp: FD x: 1F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 33 p: 01 pc: 0262 sp: FD x: 1F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 1F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 1F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 1F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 1F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 1F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 1F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 1F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 1F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 1F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 1F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 1F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 1F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 1F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 1F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 1F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 1F y: 02 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 1F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 1F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 1F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 1F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 1F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1A p: 00 pc: 026A sp: FD x: 1F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1A p: 00 pc: 026C sp: FD x: 1F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1A p: 00 pc: 026E sp: FD x: 1F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1A p: 00 pc: 0270 sp: FD x: 1F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1A p: 00 pc: 0259 sp: FD x: 1F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 1F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 1F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 1F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 1F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 1F y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 1F y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 1F y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 1F y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 1F y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 1F y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 1F y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 1F y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 1F y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 1F y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 83 p: 81 pc: 0216 sp: FF x: 1F y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 83 p: 81 pc: 0218 sp: FF x: 1F y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 1F y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 1F y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 1F y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1F y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1F y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1F y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 1F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 1F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 1F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 1F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 1F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 1F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 1F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 1F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 1F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 1F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 1F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 1F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 1F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 1F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 1F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 1F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 1F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 1F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 1F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 1F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 1F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 1F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 1F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 1F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 1F y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 1F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 1F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 83 p: 80 pc: 025B sp: FD x: 1F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 83 p: 81 pc: 025D sp: FD x: 1F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 83 p: 81 pc: 026C sp: FD x: 1F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 83 p: 00 pc: 026E sp: FD x: 1F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 83 p: 00 pc: 0270 sp: FD x: 1F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 83 p: 00 pc: 0259 sp: FD x: 1F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 83 p: 80 pc: 025B sp: FD x: 1F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 83 p: 00 pc: 025D sp: FD x: 1F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 83 p: 00 pc: 025F sp: FD x: 1F y: 03 
---
[1]    55 0261: 	sec
[2] a: 83 p: 80 pc: 0261 sp: FD x: 1F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 83 p: 81 pc: 0262 sp: FD x: 1F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 1F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 1F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 1F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 1F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 1F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 1F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 1F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 1F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 1F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 1F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 1F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 1F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 1F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 1F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 1F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 1F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 1F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 1F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 1F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 1F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 1F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 1F y: 03 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 1F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 1F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 1F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 1F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 1F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 1F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 1F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 1F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 1F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 1F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 1F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 1F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 1F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 1F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 1F y: 03 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 1F y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 1F y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 1F y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 1F y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 1F y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 1F y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 1F y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 1F y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 1F y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 83 p: 81 pc: 0216 sp: FF x: 1F y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 83 p: 81 pc: 0218 sp: FF x: 1F y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 1F y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 1F y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 1F y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 1F y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 1F y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 1F y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 1F y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 1F y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 1F y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 1F y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 1F y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 1F y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 1F y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 1F y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 1F y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 1F y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 1F y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 1F y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 1F y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 1F y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 1F y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 1F y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 1F y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 1F y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 1F y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 1F y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 1F y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 1F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 1F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 83 p: 80 pc: 025B sp: FD x: 1F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 83 p: 81 pc: 025D sp: FD x: 1F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 83 p: 81 pc: 026C sp: FD x: 1F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 83 p: 00 pc: 026E sp: FD x: 1F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 83 p: 00 pc: 0270 sp: FD x: 1F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 83 p: 00 pc: 0259 sp: FD x: 1F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 83 p: 80 pc: 025B sp: FD x: 1F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 83 p: 00 pc: 025D sp: FD x: 1F y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 83 p: 00 pc: 025F sp: FD x: 1F y: 04 
---
[1]    55 0261: 	sec
[2] a: 83 p: 80 pc: 0261 sp: FD x: 1F y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 83 p: 81 pc: 0262 sp: FD x: 1F y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 2B p: 00 pc: 0264 sp: FD x: 1F y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 2B p: 00 pc: 0266 sp: FD x: 1F y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 1F y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 1F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 1F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 1F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 1F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 1F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 1F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 81 pc: 025D sp: FD x: 1F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 81 pc: 026C sp: FD x: 1F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 00 pc: 026E sp: FD x: 1F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 00 pc: 0270 sp: FD x: 1F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2B p: 00 pc: 0259 sp: FD x: 1F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 1F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 00 pc: 025D sp: FD x: 1F y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 2B p: 00 pc: 025F sp: FD x: 1F y: 04 
---
[1]    55 0261: 	sec
[2] a: 2B p: 00 pc: 0261 sp: FD x: 1F y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2B p: 01 pc: 0262 sp: FD x: 1F y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 1F y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 1F y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 1F y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 1F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 1F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 1F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 1F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 1F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 1F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 1F y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 1F y: 04 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 1F y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 1F y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0A p: 00 pc: 0264 sp: FD x: 1F y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0A p: 00 pc: 0266 sp: FD x: 1F y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 1F y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 1F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 1F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 1F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 1F y: 04 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 1F y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 1F y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0A p: 01 pc: 0222 sp: FF x: 1F y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0A p: 01 pc: 0224 sp: FF x: 1F y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 1F y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 02 pc: 0229 sp: FF x: 1F y: 04 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0B p: 02 pc: 022E sp: FF x: 1F y: 04 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 83 p: 80 pc: 0231 sp: FF x: 1F y: 04 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 83 p: 00 pc: 0232 sp: FF x: 20 y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 83 p: 00 pc: 0235 sp: FF x: 20 y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 83 p: 80 pc: 0238 sp: FF x: 20 y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 83 p: 80 pc: 023B sp: FF x: 20 y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 85 p: 80 pc: 023E sp: FF x: 20 y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 85 p: 81 pc: 0240 sp: FF x: 20 y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 85 p: 81 pc: 0211 sp: FF x: 20 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 85 p: 01 pc: 0213 sp: FF x: 20 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 85 p: 81 pc: 0216 sp: FF x: 20 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 85 p: 81 pc: 0218 sp: FF x: 20 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 20 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 20 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 20 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 20 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 20 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 20 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 85 p: 80 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 85 p: 81 pc: 025D sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 85 p: 81 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 85 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 85 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 85 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 85 p: 80 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 85 p: 00 pc: 025D sp: FD x: 20 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 85 p: 00 pc: 025F sp: FD x: 20 y: 01 
---
[1]    55 0261: 	sec
[2] a: 85 p: 80 pc: 0261 sp: FD x: 20 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 85 p: 81 pc: 0262 sp: FD x: 20 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 25 p: 00 pc: 0264 sp: FD x: 20 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 25 p: 00 pc: 0266 sp: FD x: 20 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 20 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 81 pc: 025D sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 81 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 25 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 20 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 20 y: 01 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 20 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 20 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 20 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 20 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 20 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 20 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 20 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 20 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 20 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 20 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 20 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 20 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 20 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 20 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 20 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 20 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 20 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 20 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 20 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 20 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 20 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 85 p: 81 pc: 0216 sp: FF x: 20 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 85 p: 81 pc: 0218 sp: FF x: 20 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 20 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 20 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 20 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 20 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 20 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 20 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 20 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 20 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 20 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 20 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 20 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 20 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 20 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 20 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 20 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 20 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 20 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 20 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 20 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 20 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 20 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 20 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 20 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 20 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 20 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 20 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 20 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 20 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 20 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 20 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 20 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 20 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 20 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 20 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 85 p: 80 pc: 025B sp: FD x: 20 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 85 p: 81 pc: 025D sp: FD x: 20 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 85 p: 81 pc: 026C sp: FD x: 20 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 85 p: 00 pc: 026E sp: FD x: 20 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 85 p: 00 pc: 0270 sp: FD x: 20 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 85 p: 00 pc: 0259 sp: FD x: 20 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 85 p: 80 pc: 025B sp: FD x: 20 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 85 p: 00 pc: 025D sp: FD x: 20 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 85 p: 00 pc: 025F sp: FD x: 20 y: 02 
---
[1]    55 0261: 	sec
[2] a: 85 p: 80 pc: 0261 sp: FD x: 20 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 85 p: 81 pc: 0262 sp: FD x: 20 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 35 p: 00 pc: 0264 sp: FD x: 20 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 35 p: 00 pc: 0266 sp: FD x: 20 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 20 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 20 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 20 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 20 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 20 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 20 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 20 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 00 pc: 025D sp: FD x: 20 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 35 p: 00 pc: 025F sp: FD x: 20 y: 02 
---
[1]    55 0261: 	sec
[2] a: 35 p: 00 pc: 0261 sp: FD x: 20 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 35 p: 01 pc: 0262 sp: FD x: 20 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 20 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 20 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 20 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 20 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 20 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 20 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 20 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 20 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 20 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 20 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 20 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 20 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 20 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 20 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 20 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 20 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 20 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 20 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 20 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 20 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 20 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 20 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1A p: 00 pc: 026A sp: FD x: 20 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1A p: 00 pc: 026C sp: FD x: 20 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1A p: 00 pc: 026E sp: FD x: 20 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1A p: 00 pc: 0270 sp: FD x: 20 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1A p: 00 pc: 0259 sp: FD x: 20 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 20 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 20 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 20 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 20 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 20 y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 20 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 20 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 20 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 20 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 20 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 20 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 20 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 20 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 20 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 85 p: 81 pc: 0216 sp: FF x: 20 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 85 p: 81 pc: 0218 sp: FF x: 20 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 20 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 20 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 20 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 20 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 20 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 20 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 20 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 20 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 20 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 20 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 20 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 20 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 20 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 20 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 20 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 20 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 20 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 20 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 20 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 20 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 20 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 20 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 20 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 20 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 20 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 20 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 20 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 20 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 20 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 20 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 20 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 20 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 20 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 20 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 85 p: 80 pc: 025B sp: FD x: 20 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 85 p: 81 pc: 025D sp: FD x: 20 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 85 p: 81 pc: 026C sp: FD x: 20 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 85 p: 00 pc: 026E sp: FD x: 20 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 85 p: 00 pc: 0270 sp: FD x: 20 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 85 p: 00 pc: 0259 sp: FD x: 20 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 85 p: 80 pc: 025B sp: FD x: 20 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 85 p: 00 pc: 025D sp: FD x: 20 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 85 p: 00 pc: 025F sp: FD x: 20 y: 03 
---
[1]    55 0261: 	sec
[2] a: 85 p: 80 pc: 0261 sp: FD x: 20 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 85 p: 81 pc: 0262 sp: FD x: 20 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 20 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 20 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 20 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 20 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 20 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 20 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 20 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 20 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 20 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 20 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 20 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 20 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 20 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 20 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 20 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 20 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 20 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 20 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 20 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 20 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 20 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 20 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 20 y: 03 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 20 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 20 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 20 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 20 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 20 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 20 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 20 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 20 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 20 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 20 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 20 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 02 pc: 025D sp: FD x: 20 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 02 pc: 025F sp: FD x: 20 y: 03 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 20 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 20 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 20 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 20 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 12 p: 00 pc: 0268 sp: FD x: 20 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 13 p: 00 pc: 026A sp: FD x: 20 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 00 pc: 026C sp: FD x: 20 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 01 pc: 026E sp: FD x: 20 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 03 pc: 0270 sp: FD x: 20 y: 03 
---
[1]    64 0272: 	rts
[2] a: 13 p: 03 pc: 0272 sp: FD x: 20 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 13 p: 03 pc: 0220 sp: FF x: 20 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 20 y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 20 y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 20 y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 20 y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 87 p: 81 pc: 023E sp: FF x: 20 y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: 87 p: 81 pc: 0240 sp: FF x: 20 y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 87 p: 81 pc: 0211 sp: FF x: 20 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 87 p: 01 pc: 0213 sp: FF x: 20 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 87 p: 81 pc: 0216 sp: FF x: 20 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 87 p: 81 pc: 0218 sp: FF x: 20 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 20 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 20 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 20 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 20 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 20 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 20 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 87 p: 80 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 87 p: 81 pc: 025D sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 87 p: 81 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 87 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 87 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 87 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 87 p: 80 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 87 p: 00 pc: 025D sp: FD x: 20 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 87 p: 00 pc: 025F sp: FD x: 20 y: 01 
---
[1]    55 0261: 	sec
[2] a: 87 p: 80 pc: 0261 sp: FD x: 20 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 87 p: 81 pc: 0262 sp: FD x: 20 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 27 p: 00 pc: 0264 sp: FD x: 20 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 27 p: 00 pc: 0266 sp: FD x: 20 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 20 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 81 pc: 025D sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 81 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 27 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 20 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 20 y: 01 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 20 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 20 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 20 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 20 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 20 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 20 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 20 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 20 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 20 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 20 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 20 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 20 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 20 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 20 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 20 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 20 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 20 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 20 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2C p: 00 pc: 0268 sp: FD x: 20 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2D p: 00 pc: 026A sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2D p: 00 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2D p: 01 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2D p: 03 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    64 0272: 	rts
[2] a: 2D p: 03 pc: 0272 sp: FD x: 20 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 2D p: 03 pc: 0220 sp: FF x: 20 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 20 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 20 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 20 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 20 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 89 p: 81 pc: 023E sp: FF x: 20 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 89 p: 81 pc: 0240 sp: FF x: 20 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 89 p: 81 pc: 0211 sp: FF x: 20 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 89 p: 01 pc: 0213 sp: FF x: 20 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 89 p: 81 pc: 0216 sp: FF x: 20 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 89 p: 81 pc: 0218 sp: FF x: 20 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 20 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 20 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 20 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 20 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 20 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 20 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 20 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 20 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 20 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 20 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 20 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 89 p: 80 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 89 p: 81 pc: 025D sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 89 p: 81 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 89 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 89 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 89 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 89 p: 80 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 89 p: 00 pc: 025D sp: FD x: 20 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 89 p: 00 pc: 025F sp: FD x: 20 y: 01 
---
[1]    55 0261: 	sec
[2] a: 89 p: 80 pc: 0261 sp: FD x: 20 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 89 p: 81 pc: 0262 sp: FD x: 20 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 29 p: 00 pc: 0264 sp: FD x: 20 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 29 p: 00 pc: 0266 sp: FD x: 20 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 20 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 81 pc: 025D sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 29 p: 81 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 29 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 29 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 29 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 00 pc: 025D sp: FD x: 20 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 29 p: 00 pc: 025F sp: FD x: 20 y: 01 
---
[1]    55 0261: 	sec
[2] a: 29 p: 00 pc: 0261 sp: FD x: 20 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 29 p: 01 pc: 0262 sp: FD x: 20 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 20 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 20 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 20 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 20 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 20 y: 01 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 20 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 20 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 20 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 20 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 20 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 20 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 20 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 20 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 20 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 20 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 20 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 20 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 20 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2C p: 00 pc: 0268 sp: FD x: 20 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2D p: 00 pc: 026A sp: FD x: 20 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2D p: 00 pc: 026C sp: FD x: 20 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2D p: 01 pc: 026E sp: FD x: 20 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2D p: 03 pc: 0270 sp: FD x: 20 y: 01 
---
[1]    64 0272: 	rts
[2] a: 2D p: 03 pc: 0272 sp: FD x: 20 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 2D p: 03 pc: 0220 sp: FF x: 20 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 20 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 20 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 20 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 20 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 20 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 20 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 20 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 89 p: 81 pc: 0216 sp: FF x: 20 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 89 p: 81 pc: 0218 sp: FF x: 20 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 20 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 20 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 20 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 20 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 20 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 20 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 20 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 20 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 20 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 20 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 20 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 20 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 20 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 20 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 20 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 20 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 20 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 20 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 20 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 20 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 20 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 20 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 20 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 20 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 20 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 20 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 20 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 20 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 20 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 20 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 20 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 20 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 20 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 20 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 89 p: 80 pc: 025B sp: FD x: 20 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 89 p: 81 pc: 025D sp: FD x: 20 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 89 p: 81 pc: 026C sp: FD x: 20 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 89 p: 00 pc: 026E sp: FD x: 20 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 89 p: 00 pc: 0270 sp: FD x: 20 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 89 p: 00 pc: 0259 sp: FD x: 20 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 89 p: 80 pc: 025B sp: FD x: 20 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 89 p: 00 pc: 025D sp: FD x: 20 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 89 p: 00 pc: 025F sp: FD x: 20 y: 02 
---
[1]    55 0261: 	sec
[2] a: 89 p: 80 pc: 0261 sp: FD x: 20 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 89 p: 81 pc: 0262 sp: FD x: 20 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 39 p: 00 pc: 0264 sp: FD x: 20 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 39 p: 00 pc: 0266 sp: FD x: 20 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 20 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 20 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 20 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 20 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 20 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 20 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 20 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 00 pc: 025D sp: FD x: 20 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 39 p: 00 pc: 025F sp: FD x: 20 y: 02 
---
[1]    55 0261: 	sec
[2] a: 39 p: 00 pc: 0261 sp: FD x: 20 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 39 p: 01 pc: 0262 sp: FD x: 20 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 20 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 20 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 20 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 20 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 20 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 20 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 20 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 20 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 20 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 20 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 20 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 20 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 20 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 20 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 20 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 20 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 20 y: 02 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 20 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 20 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 20 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 20 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 20 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1A p: 00 pc: 026A sp: FD x: 20 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1A p: 00 pc: 026C sp: FD x: 20 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1A p: 00 pc: 026E sp: FD x: 20 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1A p: 00 pc: 0270 sp: FD x: 20 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1A p: 00 pc: 0259 sp: FD x: 20 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 20 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 20 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 20 y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 20 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 20 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 20 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 20 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1A p: 00 pc: 0268 sp: FD x: 20 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1B p: 00 pc: 026A sp: FD x: 20 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 00 pc: 026C sp: FD x: 20 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 01 pc: 026E sp: FD x: 20 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 03 pc: 0270 sp: FD x: 20 y: 02 
---
[1]    64 0272: 	rts
[2] a: 1B p: 03 pc: 0272 sp: FD x: 20 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1B p: 03 pc: 0220 sp: FF x: 20 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 20 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 20 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 20 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 20 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 20 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 20 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 20 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 89 p: 81 pc: 0216 sp: FF x: 20 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 89 p: 81 pc: 0218 sp: FF x: 20 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 20 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 20 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 20 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 20 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 20 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 20 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 20 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 20 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 20 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 20 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 20 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 20 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 20 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 20 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 20 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 20 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 20 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 20 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 20 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 20 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 20 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 20 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 20 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 20 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 20 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 20 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 20 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 20 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 20 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 20 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 20 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 20 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 20 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 20 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 89 p: 80 pc: 025B sp: FD x: 20 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 89 p: 81 pc: 025D sp: FD x: 20 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 89 p: 81 pc: 026C sp: FD x: 20 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 89 p: 00 pc: 026E sp: FD x: 20 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 89 p: 00 pc: 0270 sp: FD x: 20 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 89 p: 00 pc: 0259 sp: FD x: 20 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 89 p: 80 pc: 025B sp: FD x: 20 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 89 p: 00 pc: 025D sp: FD x: 20 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 89 p: 00 pc: 025F sp: FD x: 20 y: 03 
---
[1]    55 0261: 	sec
[2] a: 89 p: 80 pc: 0261 sp: FD x: 20 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 89 p: 81 pc: 0262 sp: FD x: 20 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 20 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 20 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 20 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 20 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 20 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 20 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 20 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 20 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 20 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 20 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 20 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 20 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 20 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 20 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 20 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 20 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 20 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 20 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 20 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 20 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 20 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 20 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 20 y: 03 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 20 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 20 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 20 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 20 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 20 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 20 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 20 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 20 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 20 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 20 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 20 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 20 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 20 y: 03 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 20 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 20 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 20 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 20 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 12 p: 00 pc: 0268 sp: FD x: 20 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 13 p: 00 pc: 026A sp: FD x: 20 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 00 pc: 026C sp: FD x: 20 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 01 pc: 026E sp: FD x: 20 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 03 pc: 0270 sp: FD x: 20 y: 03 
---
[1]    64 0272: 	rts
[2] a: 13 p: 03 pc: 0272 sp: FD x: 20 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 13 p: 03 pc: 0220 sp: FF x: 20 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 20 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 20 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 20 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 20 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 20 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 20 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 20 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 89 p: 81 pc: 0216 sp: FF x: 20 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 89 p: 81 pc: 0218 sp: FF x: 20 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 20 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 20 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 20 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 20 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 20 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 20 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 20 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 20 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 20 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 20 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 20 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 20 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 20 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 20 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 20 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 20 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 20 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 20 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 20 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 20 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 20 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 20 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 20 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 20 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 20 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 20 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 20 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 20 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 20 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 89 p: 80 pc: 025B sp: FD x: 20 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 89 p: 81 pc: 025D sp: FD x: 20 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 89 p: 81 pc: 026C sp: FD x: 20 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 89 p: 00 pc: 026E sp: FD x: 20 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 89 p: 00 pc: 0270 sp: FD x: 20 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 89 p: 00 pc: 0259 sp: FD x: 20 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 89 p: 80 pc: 025B sp: FD x: 20 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 89 p: 00 pc: 025D sp: FD x: 20 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 89 p: 00 pc: 025F sp: FD x: 20 y: 04 
---
[1]    55 0261: 	sec
[2] a: 89 p: 80 pc: 0261 sp: FD x: 20 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 89 p: 81 pc: 0262 sp: FD x: 20 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 31 p: 00 pc: 0264 sp: FD x: 20 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 31 p: 00 pc: 0266 sp: FD x: 20 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 20 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 20 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 20 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 20 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 20 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 20 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 20 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 00 pc: 025D sp: FD x: 20 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 31 p: 00 pc: 025F sp: FD x: 20 y: 04 
---
[1]    55 0261: 	sec
[2] a: 31 p: 00 pc: 0261 sp: FD x: 20 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 31 p: 01 pc: 0262 sp: FD x: 20 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 20 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 20 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 20 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 20 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 20 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 20 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 20 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 20 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 20 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 20 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 20 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 20 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 20 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 20 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 20 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 20 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 20 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 20 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 20 y: 04 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 20 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 20 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 20 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 20 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 20 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 20 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 20 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 20 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 20 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: 89 p: 81 pc: 0216 sp: FF x: 20 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: 89 p: 81 pc: 0218 sp: FF x: 20 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 20 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 20 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 20 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 20 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 20 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 20 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 20 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 20 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 20 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 20 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 20 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 20 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 20 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 20 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 20 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 20 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 20 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 20 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 20 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 20 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 20 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 20 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 20 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 20 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 20 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 20 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 20 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 20 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 20 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 89 p: 80 pc: 025B sp: FD x: 20 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 89 p: 81 pc: 025D sp: FD x: 20 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 89 p: 81 pc: 026C sp: FD x: 20 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 89 p: 00 pc: 026E sp: FD x: 20 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 89 p: 00 pc: 0270 sp: FD x: 20 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 89 p: 00 pc: 0259 sp: FD x: 20 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 89 p: 80 pc: 025B sp: FD x: 20 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 89 p: 00 pc: 025D sp: FD x: 20 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 89 p: 00 pc: 025F sp: FD x: 20 y: 05 
---
[1]    55 0261: 	sec
[2] a: 89 p: 80 pc: 0261 sp: FD x: 20 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 89 p: 81 pc: 0262 sp: FD x: 20 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 20 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 20 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 20 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 20 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 20 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 20 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 20 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 20 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 20 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 20 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 20 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 20 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 20 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 20 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 20 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 20 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 20 y: 05 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 20 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 20 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 20 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 20 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 20 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 20 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 20 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 20 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 20 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 20 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 20 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 20 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 20 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 20 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 20 y: 05 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 20 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 20 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 07 p: 01 pc: 0222 sp: FF x: 20 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 07 p: 01 pc: 0224 sp: FF x: 20 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 20 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 00 pc: 0229 sp: FF x: 20 y: 05 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0D p: 00 pc: 022E sp: FF x: 20 y: 05 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 89 p: 80 pc: 0231 sp: FF x: 20 y: 05 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 89 p: 00 pc: 0232 sp: FF x: 21 y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 89 p: 00 pc: 0235 sp: FF x: 21 y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 89 p: 80 pc: 0238 sp: FF x: 21 y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: 89 p: 80 pc: 023B sp: FF x: 21 y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 8B p: 80 pc: 023E sp: FF x: 21 y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: 8B p: 81 pc: 0240 sp: FF x: 21 y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 8B p: 81 pc: 0211 sp: FF x: 21 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 8B p: 01 pc: 0213 sp: FF x: 21 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 8B p: 81 pc: 0216 sp: FF x: 21 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 8B p: 81 pc: 0218 sp: FF x: 21 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 21 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 21 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 21 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 21 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 21 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 21 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 21 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 21 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 21 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 21 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 21 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 21 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 21 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 21 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 21 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 21 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 21 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 21 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 21 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 21 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 21 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 21 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 21 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 21 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 21 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 21 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 21 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 21 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 21 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 21 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 21 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 21 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 21 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 21 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 21 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 21 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 21 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 21 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 21 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8B p: 80 pc: 025B sp: FD x: 21 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8B p: 81 pc: 025D sp: FD x: 21 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 8B p: 81 pc: 026C sp: FD x: 21 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 8B p: 00 pc: 026E sp: FD x: 21 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 8B p: 00 pc: 0270 sp: FD x: 21 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 8B p: 00 pc: 0259 sp: FD x: 21 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8B p: 80 pc: 025B sp: FD x: 21 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8B p: 00 pc: 025D sp: FD x: 21 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 8B p: 00 pc: 025F sp: FD x: 21 y: 01 
---
[1]    55 0261: 	sec
[2] a: 8B p: 80 pc: 0261 sp: FD x: 21 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 8B p: 81 pc: 0262 sp: FD x: 21 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 2B p: 00 pc: 0264 sp: FD x: 21 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 2B p: 00 pc: 0266 sp: FD x: 21 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 21 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 21 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 21 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 21 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 21 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 21 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 21 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 81 pc: 025D sp: FD x: 21 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 81 pc: 026C sp: FD x: 21 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 00 pc: 026E sp: FD x: 21 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 00 pc: 0270 sp: FD x: 21 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2B p: 00 pc: 0259 sp: FD x: 21 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 21 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 00 pc: 025D sp: FD x: 21 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2B p: 00 pc: 025F sp: FD x: 21 y: 01 
---
[1]    55 0261: 	sec
[2] a: 2B p: 00 pc: 0261 sp: FD x: 21 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2B p: 01 pc: 0262 sp: FD x: 21 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 21 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 21 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 21 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 21 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 21 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 21 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 21 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 21 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 21 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 21 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 21 y: 01 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 21 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 21 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 21 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 21 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 21 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 21 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 21 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 21 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 21 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 21 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 21 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 21 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 21 y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 21 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 21 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 21 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 21 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2C p: 00 pc: 0268 sp: FD x: 21 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2E p: 00 pc: 026A sp: FD x: 21 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2E p: 00 pc: 026C sp: FD x: 21 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2E p: 00 pc: 026E sp: FD x: 21 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2E p: 00 pc: 0270 sp: FD x: 21 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2E p: 00 pc: 0259 sp: FD x: 21 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 21 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 21 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 21 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 21 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 21 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 21 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 21 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 21 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 21 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 21 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 21 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 21 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 21 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 21 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 8B p: 81 pc: 0216 sp: FF x: 21 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 8B p: 81 pc: 0218 sp: FF x: 21 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 21 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 21 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 21 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 21 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 21 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 21 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 21 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 21 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 21 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 21 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 21 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 21 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 21 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 21 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 21 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 21 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 21 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 21 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 21 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 21 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 21 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 21 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 21 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 21 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 21 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 21 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 21 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 21 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 21 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 21 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 21 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 21 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 21 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 21 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8B p: 80 pc: 025B sp: FD x: 21 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8B p: 81 pc: 025D sp: FD x: 21 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 8B p: 81 pc: 026C sp: FD x: 21 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 8B p: 00 pc: 026E sp: FD x: 21 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 8B p: 00 pc: 0270 sp: FD x: 21 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 8B p: 00 pc: 0259 sp: FD x: 21 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8B p: 80 pc: 025B sp: FD x: 21 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8B p: 00 pc: 025D sp: FD x: 21 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 8B p: 00 pc: 025F sp: FD x: 21 y: 02 
---
[1]    55 0261: 	sec
[2] a: 8B p: 80 pc: 0261 sp: FD x: 21 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 8B p: 81 pc: 0262 sp: FD x: 21 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 3B p: 00 pc: 0264 sp: FD x: 21 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 3B p: 00 pc: 0266 sp: FD x: 21 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 21 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 21 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 21 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 21 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 21 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 21 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 21 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 00 pc: 025D sp: FD x: 21 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 3B p: 00 pc: 025F sp: FD x: 21 y: 02 
---
[1]    55 0261: 	sec
[2] a: 3B p: 00 pc: 0261 sp: FD x: 21 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3B p: 01 pc: 0262 sp: FD x: 21 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 21 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 21 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 21 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 21 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 21 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 21 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 21 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 21 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 21 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 21 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 21 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 21 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 21 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 21 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 21 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 21 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 21 y: 02 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 21 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 21 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 21 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 21 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 21 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1A p: 00 pc: 026A sp: FD x: 21 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1A p: 00 pc: 026C sp: FD x: 21 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1A p: 00 pc: 026E sp: FD x: 21 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1A p: 00 pc: 0270 sp: FD x: 21 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1A p: 00 pc: 0259 sp: FD x: 21 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 21 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 21 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 21 y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 21 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 21 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 21 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 21 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1A p: 00 pc: 0268 sp: FD x: 21 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1B p: 00 pc: 026A sp: FD x: 21 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 00 pc: 026C sp: FD x: 21 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 01 pc: 026E sp: FD x: 21 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 03 pc: 0270 sp: FD x: 21 y: 02 
---
[1]    64 0272: 	rts
[2] a: 1B p: 03 pc: 0272 sp: FD x: 21 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1B p: 03 pc: 0220 sp: FF x: 21 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 21 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 21 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 21 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 21 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 21 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 21 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 21 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 8B p: 81 pc: 0216 sp: FF x: 21 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 8B p: 81 pc: 0218 sp: FF x: 21 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 21 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 21 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 21 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 21 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 21 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 21 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 21 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 21 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 21 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 21 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 21 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 21 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 21 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 21 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 21 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 21 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 21 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 21 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 21 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 21 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 21 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 21 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 21 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 21 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 21 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 21 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 21 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 21 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 21 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 21 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 21 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 21 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 21 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 21 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8B p: 80 pc: 025B sp: FD x: 21 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8B p: 81 pc: 025D sp: FD x: 21 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 8B p: 81 pc: 026C sp: FD x: 21 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 8B p: 00 pc: 026E sp: FD x: 21 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 8B p: 00 pc: 0270 sp: FD x: 21 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 8B p: 00 pc: 0259 sp: FD x: 21 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8B p: 80 pc: 025B sp: FD x: 21 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8B p: 00 pc: 025D sp: FD x: 21 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 8B p: 00 pc: 025F sp: FD x: 21 y: 03 
---
[1]    55 0261: 	sec
[2] a: 8B p: 80 pc: 0261 sp: FD x: 21 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 8B p: 81 pc: 0262 sp: FD x: 21 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 21 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 21 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 21 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 21 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 21 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 21 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 21 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 21 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 21 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 21 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 21 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 21 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 21 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 21 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 21 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 21 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 21 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 21 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 21 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 21 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 21 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 21 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 21 y: 03 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 21 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 21 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 21 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 21 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 21 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 21 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 21 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 21 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 21 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 21 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 21 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 21 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 21 y: 03 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 21 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 21 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 21 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 21 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 12 p: 00 pc: 0268 sp: FD x: 21 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 13 p: 00 pc: 026A sp: FD x: 21 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 00 pc: 026C sp: FD x: 21 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 01 pc: 026E sp: FD x: 21 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 03 pc: 0270 sp: FD x: 21 y: 03 
---
[1]    64 0272: 	rts
[2] a: 13 p: 03 pc: 0272 sp: FD x: 21 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 13 p: 03 pc: 0220 sp: FF x: 21 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 21 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 21 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 21 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 21 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 21 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 21 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 21 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 8B p: 81 pc: 0216 sp: FF x: 21 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 8B p: 81 pc: 0218 sp: FF x: 21 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 21 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 21 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 21 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 21 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 21 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 21 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 21 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 21 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 21 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 21 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 21 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 21 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 21 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 21 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 21 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 21 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 21 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 21 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 21 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 21 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 21 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 21 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 21 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 21 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 21 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 21 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 21 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 21 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 21 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8B p: 80 pc: 025B sp: FD x: 21 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8B p: 81 pc: 025D sp: FD x: 21 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 8B p: 81 pc: 026C sp: FD x: 21 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 8B p: 00 pc: 026E sp: FD x: 21 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 8B p: 00 pc: 0270 sp: FD x: 21 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 8B p: 00 pc: 0259 sp: FD x: 21 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8B p: 80 pc: 025B sp: FD x: 21 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8B p: 00 pc: 025D sp: FD x: 21 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 8B p: 00 pc: 025F sp: FD x: 21 y: 04 
---
[1]    55 0261: 	sec
[2] a: 8B p: 80 pc: 0261 sp: FD x: 21 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 8B p: 81 pc: 0262 sp: FD x: 21 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 33 p: 00 pc: 0264 sp: FD x: 21 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 33 p: 00 pc: 0266 sp: FD x: 21 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 21 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 21 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 21 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 21 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 21 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 21 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 21 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 00 pc: 025D sp: FD x: 21 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 33 p: 00 pc: 025F sp: FD x: 21 y: 04 
---
[1]    55 0261: 	sec
[2] a: 33 p: 00 pc: 0261 sp: FD x: 21 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 33 p: 01 pc: 0262 sp: FD x: 21 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 21 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 21 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 21 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 21 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 21 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 21 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 21 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 21 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 21 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 21 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 21 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 21 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 21 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 21 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 21 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 21 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 21 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 21 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 21 y: 04 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 21 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 21 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 07 p: 01 pc: 0222 sp: FF x: 21 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 07 p: 01 pc: 0224 sp: FF x: 21 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 21 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 21 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 21 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 21 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 21 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: 8B p: 81 pc: 0216 sp: FF x: 21 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: 8B p: 81 pc: 0218 sp: FF x: 21 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 21 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 21 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 21 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 21 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 21 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 21 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 21 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 21 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 21 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 21 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 21 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 21 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 21 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 21 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 21 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 21 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 21 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 21 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 21 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 21 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 21 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 21 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 21 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 21 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 21 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 21 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 21 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 21 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 21 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8B p: 80 pc: 025B sp: FD x: 21 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8B p: 81 pc: 025D sp: FD x: 21 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 8B p: 81 pc: 026C sp: FD x: 21 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 8B p: 00 pc: 026E sp: FD x: 21 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 8B p: 00 pc: 0270 sp: FD x: 21 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 8B p: 00 pc: 0259 sp: FD x: 21 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8B p: 80 pc: 025B sp: FD x: 21 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8B p: 00 pc: 025D sp: FD x: 21 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 8B p: 00 pc: 025F sp: FD x: 21 y: 05 
---
[1]    55 0261: 	sec
[2] a: 8B p: 80 pc: 0261 sp: FD x: 21 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 8B p: 81 pc: 0262 sp: FD x: 21 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 21 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 21 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 21 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 21 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 21 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 21 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 21 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 21 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 21 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 81 pc: 025D sp: FD x: 21 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 81 pc: 026C sp: FD x: 21 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 00 pc: 026E sp: FD x: 21 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 00 pc: 0270 sp: FD x: 21 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 23 p: 00 pc: 0259 sp: FD x: 21 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 21 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 21 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 21 y: 05 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 21 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 21 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 21 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 21 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 21 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 21 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 21 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 21 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 21 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 21 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 21 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 21 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 21 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 21 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 21 y: 05 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 21 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 21 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 09 p: 01 pc: 0222 sp: FF x: 21 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 09 p: 01 pc: 0224 sp: FF x: 21 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 21 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 00 pc: 0229 sp: FF x: 21 y: 05 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0D p: 00 pc: 022E sp: FF x: 21 y: 05 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 8B p: 80 pc: 0231 sp: FF x: 21 y: 05 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 8B p: 00 pc: 0232 sp: FF x: 22 y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 8B p: 00 pc: 0235 sp: FF x: 22 y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 8B p: 80 pc: 0238 sp: FF x: 22 y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: 8B p: 80 pc: 023B sp: FF x: 22 y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 8D p: 80 pc: 023E sp: FF x: 22 y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: 8D p: 81 pc: 0240 sp: FF x: 22 y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 8D p: 81 pc: 0211 sp: FF x: 22 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 8D p: 01 pc: 0213 sp: FF x: 22 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 8D p: 81 pc: 0216 sp: FF x: 22 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 8D p: 81 pc: 0218 sp: FF x: 22 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 22 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 22 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 22 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8D p: 80 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8D p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 8D p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 8D p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 8D p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 8D p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8D p: 80 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8D p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 8D p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 8D p: 80 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 8D p: 81 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 2D p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 2D p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2D p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2D p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2D p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2D p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2D p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 2D p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2D p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2C p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2E p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2E p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2E p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2E p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2E p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2E p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2F p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2F p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2F p: 01 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2F p: 03 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    64 0272: 	rts
[2] a: 2F p: 03 pc: 0272 sp: FD x: 22 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 2F p: 03 pc: 0220 sp: FF x: 22 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 22 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 22 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 22 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 22 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 8F p: 81 pc: 023E sp: FF x: 22 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 8F p: 81 pc: 0240 sp: FF x: 22 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 8F p: 81 pc: 0211 sp: FF x: 22 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 8F p: 01 pc: 0213 sp: FF x: 22 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 8F p: 81 pc: 0216 sp: FF x: 22 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 8F p: 81 pc: 0218 sp: FF x: 22 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 22 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 22 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 22 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8F p: 80 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8F p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 8F p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 8F p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 8F p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 8F p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8F p: 80 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8F p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 8F p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 8F p: 80 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 8F p: 81 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 2F p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 2F p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2F p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2F p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2F p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2F p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2F p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 2F p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2F p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2C p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2E p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2E p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2E p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2E p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2E p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2E p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2F p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2F p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2F p: 01 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2F p: 03 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    64 0272: 	rts
[2] a: 2F p: 03 pc: 0272 sp: FD x: 22 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 2F p: 03 pc: 0220 sp: FF x: 22 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 22 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 22 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 22 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 22 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 22 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 22 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 22 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 8F p: 81 pc: 0216 sp: FF x: 22 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 8F p: 81 pc: 0218 sp: FF x: 22 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 22 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 22 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 22 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8F p: 80 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8F p: 81 pc: 025D sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 8F p: 81 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 8F p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 8F p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 8F p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8F p: 80 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8F p: 00 pc: 025D sp: FD x: 22 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 8F p: 00 pc: 025F sp: FD x: 22 y: 02 
---
[1]    55 0261: 	sec
[2] a: 8F p: 80 pc: 0261 sp: FD x: 22 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 8F p: 81 pc: 0262 sp: FD x: 22 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 3F p: 00 pc: 0264 sp: FD x: 22 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 3F p: 00 pc: 0266 sp: FD x: 22 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 22 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3F p: 00 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3F p: 00 pc: 025D sp: FD x: 22 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 3F p: 00 pc: 025F sp: FD x: 22 y: 02 
---
[1]    55 0261: 	sec
[2] a: 3F p: 00 pc: 0261 sp: FD x: 22 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3F p: 01 pc: 0262 sp: FD x: 22 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 22 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 22 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 22 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 22 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 22 y: 02 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 22 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 22 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 22 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 22 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 22 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 22 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 22 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 22 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 22 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 22 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 22 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 22 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 22 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 22 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 8F p: 81 pc: 0216 sp: FF x: 22 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 8F p: 81 pc: 0218 sp: FF x: 22 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 22 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 22 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 22 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 22 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 22 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 22 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 22 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 22 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 22 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 22 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 22 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 22 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 22 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 22 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 22 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 22 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 22 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 22 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 22 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 22 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 22 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 22 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 22 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 22 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 22 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 22 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 22 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 22 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 22 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 22 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8F p: 80 pc: 025B sp: FD x: 22 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8F p: 81 pc: 025D sp: FD x: 22 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 8F p: 81 pc: 026C sp: FD x: 22 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 8F p: 00 pc: 026E sp: FD x: 22 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 8F p: 00 pc: 0270 sp: FD x: 22 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 8F p: 00 pc: 0259 sp: FD x: 22 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8F p: 80 pc: 025B sp: FD x: 22 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8F p: 00 pc: 025D sp: FD x: 22 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 8F p: 00 pc: 025F sp: FD x: 22 y: 03 
---
[1]    55 0261: 	sec
[2] a: 8F p: 80 pc: 0261 sp: FD x: 22 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 8F p: 81 pc: 0262 sp: FD x: 22 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 1F p: 00 pc: 0264 sp: FD x: 22 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 1F p: 00 pc: 0266 sp: FD x: 22 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 22 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 22 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 22 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 22 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 22 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 22 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 22 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 81 pc: 025D sp: FD x: 22 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 81 pc: 026C sp: FD x: 22 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 00 pc: 026E sp: FD x: 22 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 00 pc: 0270 sp: FD x: 22 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1F p: 00 pc: 0259 sp: FD x: 22 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 22 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 22 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 22 y: 03 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 22 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 22 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 22 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 22 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 22 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 22 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 22 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 22 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 22 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 22 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 22 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 22 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 22 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 22 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 22 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 22 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 22 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 22 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 22 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 22 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 22 y: 03 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 22 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 22 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 22 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 22 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 22 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 22 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 22 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 22 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 22 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 8F p: 81 pc: 0216 sp: FF x: 22 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 8F p: 81 pc: 0218 sp: FF x: 22 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 22 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 22 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 22 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 22 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 22 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 22 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 22 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 22 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 22 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 22 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 22 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 22 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 22 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 22 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 22 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 22 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 22 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 22 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 22 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 22 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 22 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 22 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 22 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 22 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 22 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8F p: 80 pc: 025B sp: FD x: 22 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8F p: 81 pc: 025D sp: FD x: 22 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 8F p: 81 pc: 026C sp: FD x: 22 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 8F p: 00 pc: 026E sp: FD x: 22 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 8F p: 00 pc: 0270 sp: FD x: 22 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 8F p: 00 pc: 0259 sp: FD x: 22 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 8F p: 80 pc: 025B sp: FD x: 22 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 8F p: 00 pc: 025D sp: FD x: 22 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 8F p: 00 pc: 025F sp: FD x: 22 y: 04 
---
[1]    55 0261: 	sec
[2] a: 8F p: 80 pc: 0261 sp: FD x: 22 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 8F p: 81 pc: 0262 sp: FD x: 22 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 37 p: 00 pc: 0264 sp: FD x: 22 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 37 p: 00 pc: 0266 sp: FD x: 22 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 22 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 22 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 22 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 22 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 22 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 22 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 22 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 00 pc: 025D sp: FD x: 22 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 37 p: 00 pc: 025F sp: FD x: 22 y: 04 
---
[1]    55 0261: 	sec
[2] a: 37 p: 00 pc: 0261 sp: FD x: 22 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 37 p: 01 pc: 0262 sp: FD x: 22 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 22 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 22 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 22 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 22 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 22 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 22 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 22 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 22 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 22 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 22 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 22 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 22 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 22 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 22 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 22 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 02 pc: 025D sp: FD x: 22 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 02 pc: 025F sp: FD x: 22 y: 04 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 22 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 22 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 22 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 22 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 22 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 22 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 22 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 22 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 22 y: 04 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 22 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 22 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 22 y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 22 y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 22 y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 22 y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 91 p: 81 pc: 023E sp: FF x: 22 y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: 91 p: 81 pc: 0240 sp: FF x: 22 y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 91 p: 81 pc: 0211 sp: FF x: 22 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 91 p: 01 pc: 0213 sp: FF x: 22 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 91 p: 81 pc: 0216 sp: FF x: 22 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 91 p: 81 pc: 0218 sp: FF x: 22 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 22 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 22 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 22 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 91 p: 80 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 91 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 91 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 91 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 91 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 91 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 91 p: 80 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 91 p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 91 p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 91 p: 80 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 91 p: 81 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 31 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 31 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 31 p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 31 p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 31 p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 22 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 22 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 22 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 22 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 22 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 22 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 22 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 22 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 22 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 91 p: 81 pc: 0216 sp: FF x: 22 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 91 p: 81 pc: 0218 sp: FF x: 22 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 22 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 22 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 22 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 91 p: 80 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 91 p: 81 pc: 025D sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 91 p: 81 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 91 p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 91 p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 91 p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 91 p: 80 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 91 p: 00 pc: 025D sp: FD x: 22 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 91 p: 00 pc: 025F sp: FD x: 22 y: 02 
---
[1]    55 0261: 	sec
[2] a: 91 p: 80 pc: 0261 sp: FD x: 22 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 91 p: 81 pc: 0262 sp: FD x: 22 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 41 p: 40 pc: 0264 sp: FD x: 22 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 41 p: 40 pc: 0266 sp: FD x: 22 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 22 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 41 p: 40 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 41 p: 40 pc: 025D sp: FD x: 22 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 41 p: 40 pc: 025F sp: FD x: 22 y: 02 
---
[1]    55 0261: 	sec
[2] a: 41 p: 40 pc: 0261 sp: FD x: 22 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 41 p: 41 pc: 0262 sp: FD x: 22 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 22 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 22 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 22 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 22 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 22 y: 02 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 22 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 22 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 22 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 22 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 22 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 22 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 22 y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 22 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 22 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 22 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 22 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 22 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1D p: 00 pc: 026A sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 00 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 01 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 03 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    64 0272: 	rts
[2] a: 1D p: 03 pc: 0272 sp: FD x: 22 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1D p: 03 pc: 0220 sp: FF x: 22 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 22 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 22 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 22 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 22 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 93 p: 81 pc: 023E sp: FF x: 22 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 93 p: 81 pc: 0240 sp: FF x: 22 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 93 p: 81 pc: 0211 sp: FF x: 22 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 93 p: 01 pc: 0213 sp: FF x: 22 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 93 p: 81 pc: 0216 sp: FF x: 22 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 93 p: 81 pc: 0218 sp: FF x: 22 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 22 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 22 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 22 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 93 p: 80 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 93 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 93 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 93 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 93 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 93 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 93 p: 80 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 93 p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 93 p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 93 p: 80 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 93 p: 81 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 33 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 33 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 33 p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 33 p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 33 p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 31 p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 31 p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 31 p: 01 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 31 p: 03 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    64 0272: 	rts
[2] a: 31 p: 03 pc: 0272 sp: FD x: 22 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 31 p: 03 pc: 0220 sp: FF x: 22 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 22 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 22 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 22 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 22 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 95 p: 81 pc: 023E sp: FF x: 22 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 95 p: 81 pc: 0240 sp: FF x: 22 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 95 p: 81 pc: 0211 sp: FF x: 22 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 95 p: 01 pc: 0213 sp: FF x: 22 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 95 p: 81 pc: 0216 sp: FF x: 22 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 95 p: 81 pc: 0218 sp: FF x: 22 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 22 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 22 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 22 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 22 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 22 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 22 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 22 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 22 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 95 p: 80 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 95 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 95 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 95 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 95 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 95 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 95 p: 80 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 95 p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 95 p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 95 p: 80 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 95 p: 81 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 35 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 35 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 35 p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 35 p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 35 p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 22 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 22 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 22 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 22 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 22 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 22 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 22 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 22 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 22 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 31 p: 00 pc: 026A sp: FD x: 22 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 31 p: 00 pc: 026C sp: FD x: 22 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 31 p: 01 pc: 026E sp: FD x: 22 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 31 p: 03 pc: 0270 sp: FD x: 22 y: 01 
---
[1]    64 0272: 	rts
[2] a: 31 p: 03 pc: 0272 sp: FD x: 22 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 31 p: 03 pc: 0220 sp: FF x: 22 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 22 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 22 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 22 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 22 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 22 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 22 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 22 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 95 p: 81 pc: 0216 sp: FF x: 22 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 95 p: 81 pc: 0218 sp: FF x: 22 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 22 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 22 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 22 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 22 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 22 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 22 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 22 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 22 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 95 p: 80 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 95 p: 81 pc: 025D sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 95 p: 81 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 95 p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 95 p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 95 p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 95 p: 80 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 95 p: 00 pc: 025D sp: FD x: 22 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 95 p: 00 pc: 025F sp: FD x: 22 y: 02 
---
[1]    55 0261: 	sec
[2] a: 95 p: 80 pc: 0261 sp: FD x: 22 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 95 p: 81 pc: 0262 sp: FD x: 22 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 45 p: 40 pc: 0264 sp: FD x: 22 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 45 p: 40 pc: 0266 sp: FD x: 22 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 22 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 45 p: 40 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 45 p: 40 pc: 025D sp: FD x: 22 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 45 p: 40 pc: 025F sp: FD x: 22 y: 02 
---
[1]    55 0261: 	sec
[2] a: 45 p: 40 pc: 0261 sp: FD x: 22 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 45 p: 41 pc: 0262 sp: FD x: 22 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 1D p: 00 pc: 0264 sp: FD x: 22 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 1D p: 00 pc: 0266 sp: FD x: 22 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 22 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 22 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 22 y: 02 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 22 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 22 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 22 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 22 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 22 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 22 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 22 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 22 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 22 y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 22 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 22 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 22 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 22 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 22 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1D p: 00 pc: 026A sp: FD x: 22 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 00 pc: 026C sp: FD x: 22 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 01 pc: 026E sp: FD x: 22 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 03 pc: 0270 sp: FD x: 22 y: 02 
---
[1]    64 0272: 	rts
[2] a: 1D p: 03 pc: 0272 sp: FD x: 22 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1D p: 03 pc: 0220 sp: FF x: 22 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 22 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 22 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 22 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 22 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 22 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 22 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 22 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 95 p: 81 pc: 0216 sp: FF x: 22 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 95 p: 81 pc: 0218 sp: FF x: 22 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 22 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 22 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 22 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 22 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 22 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 22 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 22 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 22 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 22 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 22 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 22 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 22 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 22 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 22 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 22 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 22 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 22 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 22 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 22 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 22 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 22 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 22 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 22 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 22 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 22 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 22 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 22 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 22 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 22 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 22 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 95 p: 80 pc: 025B sp: FD x: 22 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 95 p: 81 pc: 025D sp: FD x: 22 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 95 p: 81 pc: 026C sp: FD x: 22 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 95 p: 00 pc: 026E sp: FD x: 22 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 95 p: 00 pc: 0270 sp: FD x: 22 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 95 p: 00 pc: 0259 sp: FD x: 22 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 95 p: 80 pc: 025B sp: FD x: 22 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 95 p: 00 pc: 025D sp: FD x: 22 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 95 p: 00 pc: 025F sp: FD x: 22 y: 03 
---
[1]    55 0261: 	sec
[2] a: 95 p: 80 pc: 0261 sp: FD x: 22 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 95 p: 81 pc: 0262 sp: FD x: 22 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 25 p: 00 pc: 0264 sp: FD x: 22 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 25 p: 00 pc: 0266 sp: FD x: 22 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 22 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 22 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 22 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 22 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 22 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 22 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 22 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 81 pc: 025D sp: FD x: 22 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 81 pc: 026C sp: FD x: 22 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 00 pc: 026E sp: FD x: 22 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 00 pc: 0270 sp: FD x: 22 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 25 p: 00 pc: 0259 sp: FD x: 22 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 22 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 22 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 22 y: 03 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 22 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 22 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 22 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 22 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 22 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 22 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 22 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 22 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 22 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 22 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 22 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 22 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 22 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 22 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 22 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 22 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 22 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 22 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 22 y: 03 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 22 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 22 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 22 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 22 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 22 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 15 p: 00 pc: 026A sp: FD x: 22 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 00 pc: 026C sp: FD x: 22 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 01 pc: 026E sp: FD x: 22 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 03 pc: 0270 sp: FD x: 22 y: 03 
---
[1]    64 0272: 	rts
[2] a: 15 p: 03 pc: 0272 sp: FD x: 22 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 15 p: 03 pc: 0220 sp: FF x: 22 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 22 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 22 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 22 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 22 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 22 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 22 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 22 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 95 p: 81 pc: 0216 sp: FF x: 22 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 95 p: 81 pc: 0218 sp: FF x: 22 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 22 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 22 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 22 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 22 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 22 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 22 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 22 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 22 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 22 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 22 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 22 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 22 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 22 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 22 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 22 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 22 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 22 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 22 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 22 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 22 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 22 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 22 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 22 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 22 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 22 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 95 p: 80 pc: 025B sp: FD x: 22 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 95 p: 81 pc: 025D sp: FD x: 22 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 95 p: 81 pc: 026C sp: FD x: 22 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 95 p: 00 pc: 026E sp: FD x: 22 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 95 p: 00 pc: 0270 sp: FD x: 22 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 95 p: 00 pc: 0259 sp: FD x: 22 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 95 p: 80 pc: 025B sp: FD x: 22 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 95 p: 00 pc: 025D sp: FD x: 22 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 95 p: 00 pc: 025F sp: FD x: 22 y: 04 
---
[1]    55 0261: 	sec
[2] a: 95 p: 80 pc: 0261 sp: FD x: 22 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 95 p: 81 pc: 0262 sp: FD x: 22 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 3D p: 00 pc: 0264 sp: FD x: 22 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 3D p: 00 pc: 0266 sp: FD x: 22 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 22 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 22 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 22 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 22 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 22 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 22 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 22 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 00 pc: 025D sp: FD x: 22 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 3D p: 00 pc: 025F sp: FD x: 22 y: 04 
---
[1]    55 0261: 	sec
[2] a: 3D p: 00 pc: 0261 sp: FD x: 22 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3D p: 01 pc: 0262 sp: FD x: 22 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 22 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 22 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 22 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 22 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 22 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 22 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 22 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 22 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 22 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 22 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 22 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 22 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 22 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 22 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 22 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 22 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 22 y: 04 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 22 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 22 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 22 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 22 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 22 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 22 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 22 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 22 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 22 y: 04 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 22 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 22 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 22 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 22 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 22 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 22 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 22 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 22 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 22 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: 95 p: 81 pc: 0216 sp: FF x: 22 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: 95 p: 81 pc: 0218 sp: FF x: 22 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 22 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 22 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 22 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 22 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 22 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 22 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 22 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 22 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 22 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 22 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 22 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 22 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 22 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 22 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 22 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 22 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 22 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 22 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 22 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 22 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 22 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 22 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 22 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 22 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 22 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 22 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 22 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 22 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 22 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 95 p: 80 pc: 025B sp: FD x: 22 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 95 p: 81 pc: 025D sp: FD x: 22 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 95 p: 81 pc: 026C sp: FD x: 22 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 95 p: 00 pc: 026E sp: FD x: 22 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 95 p: 00 pc: 0270 sp: FD x: 22 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 95 p: 00 pc: 0259 sp: FD x: 22 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 95 p: 80 pc: 025B sp: FD x: 22 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 95 p: 00 pc: 025D sp: FD x: 22 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 95 p: 00 pc: 025F sp: FD x: 22 y: 05 
---
[1]    55 0261: 	sec
[2] a: 95 p: 80 pc: 0261 sp: FD x: 22 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 95 p: 81 pc: 0262 sp: FD x: 22 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 2D p: 00 pc: 0264 sp: FD x: 22 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 2D p: 00 pc: 0266 sp: FD x: 22 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 22 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 22 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 22 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 22 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 22 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 22 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 22 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 81 pc: 025D sp: FD x: 22 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2D p: 81 pc: 026C sp: FD x: 22 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 2D p: 00 pc: 026E sp: FD x: 22 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2D p: 00 pc: 0270 sp: FD x: 22 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2D p: 00 pc: 0259 sp: FD x: 22 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 22 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 00 pc: 025D sp: FD x: 22 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 2D p: 00 pc: 025F sp: FD x: 22 y: 05 
---
[1]    55 0261: 	sec
[2] a: 2D p: 00 pc: 0261 sp: FD x: 22 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2D p: 01 pc: 0262 sp: FD x: 22 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 22 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 22 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 22 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 22 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 22 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 22 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 22 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 22 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 22 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 22 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 22 y: 05 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 22 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 22 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 22 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 22 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 22 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 22 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 22 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 22 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 22 y: 05 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 22 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 22 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 22 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 22 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 22 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 00 pc: 0229 sp: FF x: 22 y: 05 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0D p: 00 pc: 022E sp: FF x: 22 y: 05 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 95 p: 80 pc: 0231 sp: FF x: 22 y: 05 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 95 p: 00 pc: 0232 sp: FF x: 23 y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 95 p: 00 pc: 0235 sp: FF x: 23 y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 95 p: 80 pc: 0238 sp: FF x: 23 y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: 95 p: 80 pc: 023B sp: FF x: 23 y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 97 p: 80 pc: 023E sp: FF x: 23 y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: 97 p: 81 pc: 0240 sp: FF x: 23 y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 97 p: 81 pc: 0211 sp: FF x: 23 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 97 p: 01 pc: 0213 sp: FF x: 23 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 97 p: 81 pc: 0216 sp: FF x: 23 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 97 p: 81 pc: 0218 sp: FF x: 23 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 23 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 23 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 23 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 23 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 23 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 23 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 23 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 23 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 23 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 23 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 23 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 23 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 23 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 23 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 23 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 23 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 23 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 23 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 23 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 23 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 23 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 23 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 23 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 23 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 23 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 23 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 23 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 23 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 23 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 23 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 23 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 23 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 23 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 23 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 23 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 23 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 23 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 23 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 23 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 97 p: 80 pc: 025B sp: FD x: 23 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 97 p: 81 pc: 025D sp: FD x: 23 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 97 p: 81 pc: 026C sp: FD x: 23 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 97 p: 00 pc: 026E sp: FD x: 23 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 97 p: 00 pc: 0270 sp: FD x: 23 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 97 p: 00 pc: 0259 sp: FD x: 23 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 97 p: 80 pc: 025B sp: FD x: 23 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 97 p: 00 pc: 025D sp: FD x: 23 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 97 p: 00 pc: 025F sp: FD x: 23 y: 01 
---
[1]    55 0261: 	sec
[2] a: 97 p: 80 pc: 0261 sp: FD x: 23 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 97 p: 81 pc: 0262 sp: FD x: 23 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 37 p: 00 pc: 0264 sp: FD x: 23 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 37 p: 00 pc: 0266 sp: FD x: 23 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 23 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 23 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 23 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 23 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 23 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 23 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 23 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 00 pc: 025D sp: FD x: 23 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 37 p: 00 pc: 025F sp: FD x: 23 y: 01 
---
[1]    55 0261: 	sec
[2] a: 37 p: 00 pc: 0261 sp: FD x: 23 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 37 p: 01 pc: 0262 sp: FD x: 23 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 23 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 23 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 23 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 23 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 23 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 23 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 23 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 23 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 23 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 23 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 23 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 23 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 23 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 23 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 23 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 23 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 23 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 23 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 23 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 23 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 23 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 23 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 23 y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 23 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 23 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 23 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 23 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 23 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 32 p: 00 pc: 026A sp: FD x: 23 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 32 p: 00 pc: 026C sp: FD x: 23 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 32 p: 00 pc: 026E sp: FD x: 23 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 32 p: 00 pc: 0270 sp: FD x: 23 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 32 p: 00 pc: 0259 sp: FD x: 23 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 23 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 23 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 23 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 23 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 23 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 23 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 23 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 23 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 23 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 23 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 23 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 23 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 23 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 23 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 97 p: 81 pc: 0216 sp: FF x: 23 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 97 p: 81 pc: 0218 sp: FF x: 23 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 23 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 23 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 23 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 23 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 23 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 23 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 23 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 23 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 23 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 23 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 23 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 23 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 23 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 23 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 23 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 23 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 23 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 23 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 23 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 23 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 23 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 23 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 23 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 23 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 23 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 23 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 23 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 23 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 23 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 23 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 23 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 23 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 23 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 23 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 97 p: 80 pc: 025B sp: FD x: 23 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 97 p: 81 pc: 025D sp: FD x: 23 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 97 p: 81 pc: 026C sp: FD x: 23 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 97 p: 00 pc: 026E sp: FD x: 23 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 97 p: 00 pc: 0270 sp: FD x: 23 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 97 p: 00 pc: 0259 sp: FD x: 23 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 97 p: 80 pc: 025B sp: FD x: 23 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 97 p: 00 pc: 025D sp: FD x: 23 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 97 p: 00 pc: 025F sp: FD x: 23 y: 02 
---
[1]    55 0261: 	sec
[2] a: 97 p: 80 pc: 0261 sp: FD x: 23 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 97 p: 81 pc: 0262 sp: FD x: 23 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 47 p: 40 pc: 0264 sp: FD x: 23 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 47 p: 40 pc: 0266 sp: FD x: 23 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 23 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 23 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 23 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 23 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 23 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 23 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 47 p: 40 pc: 025B sp: FD x: 23 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 47 p: 40 pc: 025D sp: FD x: 23 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 47 p: 40 pc: 025F sp: FD x: 23 y: 02 
---
[1]    55 0261: 	sec
[2] a: 47 p: 40 pc: 0261 sp: FD x: 23 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 47 p: 41 pc: 0262 sp: FD x: 23 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 1F p: 00 pc: 0264 sp: FD x: 23 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 1F p: 00 pc: 0266 sp: FD x: 23 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 23 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 23 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 23 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 23 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 23 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 23 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 23 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 23 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 23 y: 02 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 23 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 23 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 23 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 23 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 23 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 23 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 23 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 23 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 23 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 23 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 23 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 23 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 23 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 23 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 23 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 23 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 23 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 23 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1E p: 00 pc: 026A sp: FD x: 23 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1E p: 00 pc: 026C sp: FD x: 23 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1E p: 00 pc: 026E sp: FD x: 23 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1E p: 00 pc: 0270 sp: FD x: 23 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1E p: 00 pc: 0259 sp: FD x: 23 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 23 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 23 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 23 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 23 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 23 y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 23 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 23 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 23 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 23 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 23 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 23 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 23 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 23 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 23 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 97 p: 81 pc: 0216 sp: FF x: 23 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 97 p: 81 pc: 0218 sp: FF x: 23 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 23 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 23 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 23 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 23 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 23 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 23 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 23 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 23 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 23 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 23 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 23 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 23 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 23 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 23 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 23 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 23 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 23 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 23 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 23 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 23 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 23 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 23 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 23 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 23 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 23 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 23 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 23 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 23 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 23 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 23 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 23 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 23 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 23 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 23 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 97 p: 80 pc: 025B sp: FD x: 23 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 97 p: 81 pc: 025D sp: FD x: 23 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 97 p: 81 pc: 026C sp: FD x: 23 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 97 p: 00 pc: 026E sp: FD x: 23 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 97 p: 00 pc: 0270 sp: FD x: 23 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 97 p: 00 pc: 0259 sp: FD x: 23 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 97 p: 80 pc: 025B sp: FD x: 23 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 97 p: 00 pc: 025D sp: FD x: 23 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 97 p: 00 pc: 025F sp: FD x: 23 y: 03 
---
[1]    55 0261: 	sec
[2] a: 97 p: 80 pc: 0261 sp: FD x: 23 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 97 p: 81 pc: 0262 sp: FD x: 23 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 27 p: 00 pc: 0264 sp: FD x: 23 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 27 p: 00 pc: 0266 sp: FD x: 23 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 23 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 23 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 23 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 23 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 23 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 23 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 23 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 81 pc: 025D sp: FD x: 23 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 81 pc: 026C sp: FD x: 23 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 00 pc: 026E sp: FD x: 23 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 00 pc: 0270 sp: FD x: 23 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 27 p: 00 pc: 0259 sp: FD x: 23 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 23 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 23 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 23 y: 03 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 23 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 23 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 23 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 23 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 23 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 23 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 23 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 23 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 23 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 23 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 23 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 23 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 23 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 23 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 23 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 23 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 23 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 23 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 23 y: 03 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 23 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 23 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 23 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 23 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 23 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 15 p: 00 pc: 026A sp: FD x: 23 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 00 pc: 026C sp: FD x: 23 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 01 pc: 026E sp: FD x: 23 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 03 pc: 0270 sp: FD x: 23 y: 03 
---
[1]    64 0272: 	rts
[2] a: 15 p: 03 pc: 0272 sp: FD x: 23 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 15 p: 03 pc: 0220 sp: FF x: 23 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 23 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 23 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 23 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 23 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 23 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 23 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 23 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 97 p: 81 pc: 0216 sp: FF x: 23 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 97 p: 81 pc: 0218 sp: FF x: 23 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 23 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 23 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 23 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 23 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 23 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 23 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 23 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 23 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 23 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 23 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 23 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 23 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 23 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 23 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 23 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 23 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 23 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 23 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 23 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 23 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 23 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 23 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 23 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 23 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 23 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 23 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 23 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 23 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 23 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 97 p: 80 pc: 025B sp: FD x: 23 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 97 p: 81 pc: 025D sp: FD x: 23 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 97 p: 81 pc: 026C sp: FD x: 23 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 97 p: 00 pc: 026E sp: FD x: 23 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 97 p: 00 pc: 0270 sp: FD x: 23 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 97 p: 00 pc: 0259 sp: FD x: 23 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 97 p: 80 pc: 025B sp: FD x: 23 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 97 p: 00 pc: 025D sp: FD x: 23 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 97 p: 00 pc: 025F sp: FD x: 23 y: 04 
---
[1]    55 0261: 	sec
[2] a: 97 p: 80 pc: 0261 sp: FD x: 23 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 97 p: 81 pc: 0262 sp: FD x: 23 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 3F p: 00 pc: 0264 sp: FD x: 23 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 3F p: 00 pc: 0266 sp: FD x: 23 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 23 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 23 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 23 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 23 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 23 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 23 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3F p: 00 pc: 025B sp: FD x: 23 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3F p: 00 pc: 025D sp: FD x: 23 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 3F p: 00 pc: 025F sp: FD x: 23 y: 04 
---
[1]    55 0261: 	sec
[2] a: 3F p: 00 pc: 0261 sp: FD x: 23 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3F p: 01 pc: 0262 sp: FD x: 23 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 23 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 23 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 23 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 23 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 23 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 23 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 23 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 23 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 23 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 23 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 23 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 23 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 23 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 23 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 23 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 23 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 23 y: 04 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 23 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 23 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 08 p: 00 pc: 0264 sp: FD x: 23 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 08 p: 00 pc: 0266 sp: FD x: 23 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 23 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 23 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 23 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 23 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 23 y: 04 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 23 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 23 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 08 p: 01 pc: 0222 sp: FF x: 23 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 08 p: 01 pc: 0224 sp: FF x: 23 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 23 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 23 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 23 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 23 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 23 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: 97 p: 81 pc: 0216 sp: FF x: 23 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: 97 p: 81 pc: 0218 sp: FF x: 23 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 23 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 23 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 23 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 23 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 23 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 23 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 23 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 23 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 23 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 23 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 23 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 23 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 23 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 23 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 23 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 23 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 23 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 23 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 23 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 23 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 23 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 23 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 23 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 23 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 23 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 23 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 23 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 23 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 23 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 97 p: 80 pc: 025B sp: FD x: 23 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 97 p: 81 pc: 025D sp: FD x: 23 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 97 p: 81 pc: 026C sp: FD x: 23 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 97 p: 00 pc: 026E sp: FD x: 23 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 97 p: 00 pc: 0270 sp: FD x: 23 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 97 p: 00 pc: 0259 sp: FD x: 23 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 97 p: 80 pc: 025B sp: FD x: 23 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 97 p: 00 pc: 025D sp: FD x: 23 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 97 p: 00 pc: 025F sp: FD x: 23 y: 05 
---
[1]    55 0261: 	sec
[2] a: 97 p: 80 pc: 0261 sp: FD x: 23 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 97 p: 81 pc: 0262 sp: FD x: 23 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 2F p: 00 pc: 0264 sp: FD x: 23 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 2F p: 00 pc: 0266 sp: FD x: 23 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 23 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 23 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 23 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 23 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 23 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 23 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 23 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 81 pc: 025D sp: FD x: 23 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2F p: 81 pc: 026C sp: FD x: 23 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 2F p: 00 pc: 026E sp: FD x: 23 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2F p: 00 pc: 0270 sp: FD x: 23 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2F p: 00 pc: 0259 sp: FD x: 23 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 23 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 00 pc: 025D sp: FD x: 23 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 2F p: 00 pc: 025F sp: FD x: 23 y: 05 
---
[1]    55 0261: 	sec
[2] a: 2F p: 00 pc: 0261 sp: FD x: 23 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2F p: 01 pc: 0262 sp: FD x: 23 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 23 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 23 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 23 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 23 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 23 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 23 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 23 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 23 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 23 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 23 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 23 y: 05 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 23 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 23 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 08 p: 00 pc: 0264 sp: FD x: 23 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 08 p: 00 pc: 0266 sp: FD x: 23 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 23 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 23 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 23 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 23 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 23 y: 05 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 23 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 23 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 08 p: 01 pc: 0222 sp: FF x: 23 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 08 p: 01 pc: 0224 sp: FF x: 23 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 23 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 00 pc: 0229 sp: FF x: 23 y: 05 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0D p: 00 pc: 022E sp: FF x: 23 y: 05 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 97 p: 80 pc: 0231 sp: FF x: 23 y: 05 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 97 p: 00 pc: 0232 sp: FF x: 24 y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 97 p: 00 pc: 0235 sp: FF x: 24 y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 97 p: 80 pc: 0238 sp: FF x: 24 y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: 97 p: 80 pc: 023B sp: FF x: 24 y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 99 p: 80 pc: 023E sp: FF x: 24 y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: 99 p: 81 pc: 0240 sp: FF x: 24 y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 99 p: 81 pc: 0211 sp: FF x: 24 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 99 p: 01 pc: 0213 sp: FF x: 24 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 99 p: 81 pc: 0216 sp: FF x: 24 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 99 p: 81 pc: 0218 sp: FF x: 24 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 24 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 24 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 24 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 24 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 24 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 24 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 99 p: 80 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 99 p: 81 pc: 025D sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 99 p: 81 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 99 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 99 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 99 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 99 p: 80 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 99 p: 00 pc: 025D sp: FD x: 24 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 99 p: 00 pc: 025F sp: FD x: 24 y: 01 
---
[1]    55 0261: 	sec
[2] a: 99 p: 80 pc: 0261 sp: FD x: 24 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 99 p: 81 pc: 0262 sp: FD x: 24 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 39 p: 00 pc: 0264 sp: FD x: 24 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 39 p: 00 pc: 0266 sp: FD x: 24 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 24 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 00 pc: 025D sp: FD x: 24 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 39 p: 00 pc: 025F sp: FD x: 24 y: 01 
---
[1]    55 0261: 	sec
[2] a: 39 p: 00 pc: 0261 sp: FD x: 24 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 39 p: 01 pc: 0262 sp: FD x: 24 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 24 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 24 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 24 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 24 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 24 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 24 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 24 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 24 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 24 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 24 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 32 p: 00 pc: 026A sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 32 p: 00 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 32 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 32 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 32 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 24 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 24 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 24 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 24 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 24 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 24 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 32 p: 00 pc: 0268 sp: FD x: 24 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 33 p: 00 pc: 026A sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 33 p: 00 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 33 p: 01 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 33 p: 03 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    64 0272: 	rts
[2] a: 33 p: 03 pc: 0272 sp: FD x: 24 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 33 p: 03 pc: 0220 sp: FF x: 24 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 24 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 24 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 24 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 24 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 9B p: 81 pc: 023E sp: FF x: 24 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: 9B p: 81 pc: 0240 sp: FF x: 24 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 9B p: 81 pc: 0211 sp: FF x: 24 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 9B p: 01 pc: 0213 sp: FF x: 24 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 9B p: 81 pc: 0216 sp: FF x: 24 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 9B p: 81 pc: 0218 sp: FF x: 24 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 24 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 24 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 24 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 24 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 24 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 24 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9B p: 80 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9B p: 81 pc: 025D sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 9B p: 81 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 9B p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 9B p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 9B p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9B p: 80 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9B p: 00 pc: 025D sp: FD x: 24 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 9B p: 00 pc: 025F sp: FD x: 24 y: 01 
---
[1]    55 0261: 	sec
[2] a: 9B p: 80 pc: 0261 sp: FD x: 24 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 9B p: 81 pc: 0262 sp: FD x: 24 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 3B p: 00 pc: 0264 sp: FD x: 24 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 3B p: 00 pc: 0266 sp: FD x: 24 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 24 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 00 pc: 025D sp: FD x: 24 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 3B p: 00 pc: 025F sp: FD x: 24 y: 01 
---
[1]    55 0261: 	sec
[2] a: 3B p: 00 pc: 0261 sp: FD x: 24 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3B p: 01 pc: 0262 sp: FD x: 24 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 24 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 24 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 24 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 24 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 24 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 24 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 24 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 24 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 24 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 24 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 32 p: 00 pc: 026A sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 32 p: 00 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 32 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 32 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 32 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 24 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 24 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 24 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 24 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 24 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 24 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 32 p: 00 pc: 0268 sp: FD x: 24 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 33 p: 00 pc: 026A sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 33 p: 00 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 33 p: 01 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 33 p: 03 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    64 0272: 	rts
[2] a: 33 p: 03 pc: 0272 sp: FD x: 24 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 33 p: 03 pc: 0220 sp: FF x: 24 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 24 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 24 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 24 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 24 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 24 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 24 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 24 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 9B p: 81 pc: 0216 sp: FF x: 24 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 9B p: 81 pc: 0218 sp: FF x: 24 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 24 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 24 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 24 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 24 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 24 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 24 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 24 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 24 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 24 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 24 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 24 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 24 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 24 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 24 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 24 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 24 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 24 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 24 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 24 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 24 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 24 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 24 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 24 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 24 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 24 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 24 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 24 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 24 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 24 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 24 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 24 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 24 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 24 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 24 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9B p: 80 pc: 025B sp: FD x: 24 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9B p: 81 pc: 025D sp: FD x: 24 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 9B p: 81 pc: 026C sp: FD x: 24 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 9B p: 00 pc: 026E sp: FD x: 24 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 9B p: 00 pc: 0270 sp: FD x: 24 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 9B p: 00 pc: 0259 sp: FD x: 24 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9B p: 80 pc: 025B sp: FD x: 24 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9B p: 00 pc: 025D sp: FD x: 24 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 9B p: 00 pc: 025F sp: FD x: 24 y: 02 
---
[1]    55 0261: 	sec
[2] a: 9B p: 80 pc: 0261 sp: FD x: 24 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 9B p: 81 pc: 0262 sp: FD x: 24 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 4B p: 40 pc: 0264 sp: FD x: 24 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 4B p: 40 pc: 0266 sp: FD x: 24 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 24 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 24 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 24 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 24 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 24 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 24 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4B p: 40 pc: 025B sp: FD x: 24 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4B p: 40 pc: 025D sp: FD x: 24 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 4B p: 40 pc: 025F sp: FD x: 24 y: 02 
---
[1]    55 0261: 	sec
[2] a: 4B p: 40 pc: 0261 sp: FD x: 24 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4B p: 41 pc: 0262 sp: FD x: 24 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 24 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 24 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 24 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 24 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 24 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 24 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 24 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 24 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 24 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 24 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 24 y: 02 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 24 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 24 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 24 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 24 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 24 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 24 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 24 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 24 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 24 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 24 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 24 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 24 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 24 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 24 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 24 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 24 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 24 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 24 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1E p: 00 pc: 026A sp: FD x: 24 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1E p: 00 pc: 026C sp: FD x: 24 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1E p: 00 pc: 026E sp: FD x: 24 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1E p: 00 pc: 0270 sp: FD x: 24 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1E p: 00 pc: 0259 sp: FD x: 24 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 24 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 24 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 24 y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 24 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 24 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 24 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 24 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1E p: 00 pc: 0268 sp: FD x: 24 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1F p: 00 pc: 026A sp: FD x: 24 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 00 pc: 026C sp: FD x: 24 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 01 pc: 026E sp: FD x: 24 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 03 pc: 0270 sp: FD x: 24 y: 02 
---
[1]    64 0272: 	rts
[2] a: 1F p: 03 pc: 0272 sp: FD x: 24 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1F p: 03 pc: 0220 sp: FF x: 24 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 24 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 24 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 24 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 24 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 9D p: 81 pc: 023E sp: FF x: 24 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: 9D p: 81 pc: 0240 sp: FF x: 24 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 9D p: 81 pc: 0211 sp: FF x: 24 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 9D p: 01 pc: 0213 sp: FF x: 24 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 9D p: 81 pc: 0216 sp: FF x: 24 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 9D p: 81 pc: 0218 sp: FF x: 24 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 24 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 24 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 24 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 24 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 24 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 24 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 24 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 24 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 24 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 24 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 24 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9D p: 80 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9D p: 81 pc: 025D sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 9D p: 81 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 9D p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 9D p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 9D p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9D p: 80 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9D p: 00 pc: 025D sp: FD x: 24 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 9D p: 00 pc: 025F sp: FD x: 24 y: 01 
---
[1]    55 0261: 	sec
[2] a: 9D p: 80 pc: 0261 sp: FD x: 24 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 9D p: 81 pc: 0262 sp: FD x: 24 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 3D p: 00 pc: 0264 sp: FD x: 24 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 3D p: 00 pc: 0266 sp: FD x: 24 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 24 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 00 pc: 025D sp: FD x: 24 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 3D p: 00 pc: 025F sp: FD x: 24 y: 01 
---
[1]    55 0261: 	sec
[2] a: 3D p: 00 pc: 0261 sp: FD x: 24 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3D p: 01 pc: 0262 sp: FD x: 24 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 24 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 24 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 24 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 24 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 24 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 24 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 24 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 24 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 24 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 24 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 34 p: 00 pc: 026A sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 34 p: 00 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 34 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 34 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 34 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 24 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 24 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 24 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 24 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 24 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 24 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 24 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 24 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 24 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 24 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 24 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 24 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 24 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 24 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 24 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: 9D p: 81 pc: 0216 sp: FF x: 24 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: 9D p: 81 pc: 0218 sp: FF x: 24 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 24 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 24 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 24 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 24 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 24 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 24 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 24 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 24 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 24 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 24 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 24 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 24 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 24 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 24 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 24 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 24 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 24 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 24 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 24 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 24 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 24 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 24 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 24 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 24 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 24 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 24 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 24 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 24 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 24 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 24 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 24 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 24 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 24 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 24 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9D p: 80 pc: 025B sp: FD x: 24 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9D p: 81 pc: 025D sp: FD x: 24 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 9D p: 81 pc: 026C sp: FD x: 24 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 9D p: 00 pc: 026E sp: FD x: 24 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 9D p: 00 pc: 0270 sp: FD x: 24 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 9D p: 00 pc: 0259 sp: FD x: 24 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9D p: 80 pc: 025B sp: FD x: 24 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9D p: 00 pc: 025D sp: FD x: 24 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 9D p: 00 pc: 025F sp: FD x: 24 y: 02 
---
[1]    55 0261: 	sec
[2] a: 9D p: 80 pc: 0261 sp: FD x: 24 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 9D p: 81 pc: 0262 sp: FD x: 24 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 4D p: 40 pc: 0264 sp: FD x: 24 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 4D p: 40 pc: 0266 sp: FD x: 24 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 24 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 24 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 24 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 24 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 24 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 24 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4D p: 40 pc: 025B sp: FD x: 24 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4D p: 40 pc: 025D sp: FD x: 24 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 4D p: 40 pc: 025F sp: FD x: 24 y: 02 
---
[1]    55 0261: 	sec
[2] a: 4D p: 40 pc: 0261 sp: FD x: 24 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4D p: 41 pc: 0262 sp: FD x: 24 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 25 p: 00 pc: 0264 sp: FD x: 24 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 25 p: 00 pc: 0266 sp: FD x: 24 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 24 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 24 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 24 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 24 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 24 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 24 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 24 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 24 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 24 y: 02 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 24 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 24 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 24 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 24 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 24 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 24 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 24 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 24 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 24 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 24 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 24 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 24 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 24 y: 02 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 24 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 24 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 24 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 24 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 24 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1E p: 00 pc: 026A sp: FD x: 24 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1E p: 00 pc: 026C sp: FD x: 24 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1E p: 00 pc: 026E sp: FD x: 24 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1E p: 00 pc: 0270 sp: FD x: 24 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1E p: 00 pc: 0259 sp: FD x: 24 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 24 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 24 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 24 y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 24 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 24 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 24 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 24 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1E p: 00 pc: 0268 sp: FD x: 24 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1F p: 00 pc: 026A sp: FD x: 24 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 00 pc: 026C sp: FD x: 24 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 01 pc: 026E sp: FD x: 24 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 03 pc: 0270 sp: FD x: 24 y: 02 
---
[1]    64 0272: 	rts
[2] a: 1F p: 03 pc: 0272 sp: FD x: 24 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1F p: 03 pc: 0220 sp: FF x: 24 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 24 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 24 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 24 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 24 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 24 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 24 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 24 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: 9D p: 81 pc: 0216 sp: FF x: 24 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: 9D p: 81 pc: 0218 sp: FF x: 24 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 24 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 24 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 24 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 24 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 24 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 24 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 24 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 24 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 24 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 24 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 24 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 24 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 24 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 24 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 24 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 24 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 24 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 24 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 24 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 24 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 24 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 24 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 24 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 24 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 24 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 24 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 24 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 24 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 24 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 24 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 24 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 24 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 24 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 24 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9D p: 80 pc: 025B sp: FD x: 24 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9D p: 81 pc: 025D sp: FD x: 24 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 9D p: 81 pc: 026C sp: FD x: 24 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 9D p: 00 pc: 026E sp: FD x: 24 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 9D p: 00 pc: 0270 sp: FD x: 24 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 9D p: 00 pc: 0259 sp: FD x: 24 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9D p: 80 pc: 025B sp: FD x: 24 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9D p: 00 pc: 025D sp: FD x: 24 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 9D p: 00 pc: 025F sp: FD x: 24 y: 03 
---
[1]    55 0261: 	sec
[2] a: 9D p: 80 pc: 0261 sp: FD x: 24 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 9D p: 81 pc: 0262 sp: FD x: 24 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 2D p: 00 pc: 0264 sp: FD x: 24 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 2D p: 00 pc: 0266 sp: FD x: 24 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 24 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 24 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 24 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 24 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 24 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 24 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 24 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 81 pc: 025D sp: FD x: 24 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2D p: 81 pc: 026C sp: FD x: 24 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 2D p: 00 pc: 026E sp: FD x: 24 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2D p: 00 pc: 0270 sp: FD x: 24 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2D p: 00 pc: 0259 sp: FD x: 24 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 24 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 00 pc: 025D sp: FD x: 24 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 2D p: 00 pc: 025F sp: FD x: 24 y: 03 
---
[1]    55 0261: 	sec
[2] a: 2D p: 00 pc: 0261 sp: FD x: 24 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2D p: 01 pc: 0262 sp: FD x: 24 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 24 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 24 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 24 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 24 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 24 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 24 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 24 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 24 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 24 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 24 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 24 y: 03 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 24 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 24 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 24 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 24 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 24 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 24 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 24 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 24 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 24 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 24 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 24 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 24 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 24 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 24 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 24 y: 03 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 24 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 24 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 24 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 24 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 24 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 24 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 24 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 24 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 24 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: 9D p: 81 pc: 0216 sp: FF x: 24 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: 9D p: 81 pc: 0218 sp: FF x: 24 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 24 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 24 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 24 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 24 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 24 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 24 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 24 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 24 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 24 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 24 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 24 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 24 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 24 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 24 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 24 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 24 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 24 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 24 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 24 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 24 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 24 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 24 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 24 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 24 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 24 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 24 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 24 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 24 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 24 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9D p: 80 pc: 025B sp: FD x: 24 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9D p: 81 pc: 025D sp: FD x: 24 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 9D p: 81 pc: 026C sp: FD x: 24 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 9D p: 00 pc: 026E sp: FD x: 24 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 9D p: 00 pc: 0270 sp: FD x: 24 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 9D p: 00 pc: 0259 sp: FD x: 24 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9D p: 80 pc: 025B sp: FD x: 24 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9D p: 00 pc: 025D sp: FD x: 24 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 9D p: 00 pc: 025F sp: FD x: 24 y: 04 
---
[1]    55 0261: 	sec
[2] a: 9D p: 80 pc: 0261 sp: FD x: 24 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 9D p: 81 pc: 0262 sp: FD x: 24 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 45 p: 40 pc: 0264 sp: FD x: 24 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 45 p: 40 pc: 0266 sp: FD x: 24 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 24 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 24 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 24 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 24 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 24 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 24 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 45 p: 40 pc: 025B sp: FD x: 24 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 45 p: 40 pc: 025D sp: FD x: 24 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 45 p: 40 pc: 025F sp: FD x: 24 y: 04 
---
[1]    55 0261: 	sec
[2] a: 45 p: 40 pc: 0261 sp: FD x: 24 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 45 p: 41 pc: 0262 sp: FD x: 24 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 24 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 24 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 24 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 24 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 24 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 24 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 24 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 24 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 24 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 24 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 24 y: 04 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 24 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 24 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 24 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 24 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 24 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 24 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 24 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 24 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 24 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 24 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 24 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 24 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 24 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 24 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 24 y: 04 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 24 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 24 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 24 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 24 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 24 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 24 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 24 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 24 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 24 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: 9D p: 81 pc: 0216 sp: FF x: 24 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: 9D p: 81 pc: 0218 sp: FF x: 24 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 24 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 24 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 24 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 24 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 24 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 24 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 24 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 24 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 24 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 24 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 24 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 24 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 24 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 24 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 24 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 24 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 24 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 24 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 24 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 24 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 24 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 24 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 24 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 24 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 24 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 24 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 24 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 24 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 24 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9D p: 80 pc: 025B sp: FD x: 24 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9D p: 81 pc: 025D sp: FD x: 24 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 9D p: 81 pc: 026C sp: FD x: 24 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 9D p: 00 pc: 026E sp: FD x: 24 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 9D p: 00 pc: 0270 sp: FD x: 24 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 9D p: 00 pc: 0259 sp: FD x: 24 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9D p: 80 pc: 025B sp: FD x: 24 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9D p: 00 pc: 025D sp: FD x: 24 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 9D p: 00 pc: 025F sp: FD x: 24 y: 05 
---
[1]    55 0261: 	sec
[2] a: 9D p: 80 pc: 0261 sp: FD x: 24 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 9D p: 81 pc: 0262 sp: FD x: 24 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 35 p: 00 pc: 0264 sp: FD x: 24 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 35 p: 00 pc: 0266 sp: FD x: 24 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 24 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 24 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 24 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 24 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 24 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 24 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 24 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 00 pc: 025D sp: FD x: 24 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 35 p: 00 pc: 025F sp: FD x: 24 y: 05 
---
[1]    55 0261: 	sec
[2] a: 35 p: 00 pc: 0261 sp: FD x: 24 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 35 p: 01 pc: 0262 sp: FD x: 24 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 24 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 24 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 24 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 24 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 24 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 24 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 24 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 24 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 24 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 24 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 24 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 24 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 24 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 24 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 24 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 24 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 24 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 24 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 24 y: 05 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 24 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 24 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 24 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 24 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 24 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 00 pc: 0229 sp: FF x: 24 y: 05 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0D p: 00 pc: 022E sp: FF x: 24 y: 05 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: 9D p: 80 pc: 0231 sp: FF x: 24 y: 05 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: 9D p: 00 pc: 0232 sp: FF x: 25 y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 9D p: 00 pc: 0235 sp: FF x: 25 y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 9D p: 80 pc: 0238 sp: FF x: 25 y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: 9D p: 80 pc: 023B sp: FF x: 25 y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: 9F p: 80 pc: 023E sp: FF x: 25 y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: 9F p: 81 pc: 0240 sp: FF x: 25 y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: 9F p: 81 pc: 0211 sp: FF x: 25 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 9F p: 01 pc: 0213 sp: FF x: 25 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: 9F p: 81 pc: 0216 sp: FF x: 25 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: 9F p: 81 pc: 0218 sp: FF x: 25 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 25 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 25 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 25 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 25 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 25 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 25 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9F p: 80 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9F p: 81 pc: 025D sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 9F p: 81 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 9F p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 9F p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 9F p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 9F p: 80 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 9F p: 00 pc: 025D sp: FD x: 25 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 9F p: 00 pc: 025F sp: FD x: 25 y: 01 
---
[1]    55 0261: 	sec
[2] a: 9F p: 80 pc: 0261 sp: FD x: 25 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 9F p: 81 pc: 0262 sp: FD x: 25 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 3F p: 00 pc: 0264 sp: FD x: 25 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 3F p: 00 pc: 0266 sp: FD x: 25 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 25 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3F p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3F p: 00 pc: 025D sp: FD x: 25 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 3F p: 00 pc: 025F sp: FD x: 25 y: 01 
---
[1]    55 0261: 	sec
[2] a: 3F p: 00 pc: 0261 sp: FD x: 25 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3F p: 01 pc: 0262 sp: FD x: 25 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 25 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 25 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 25 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 25 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 25 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 25 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 25 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 25 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 25 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 25 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 34 p: 00 pc: 026A sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 34 p: 00 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 34 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 34 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 34 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 25 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 25 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 25 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 25 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 25 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 25 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 34 p: 00 pc: 0268 sp: FD x: 25 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 35 p: 00 pc: 026A sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 35 p: 00 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 35 p: 01 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 35 p: 03 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    64 0272: 	rts
[2] a: 35 p: 03 pc: 0272 sp: FD x: 25 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 35 p: 03 pc: 0220 sp: FF x: 25 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 25 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 25 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 25 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 25 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: A1 p: 81 pc: 023E sp: FF x: 25 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: A1 p: 81 pc: 0240 sp: FF x: 25 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: A1 p: 81 pc: 0211 sp: FF x: 25 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: A1 p: 01 pc: 0213 sp: FF x: 25 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: A1 p: 81 pc: 0216 sp: FF x: 25 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: A1 p: 81 pc: 0218 sp: FF x: 25 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 25 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 25 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 25 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 25 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 25 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 25 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A1 p: 80 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A1 p: 81 pc: 025D sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A1 p: 81 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: A1 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A1 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: A1 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A1 p: 80 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A1 p: 00 pc: 025D sp: FD x: 25 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: A1 p: 00 pc: 025F sp: FD x: 25 y: 01 
---
[1]    55 0261: 	sec
[2] a: A1 p: 80 pc: 0261 sp: FD x: 25 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A1 p: 81 pc: 0262 sp: FD x: 25 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 41 p: 40 pc: 0264 sp: FD x: 25 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 41 p: 40 pc: 0266 sp: FD x: 25 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 25 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 41 p: 40 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 41 p: 40 pc: 025D sp: FD x: 25 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 41 p: 40 pc: 025F sp: FD x: 25 y: 01 
---
[1]    55 0261: 	sec
[2] a: 41 p: 40 pc: 0261 sp: FD x: 25 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 41 p: 41 pc: 0262 sp: FD x: 25 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 25 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 25 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 25 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 25 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 25 y: 01 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 25 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 25 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 25 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 25 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 25 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 34 p: 00 pc: 026A sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 34 p: 00 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 34 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 34 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 34 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 25 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 25 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 25 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 25 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 25 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 25 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 34 p: 00 pc: 0268 sp: FD x: 25 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 35 p: 00 pc: 026A sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 35 p: 00 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 35 p: 01 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 35 p: 03 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    64 0272: 	rts
[2] a: 35 p: 03 pc: 0272 sp: FD x: 25 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 35 p: 03 pc: 0220 sp: FF x: 25 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 25 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 25 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 25 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 25 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 25 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 25 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 25 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: A1 p: 81 pc: 0216 sp: FF x: 25 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: A1 p: 81 pc: 0218 sp: FF x: 25 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 25 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 25 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 25 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 25 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 25 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 25 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 25 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 25 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 25 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 25 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 25 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 25 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 25 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 25 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 25 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 25 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 25 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 25 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 25 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 25 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 25 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 25 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 25 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 25 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 25 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 25 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 25 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 25 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 25 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 25 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 25 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 25 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 25 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 25 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A1 p: 80 pc: 025B sp: FD x: 25 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A1 p: 00 pc: 025D sp: FD x: 25 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: A1 p: 00 pc: 025F sp: FD x: 25 y: 02 
---
[1]    55 0261: 	sec
[2] a: A1 p: 80 pc: 0261 sp: FD x: 25 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A1 p: 81 pc: 0262 sp: FD x: 25 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 25 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 25 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 25 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 25 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 25 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 25 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 25 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 25 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 25 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 25 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 25 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 25 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 25 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 25 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 25 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 25 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 25 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 25 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 25 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 25 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 25 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 25 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 25 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 25 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 25 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 25 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 25 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 25 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 25 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 25 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 25 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 25 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 25 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 25 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 25 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 25 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 25 y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 25 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 25 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 25 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 25 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 25 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 25 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 25 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 25 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 25 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: A1 p: 81 pc: 0216 sp: FF x: 25 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: A1 p: 81 pc: 0218 sp: FF x: 25 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 25 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 25 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 25 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 25 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 25 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 25 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 25 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 25 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 25 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 25 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 25 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 25 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 25 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 25 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 25 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 25 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 25 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 25 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 25 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 25 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 25 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 25 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 25 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 25 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 25 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 25 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 25 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 25 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 25 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 25 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 25 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 25 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 25 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 25 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A1 p: 80 pc: 025B sp: FD x: 25 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A1 p: 81 pc: 025D sp: FD x: 25 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A1 p: 81 pc: 026C sp: FD x: 25 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: A1 p: 00 pc: 026E sp: FD x: 25 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A1 p: 00 pc: 0270 sp: FD x: 25 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: A1 p: 00 pc: 0259 sp: FD x: 25 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A1 p: 80 pc: 025B sp: FD x: 25 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A1 p: 00 pc: 025D sp: FD x: 25 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: A1 p: 00 pc: 025F sp: FD x: 25 y: 03 
---
[1]    55 0261: 	sec
[2] a: A1 p: 80 pc: 0261 sp: FD x: 25 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A1 p: 81 pc: 0262 sp: FD x: 25 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 31 p: 00 pc: 0264 sp: FD x: 25 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 31 p: 00 pc: 0266 sp: FD x: 25 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 25 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 25 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 25 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 25 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 25 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 25 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 25 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 81 pc: 025D sp: FD x: 25 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 31 p: 81 pc: 026C sp: FD x: 25 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 31 p: 00 pc: 026E sp: FD x: 25 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 31 p: 00 pc: 0270 sp: FD x: 25 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 31 p: 00 pc: 0259 sp: FD x: 25 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 25 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 00 pc: 025D sp: FD x: 25 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 31 p: 00 pc: 025F sp: FD x: 25 y: 03 
---
[1]    55 0261: 	sec
[2] a: 31 p: 00 pc: 0261 sp: FD x: 25 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 31 p: 01 pc: 0262 sp: FD x: 25 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 25 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 25 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 25 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 25 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 25 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 25 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 25 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 25 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 25 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 25 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 25 y: 03 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 25 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 25 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 25 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 25 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 25 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 25 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 25 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 25 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 25 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 25 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 25 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 02 pc: 025D sp: FD x: 25 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 02 pc: 025F sp: FD x: 25 y: 03 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 25 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 25 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 25 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 25 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 16 p: 00 pc: 0268 sp: FD x: 25 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 17 p: 00 pc: 026A sp: FD x: 25 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 00 pc: 026C sp: FD x: 25 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 01 pc: 026E sp: FD x: 25 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 03 pc: 0270 sp: FD x: 25 y: 03 
---
[1]    64 0272: 	rts
[2] a: 17 p: 03 pc: 0272 sp: FD x: 25 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 17 p: 03 pc: 0220 sp: FF x: 25 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 25 y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 25 y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 25 y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 25 y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: A3 p: 81 pc: 023E sp: FF x: 25 y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: A3 p: 81 pc: 0240 sp: FF x: 25 y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: A3 p: 81 pc: 0211 sp: FF x: 25 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: A3 p: 01 pc: 0213 sp: FF x: 25 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: A3 p: 81 pc: 0216 sp: FF x: 25 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: A3 p: 81 pc: 0218 sp: FF x: 25 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 25 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 25 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 25 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 25 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 25 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 25 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 25 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 25 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 25 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 25 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 25 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A3 p: 80 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A3 p: 81 pc: 025D sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A3 p: 81 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: A3 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A3 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: A3 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A3 p: 80 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A3 p: 00 pc: 025D sp: FD x: 25 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: A3 p: 00 pc: 025F sp: FD x: 25 y: 01 
---
[1]    55 0261: 	sec
[2] a: A3 p: 80 pc: 0261 sp: FD x: 25 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A3 p: 81 pc: 0262 sp: FD x: 25 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 43 p: 40 pc: 0264 sp: FD x: 25 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 43 p: 40 pc: 0266 sp: FD x: 25 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 25 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 43 p: 40 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 43 p: 40 pc: 025D sp: FD x: 25 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 43 p: 40 pc: 025F sp: FD x: 25 y: 01 
---
[1]    55 0261: 	sec
[2] a: 43 p: 40 pc: 0261 sp: FD x: 25 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 43 p: 41 pc: 0262 sp: FD x: 25 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 25 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 25 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 25 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 25 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 25 y: 01 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 25 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 25 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 25 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 25 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 25 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 34 p: 00 pc: 026A sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 34 p: 00 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 34 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 34 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 34 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 25 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 25 y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 25 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 25 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 25 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 25 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 34 p: 00 pc: 0268 sp: FD x: 25 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 36 p: 00 pc: 026A sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 36 p: 00 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 36 p: 00 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 36 p: 00 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 36 p: 00 pc: 0259 sp: FD x: 25 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 25 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 25 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 25 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 25 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 25 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 25 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 25 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 25 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 25 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 25 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 25 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 25 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 25 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 25 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: A3 p: 81 pc: 0216 sp: FF x: 25 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: A3 p: 81 pc: 0218 sp: FF x: 25 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 25 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 25 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 25 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 25 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 25 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 25 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 25 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 25 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 25 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 25 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 25 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 25 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 25 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 25 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 25 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 25 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 25 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 25 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 25 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 25 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 25 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 25 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 25 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 25 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 25 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 25 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 25 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 25 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 25 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 25 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 25 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 25 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 25 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 25 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A3 p: 80 pc: 025B sp: FD x: 25 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A3 p: 00 pc: 025D sp: FD x: 25 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: A3 p: 00 pc: 025F sp: FD x: 25 y: 02 
---
[1]    55 0261: 	sec
[2] a: A3 p: 80 pc: 0261 sp: FD x: 25 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A3 p: 81 pc: 0262 sp: FD x: 25 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 25 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 25 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 25 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 25 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 25 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 25 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 25 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 25 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 25 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 25 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 25 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 25 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 25 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 25 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 25 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 25 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 25 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 25 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 25 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 25 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 25 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 25 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 25 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 25 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 25 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 25 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 25 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 25 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 25 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 25 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 25 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 25 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 25 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 25 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 25 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 25 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 25 y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 25 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 25 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 25 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 25 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 25 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 25 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 25 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 25 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 25 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: A3 p: 81 pc: 0216 sp: FF x: 25 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: A3 p: 81 pc: 0218 sp: FF x: 25 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 25 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 25 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 25 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 25 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 25 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 25 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 25 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 25 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 25 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 25 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 25 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 25 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 25 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 25 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 25 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 25 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 25 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 25 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 25 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 25 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 25 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 25 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 25 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 25 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 25 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 25 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 25 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 25 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 25 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 25 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 25 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 25 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 25 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 25 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A3 p: 80 pc: 025B sp: FD x: 25 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A3 p: 81 pc: 025D sp: FD x: 25 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A3 p: 81 pc: 026C sp: FD x: 25 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: A3 p: 00 pc: 026E sp: FD x: 25 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A3 p: 00 pc: 0270 sp: FD x: 25 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: A3 p: 00 pc: 0259 sp: FD x: 25 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A3 p: 80 pc: 025B sp: FD x: 25 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A3 p: 00 pc: 025D sp: FD x: 25 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: A3 p: 00 pc: 025F sp: FD x: 25 y: 03 
---
[1]    55 0261: 	sec
[2] a: A3 p: 80 pc: 0261 sp: FD x: 25 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A3 p: 81 pc: 0262 sp: FD x: 25 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 33 p: 00 pc: 0264 sp: FD x: 25 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 33 p: 00 pc: 0266 sp: FD x: 25 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 25 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 25 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 25 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 25 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 25 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 25 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 25 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 81 pc: 025D sp: FD x: 25 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 33 p: 81 pc: 026C sp: FD x: 25 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 33 p: 00 pc: 026E sp: FD x: 25 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 33 p: 00 pc: 0270 sp: FD x: 25 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 33 p: 00 pc: 0259 sp: FD x: 25 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 25 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 00 pc: 025D sp: FD x: 25 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 33 p: 00 pc: 025F sp: FD x: 25 y: 03 
---
[1]    55 0261: 	sec
[2] a: 33 p: 00 pc: 0261 sp: FD x: 25 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 33 p: 01 pc: 0262 sp: FD x: 25 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 25 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 25 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 25 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 25 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 25 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 25 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 25 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 25 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 25 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 25 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 25 y: 03 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 25 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 25 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 25 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 25 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 25 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 25 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 25 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 25 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 25 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 25 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 25 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 25 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 25 y: 03 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 25 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 25 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 25 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 25 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 16 p: 00 pc: 0268 sp: FD x: 25 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 17 p: 00 pc: 026A sp: FD x: 25 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 00 pc: 026C sp: FD x: 25 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 01 pc: 026E sp: FD x: 25 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 03 pc: 0270 sp: FD x: 25 y: 03 
---
[1]    64 0272: 	rts
[2] a: 17 p: 03 pc: 0272 sp: FD x: 25 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 17 p: 03 pc: 0220 sp: FF x: 25 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 25 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 25 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 25 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 25 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 25 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 25 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 25 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: A3 p: 81 pc: 0216 sp: FF x: 25 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: A3 p: 81 pc: 0218 sp: FF x: 25 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 25 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 25 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 25 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 25 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 25 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 25 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 25 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 25 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 25 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 25 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 25 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 25 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 25 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 25 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 25 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 25 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 25 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 25 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 25 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 25 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 25 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 25 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 25 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 25 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 25 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 25 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 25 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 25 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 25 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A3 p: 80 pc: 025B sp: FD x: 25 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A3 p: 81 pc: 025D sp: FD x: 25 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A3 p: 81 pc: 026C sp: FD x: 25 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: A3 p: 00 pc: 026E sp: FD x: 25 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A3 p: 00 pc: 0270 sp: FD x: 25 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: A3 p: 00 pc: 0259 sp: FD x: 25 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A3 p: 80 pc: 025B sp: FD x: 25 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A3 p: 00 pc: 025D sp: FD x: 25 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: A3 p: 00 pc: 025F sp: FD x: 25 y: 04 
---
[1]    55 0261: 	sec
[2] a: A3 p: 80 pc: 0261 sp: FD x: 25 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A3 p: 81 pc: 0262 sp: FD x: 25 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 4B p: 40 pc: 0264 sp: FD x: 25 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 4B p: 40 pc: 0266 sp: FD x: 25 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 25 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 25 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 25 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 25 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 25 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 25 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4B p: 40 pc: 025B sp: FD x: 25 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4B p: 40 pc: 025D sp: FD x: 25 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 4B p: 40 pc: 025F sp: FD x: 25 y: 04 
---
[1]    55 0261: 	sec
[2] a: 4B p: 40 pc: 0261 sp: FD x: 25 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4B p: 41 pc: 0262 sp: FD x: 25 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 1F p: 00 pc: 0264 sp: FD x: 25 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 1F p: 00 pc: 0266 sp: FD x: 25 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 25 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 25 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 25 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 25 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 25 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 25 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 25 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 25 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 25 y: 04 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 25 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 25 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 25 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 25 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 25 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 25 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 25 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 25 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 25 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 25 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 25 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 25 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 25 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 25 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 25 y: 04 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 25 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 25 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 09 p: 01 pc: 0222 sp: FF x: 25 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 09 p: 01 pc: 0224 sp: FF x: 25 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 25 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 25 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 25 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 25 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 25 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: A3 p: 81 pc: 0216 sp: FF x: 25 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: A3 p: 81 pc: 0218 sp: FF x: 25 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 25 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 25 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 25 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 25 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 25 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 25 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 25 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 25 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 25 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 25 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 25 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 25 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 25 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 25 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 25 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 25 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 25 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 25 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 25 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 25 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 25 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 25 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 25 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 25 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 25 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 25 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 25 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 25 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 25 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A3 p: 80 pc: 025B sp: FD x: 25 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A3 p: 81 pc: 025D sp: FD x: 25 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A3 p: 81 pc: 026C sp: FD x: 25 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: A3 p: 00 pc: 026E sp: FD x: 25 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A3 p: 00 pc: 0270 sp: FD x: 25 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: A3 p: 00 pc: 0259 sp: FD x: 25 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A3 p: 80 pc: 025B sp: FD x: 25 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A3 p: 00 pc: 025D sp: FD x: 25 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: A3 p: 00 pc: 025F sp: FD x: 25 y: 05 
---
[1]    55 0261: 	sec
[2] a: A3 p: 80 pc: 0261 sp: FD x: 25 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A3 p: 81 pc: 0262 sp: FD x: 25 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 3B p: 00 pc: 0264 sp: FD x: 25 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 3B p: 00 pc: 0266 sp: FD x: 25 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 25 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 25 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 25 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 25 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 25 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 25 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 25 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 00 pc: 025D sp: FD x: 25 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 3B p: 00 pc: 025F sp: FD x: 25 y: 05 
---
[1]    55 0261: 	sec
[2] a: 3B p: 00 pc: 0261 sp: FD x: 25 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3B p: 01 pc: 0262 sp: FD x: 25 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 25 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 25 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 25 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 25 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 25 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 25 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 25 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 25 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 25 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 25 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 25 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 25 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 25 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 25 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 25 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 25 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 25 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 25 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 25 y: 05 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 25 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 25 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 07 p: 01 pc: 0222 sp: FF x: 25 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 07 p: 01 pc: 0224 sp: FF x: 25 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 25 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 00 pc: 0229 sp: FF x: 25 y: 05 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0D p: 00 pc: 022E sp: FF x: 25 y: 05 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: A3 p: 80 pc: 0231 sp: FF x: 25 y: 05 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: A3 p: 00 pc: 0232 sp: FF x: 26 y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: A3 p: 00 pc: 0235 sp: FF x: 26 y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: A3 p: 80 pc: 0238 sp: FF x: 26 y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: A3 p: 80 pc: 023B sp: FF x: 26 y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: A5 p: 80 pc: 023E sp: FF x: 26 y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: A5 p: 81 pc: 0240 sp: FF x: 26 y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: A5 p: 81 pc: 0211 sp: FF x: 26 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: A5 p: 01 pc: 0213 sp: FF x: 26 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: A5 p: 81 pc: 0216 sp: FF x: 26 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: A5 p: 81 pc: 0218 sp: FF x: 26 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 26 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 26 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 26 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 26 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 26 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 26 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 26 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 26 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 26 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 26 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 26 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 26 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 26 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 26 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 26 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 26 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 26 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 26 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 26 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 26 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 26 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 26 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 26 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 26 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 26 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 26 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 26 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 26 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 26 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 26 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 26 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 26 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 26 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 26 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 26 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 26 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 26 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A5 p: 80 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A5 p: 81 pc: 025D sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A5 p: 81 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: A5 p: 00 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A5 p: 00 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: A5 p: 00 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A5 p: 80 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A5 p: 00 pc: 025D sp: FD x: 26 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: A5 p: 00 pc: 025F sp: FD x: 26 y: 01 
---
[1]    55 0261: 	sec
[2] a: A5 p: 80 pc: 0261 sp: FD x: 26 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A5 p: 81 pc: 0262 sp: FD x: 26 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 45 p: 40 pc: 0264 sp: FD x: 26 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 45 p: 40 pc: 0266 sp: FD x: 26 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 26 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 45 p: 40 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 45 p: 40 pc: 025D sp: FD x: 26 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 45 p: 40 pc: 025F sp: FD x: 26 y: 01 
---
[1]    55 0261: 	sec
[2] a: 45 p: 40 pc: 0261 sp: FD x: 26 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 45 p: 41 pc: 0262 sp: FD x: 26 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 26 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 26 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 26 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 26 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 26 y: 01 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 26 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 26 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 26 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 26 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 26 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 34 p: 00 pc: 026A sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 34 p: 00 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 34 p: 00 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 34 p: 00 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 34 p: 00 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 26 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 26 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 26 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 26 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 26 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 26 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 34 p: 00 pc: 0268 sp: FD x: 26 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 36 p: 00 pc: 026A sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 36 p: 00 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 36 p: 00 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 36 p: 00 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 36 p: 00 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 26 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 26 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 26 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 26 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 26 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 26 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 36 p: 00 pc: 0268 sp: FD x: 26 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 37 p: 00 pc: 026A sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 37 p: 00 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 37 p: 01 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 37 p: 03 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    64 0272: 	rts
[2] a: 37 p: 03 pc: 0272 sp: FD x: 26 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 37 p: 03 pc: 0220 sp: FF x: 26 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 26 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 26 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 26 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 26 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: A7 p: 81 pc: 023E sp: FF x: 26 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: A7 p: 81 pc: 0240 sp: FF x: 26 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: A7 p: 81 pc: 0211 sp: FF x: 26 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: A7 p: 01 pc: 0213 sp: FF x: 26 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: A7 p: 81 pc: 0216 sp: FF x: 26 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: A7 p: 81 pc: 0218 sp: FF x: 26 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 26 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 26 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 26 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 26 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 26 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 26 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 26 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 26 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 26 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 26 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 26 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 26 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 26 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 26 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 26 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 26 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 26 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 26 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 26 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 26 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 26 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 26 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 26 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 26 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 26 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 26 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 26 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 26 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 26 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 26 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 26 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 26 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 26 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 26 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 26 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 26 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 26 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A7 p: 80 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A7 p: 81 pc: 025D sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A7 p: 81 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: A7 p: 00 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A7 p: 00 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: A7 p: 00 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A7 p: 80 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A7 p: 00 pc: 025D sp: FD x: 26 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: A7 p: 00 pc: 025F sp: FD x: 26 y: 01 
---
[1]    55 0261: 	sec
[2] a: A7 p: 80 pc: 0261 sp: FD x: 26 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A7 p: 81 pc: 0262 sp: FD x: 26 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 47 p: 40 pc: 0264 sp: FD x: 26 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 47 p: 40 pc: 0266 sp: FD x: 26 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 26 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 47 p: 40 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 47 p: 40 pc: 025D sp: FD x: 26 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 47 p: 40 pc: 025F sp: FD x: 26 y: 01 
---
[1]    55 0261: 	sec
[2] a: 47 p: 40 pc: 0261 sp: FD x: 26 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 47 p: 41 pc: 0262 sp: FD x: 26 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 26 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 26 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 26 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 26 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 26 y: 01 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 26 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 26 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 26 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 26 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 26 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 34 p: 00 pc: 026A sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 34 p: 00 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 34 p: 00 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 34 p: 00 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 34 p: 00 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 26 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 26 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 26 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 26 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 26 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 26 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 34 p: 00 pc: 0268 sp: FD x: 26 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 36 p: 00 pc: 026A sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 36 p: 00 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 36 p: 00 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 36 p: 00 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 36 p: 00 pc: 0259 sp: FD x: 26 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 26 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 26 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 26 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 26 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 26 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 26 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 26 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 36 p: 00 pc: 0268 sp: FD x: 26 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 37 p: 00 pc: 026A sp: FD x: 26 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 37 p: 00 pc: 026C sp: FD x: 26 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 37 p: 01 pc: 026E sp: FD x: 26 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 37 p: 03 pc: 0270 sp: FD x: 26 y: 01 
---
[1]    64 0272: 	rts
[2] a: 37 p: 03 pc: 0272 sp: FD x: 26 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 37 p: 03 pc: 0220 sp: FF x: 26 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 26 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 26 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 26 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 26 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 26 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 26 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 26 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: A7 p: 81 pc: 0216 sp: FF x: 26 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: A7 p: 81 pc: 0218 sp: FF x: 26 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 26 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 26 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 26 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 26 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 26 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 26 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 26 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 26 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 26 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 26 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 26 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 26 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 26 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 26 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 26 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 26 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 26 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 26 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 26 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 26 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 26 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 26 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 26 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 26 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 26 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 26 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 26 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 26 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 26 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 26 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 26 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 26 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 26 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 26 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A7 p: 80 pc: 025B sp: FD x: 26 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A7 p: 00 pc: 025D sp: FD x: 26 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: A7 p: 00 pc: 025F sp: FD x: 26 y: 02 
---
[1]    55 0261: 	sec
[2] a: A7 p: 80 pc: 0261 sp: FD x: 26 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A7 p: 81 pc: 0262 sp: FD x: 26 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 26 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 26 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 26 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 26 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 26 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 26 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 26 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 26 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 26 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 26 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 26 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 26 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 26 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 26 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 26 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 26 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 26 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 26 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 26 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 26 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 26 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 26 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 26 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 26 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 26 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 26 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 26 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 26 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 26 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 26 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 26 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 26 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 26 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 26 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 26 y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 26 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 26 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 26 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 26 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 26 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 21 p: 00 pc: 026A sp: FD x: 26 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 00 pc: 026C sp: FD x: 26 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 01 pc: 026E sp: FD x: 26 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 03 pc: 0270 sp: FD x: 26 y: 02 
---
[1]    64 0272: 	rts
[2] a: 21 p: 03 pc: 0272 sp: FD x: 26 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 21 p: 03 pc: 0220 sp: FF x: 26 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 26 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 26 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 26 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 26 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 26 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 26 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 26 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: A7 p: 81 pc: 0216 sp: FF x: 26 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: A7 p: 81 pc: 0218 sp: FF x: 26 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 26 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 26 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 26 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 26 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 26 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 26 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 26 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 26 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 26 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 26 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 26 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 26 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 26 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 26 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 26 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 26 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 26 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 26 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 26 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 26 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 26 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 26 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 26 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 26 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 26 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 26 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 26 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 26 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 26 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 26 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 26 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 26 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 26 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 26 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A7 p: 80 pc: 025B sp: FD x: 26 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A7 p: 81 pc: 025D sp: FD x: 26 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A7 p: 81 pc: 026C sp: FD x: 26 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: A7 p: 00 pc: 026E sp: FD x: 26 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A7 p: 00 pc: 0270 sp: FD x: 26 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: A7 p: 00 pc: 0259 sp: FD x: 26 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A7 p: 80 pc: 025B sp: FD x: 26 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A7 p: 00 pc: 025D sp: FD x: 26 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: A7 p: 00 pc: 025F sp: FD x: 26 y: 03 
---
[1]    55 0261: 	sec
[2] a: A7 p: 80 pc: 0261 sp: FD x: 26 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A7 p: 81 pc: 0262 sp: FD x: 26 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 37 p: 00 pc: 0264 sp: FD x: 26 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 37 p: 00 pc: 0266 sp: FD x: 26 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 26 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 26 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 26 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 26 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 26 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 26 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 26 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 81 pc: 025D sp: FD x: 26 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 37 p: 81 pc: 026C sp: FD x: 26 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 37 p: 00 pc: 026E sp: FD x: 26 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 37 p: 00 pc: 0270 sp: FD x: 26 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 37 p: 00 pc: 0259 sp: FD x: 26 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 26 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 00 pc: 025D sp: FD x: 26 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 37 p: 00 pc: 025F sp: FD x: 26 y: 03 
---
[1]    55 0261: 	sec
[2] a: 37 p: 00 pc: 0261 sp: FD x: 26 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 37 p: 01 pc: 0262 sp: FD x: 26 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 26 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 26 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 26 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 26 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 26 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 26 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 26 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 26 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 26 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 26 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 26 y: 03 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 26 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 26 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 26 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 26 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 26 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 26 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 26 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 26 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 26 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 26 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 26 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 26 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 26 y: 03 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 26 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 26 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 26 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 26 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 16 p: 00 pc: 0268 sp: FD x: 26 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 17 p: 00 pc: 026A sp: FD x: 26 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 00 pc: 026C sp: FD x: 26 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 01 pc: 026E sp: FD x: 26 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 03 pc: 0270 sp: FD x: 26 y: 03 
---
[1]    64 0272: 	rts
[2] a: 17 p: 03 pc: 0272 sp: FD x: 26 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 17 p: 03 pc: 0220 sp: FF x: 26 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 26 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 26 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 26 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 26 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 26 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 26 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 26 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: A7 p: 81 pc: 0216 sp: FF x: 26 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: A7 p: 81 pc: 0218 sp: FF x: 26 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 26 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 26 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 26 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 26 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 26 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 26 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 26 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 26 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 26 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 26 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 26 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 26 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 26 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 26 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 26 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 26 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 26 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 26 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 26 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 26 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 26 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 26 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 26 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 26 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 26 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 26 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 26 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 26 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 26 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A7 p: 80 pc: 025B sp: FD x: 26 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A7 p: 81 pc: 025D sp: FD x: 26 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A7 p: 81 pc: 026C sp: FD x: 26 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: A7 p: 00 pc: 026E sp: FD x: 26 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A7 p: 00 pc: 0270 sp: FD x: 26 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: A7 p: 00 pc: 0259 sp: FD x: 26 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A7 p: 80 pc: 025B sp: FD x: 26 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A7 p: 00 pc: 025D sp: FD x: 26 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: A7 p: 00 pc: 025F sp: FD x: 26 y: 04 
---
[1]    55 0261: 	sec
[2] a: A7 p: 80 pc: 0261 sp: FD x: 26 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A7 p: 81 pc: 0262 sp: FD x: 26 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 4F p: 40 pc: 0264 sp: FD x: 26 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 4F p: 40 pc: 0266 sp: FD x: 26 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 26 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 26 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 26 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 26 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 26 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 26 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 40 pc: 025B sp: FD x: 26 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: 40 pc: 025D sp: FD x: 26 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 4F p: 40 pc: 025F sp: FD x: 26 y: 04 
---
[1]    55 0261: 	sec
[2] a: 4F p: 40 pc: 0261 sp: FD x: 26 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4F p: 41 pc: 0262 sp: FD x: 26 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 26 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 26 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 26 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 26 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 26 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 26 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 26 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 26 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 26 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 26 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 26 y: 04 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 26 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 26 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 26 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 26 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 26 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 26 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 26 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 26 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 26 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 26 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 26 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 26 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 26 y: 04 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 26 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 26 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 26 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 26 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0E p: 00 pc: 0268 sp: FD x: 26 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0F p: 00 pc: 026A sp: FD x: 26 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 00 pc: 026C sp: FD x: 26 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 01 pc: 026E sp: FD x: 26 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 03 pc: 0270 sp: FD x: 26 y: 04 
---
[1]    64 0272: 	rts
[2] a: 0F p: 03 pc: 0272 sp: FD x: 26 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0F p: 03 pc: 0220 sp: FF x: 26 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 26 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 26 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 26 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 26 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 26 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 26 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 26 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: A7 p: 81 pc: 0216 sp: FF x: 26 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: A7 p: 81 pc: 0218 sp: FF x: 26 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 26 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 26 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 26 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 26 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 26 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 26 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 26 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 26 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 26 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 26 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 26 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 26 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 26 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 26 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 26 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 26 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 26 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 26 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 26 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 26 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 26 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 26 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 26 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 26 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 26 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 26 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 26 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 26 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 26 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A7 p: 80 pc: 025B sp: FD x: 26 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A7 p: 81 pc: 025D sp: FD x: 26 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A7 p: 81 pc: 026C sp: FD x: 26 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: A7 p: 00 pc: 026E sp: FD x: 26 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A7 p: 00 pc: 0270 sp: FD x: 26 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: A7 p: 00 pc: 0259 sp: FD x: 26 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A7 p: 80 pc: 025B sp: FD x: 26 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A7 p: 00 pc: 025D sp: FD x: 26 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: A7 p: 00 pc: 025F sp: FD x: 26 y: 05 
---
[1]    55 0261: 	sec
[2] a: A7 p: 80 pc: 0261 sp: FD x: 26 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A7 p: 81 pc: 0262 sp: FD x: 26 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 3F p: 00 pc: 0264 sp: FD x: 26 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 3F p: 00 pc: 0266 sp: FD x: 26 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 26 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 26 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 26 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 26 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 26 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 26 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3F p: 00 pc: 025B sp: FD x: 26 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3F p: 00 pc: 025D sp: FD x: 26 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 3F p: 00 pc: 025F sp: FD x: 26 y: 05 
---
[1]    55 0261: 	sec
[2] a: 3F p: 00 pc: 0261 sp: FD x: 26 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3F p: 01 pc: 0262 sp: FD x: 26 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 26 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 26 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 26 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 26 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 26 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 26 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 26 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 26 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 26 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 26 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 26 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 26 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 26 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 26 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 26 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 26 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 26 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 26 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 26 y: 05 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 26 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 26 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0B p: 01 pc: 0222 sp: FF x: 26 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0B p: 01 pc: 0224 sp: FF x: 26 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 26 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 00 pc: 0229 sp: FF x: 26 y: 05 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0D p: 00 pc: 022E sp: FF x: 26 y: 05 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: A7 p: 80 pc: 0231 sp: FF x: 26 y: 05 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: A7 p: 00 pc: 0232 sp: FF x: 27 y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: A7 p: 00 pc: 0235 sp: FF x: 27 y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: A7 p: 80 pc: 0238 sp: FF x: 27 y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: A7 p: 80 pc: 023B sp: FF x: 27 y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: A9 p: 80 pc: 023E sp: FF x: 27 y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: A9 p: 81 pc: 0240 sp: FF x: 27 y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: A9 p: 81 pc: 0211 sp: FF x: 27 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: A9 p: 01 pc: 0213 sp: FF x: 27 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: A9 p: 81 pc: 0216 sp: FF x: 27 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: A9 p: 81 pc: 0218 sp: FF x: 27 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 27 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 27 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 27 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 27 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 27 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 27 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A9 p: 80 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A9 p: 81 pc: 025D sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A9 p: 81 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: A9 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A9 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: A9 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A9 p: 80 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A9 p: 00 pc: 025D sp: FD x: 27 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: A9 p: 00 pc: 025F sp: FD x: 27 y: 01 
---
[1]    55 0261: 	sec
[2] a: A9 p: 80 pc: 0261 sp: FD x: 27 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A9 p: 81 pc: 0262 sp: FD x: 27 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 49 p: 40 pc: 0264 sp: FD x: 27 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 49 p: 40 pc: 0266 sp: FD x: 27 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 27 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 49 p: 40 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 49 p: 40 pc: 025D sp: FD x: 27 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 49 p: 40 pc: 025F sp: FD x: 27 y: 01 
---
[1]    55 0261: 	sec
[2] a: 49 p: 40 pc: 0261 sp: FD x: 27 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 49 p: 41 pc: 0262 sp: FD x: 27 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 27 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 27 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 27 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 27 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 27 y: 01 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 27 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 27 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 27 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 27 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 27 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 38 p: 00 pc: 026A sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 38 p: 00 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 38 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 38 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 27 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 27 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 27 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 27 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 27 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 27 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 27 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 27 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 27 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: A9 p: 81 pc: 0216 sp: FF x: 27 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: A9 p: 81 pc: 0218 sp: FF x: 27 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 27 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 27 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 27 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 27 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 27 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 27 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 27 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 27 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 27 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 27 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 27 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 27 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 27 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 27 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 27 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 27 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 27 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 27 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 27 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 27 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 27 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 27 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 27 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 27 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 27 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 27 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 27 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 27 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 27 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 27 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 27 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 27 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 27 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 27 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A9 p: 80 pc: 025B sp: FD x: 27 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A9 p: 00 pc: 025D sp: FD x: 27 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: A9 p: 00 pc: 025F sp: FD x: 27 y: 02 
---
[1]    55 0261: 	sec
[2] a: A9 p: 80 pc: 0261 sp: FD x: 27 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A9 p: 81 pc: 0262 sp: FD x: 27 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 27 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 27 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 27 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 27 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 27 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 27 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 27 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 27 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 27 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 27 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 27 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 27 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 27 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 27 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 27 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 27 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 27 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 27 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 27 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 27 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 27 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 27 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 27 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 27 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 27 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 27 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 27 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 27 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 27 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 27 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 27 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 27 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 27 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 27 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 27 y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 27 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 27 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 27 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 27 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 27 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 21 p: 00 pc: 026A sp: FD x: 27 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 00 pc: 026C sp: FD x: 27 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 01 pc: 026E sp: FD x: 27 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 03 pc: 0270 sp: FD x: 27 y: 02 
---
[1]    64 0272: 	rts
[2] a: 21 p: 03 pc: 0272 sp: FD x: 27 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 21 p: 03 pc: 0220 sp: FF x: 27 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 27 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 27 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 27 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 27 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 27 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 27 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 27 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: A9 p: 81 pc: 0216 sp: FF x: 27 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: A9 p: 81 pc: 0218 sp: FF x: 27 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 27 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 27 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 27 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 27 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 27 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 27 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 27 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 27 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 27 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 27 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 27 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 27 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 27 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 27 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 27 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 27 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 27 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 27 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 27 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 27 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 27 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 27 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 27 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 27 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 27 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 27 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 27 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 27 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 27 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 27 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 27 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 27 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 27 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 27 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A9 p: 80 pc: 025B sp: FD x: 27 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A9 p: 81 pc: 025D sp: FD x: 27 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A9 p: 81 pc: 026C sp: FD x: 27 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: A9 p: 00 pc: 026E sp: FD x: 27 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A9 p: 00 pc: 0270 sp: FD x: 27 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: A9 p: 00 pc: 0259 sp: FD x: 27 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A9 p: 80 pc: 025B sp: FD x: 27 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A9 p: 00 pc: 025D sp: FD x: 27 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: A9 p: 00 pc: 025F sp: FD x: 27 y: 03 
---
[1]    55 0261: 	sec
[2] a: A9 p: 80 pc: 0261 sp: FD x: 27 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A9 p: 81 pc: 0262 sp: FD x: 27 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 39 p: 00 pc: 0264 sp: FD x: 27 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 39 p: 00 pc: 0266 sp: FD x: 27 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 27 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 27 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 27 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 27 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 27 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 27 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 27 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 00 pc: 025D sp: FD x: 27 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 39 p: 00 pc: 025F sp: FD x: 27 y: 03 
---
[1]    55 0261: 	sec
[2] a: 39 p: 00 pc: 0261 sp: FD x: 27 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 39 p: 01 pc: 0262 sp: FD x: 27 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 27 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 27 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 27 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 27 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 27 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 27 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 27 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 27 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 27 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 27 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 27 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 27 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 27 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 27 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 27 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 27 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 27 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 27 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 27 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 27 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 27 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 27 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 27 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 27 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 27 y: 03 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 27 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 27 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 27 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 27 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 27 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 27 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 27 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 27 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 27 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: A9 p: 81 pc: 0216 sp: FF x: 27 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: A9 p: 81 pc: 0218 sp: FF x: 27 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 27 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 27 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 27 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 27 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 27 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 27 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 27 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 27 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 27 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 27 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 27 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 27 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 27 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 27 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 27 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 27 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 27 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 27 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 27 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 27 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 27 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 27 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 27 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 27 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 27 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 27 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 27 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 27 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 27 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A9 p: 80 pc: 025B sp: FD x: 27 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A9 p: 81 pc: 025D sp: FD x: 27 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A9 p: 81 pc: 026C sp: FD x: 27 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: A9 p: 00 pc: 026E sp: FD x: 27 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A9 p: 00 pc: 0270 sp: FD x: 27 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: A9 p: 00 pc: 0259 sp: FD x: 27 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A9 p: 80 pc: 025B sp: FD x: 27 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A9 p: 00 pc: 025D sp: FD x: 27 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: A9 p: 00 pc: 025F sp: FD x: 27 y: 04 
---
[1]    55 0261: 	sec
[2] a: A9 p: 80 pc: 0261 sp: FD x: 27 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A9 p: 81 pc: 0262 sp: FD x: 27 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 51 p: 40 pc: 0264 sp: FD x: 27 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 51 p: 40 pc: 0266 sp: FD x: 27 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 27 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 27 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 27 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 27 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 27 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 27 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 51 p: 40 pc: 025B sp: FD x: 27 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 51 p: 40 pc: 025D sp: FD x: 27 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 51 p: 40 pc: 025F sp: FD x: 27 y: 04 
---
[1]    55 0261: 	sec
[2] a: 51 p: 40 pc: 0261 sp: FD x: 27 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 51 p: 41 pc: 0262 sp: FD x: 27 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 25 p: 00 pc: 0264 sp: FD x: 27 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 25 p: 00 pc: 0266 sp: FD x: 27 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 27 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 27 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 27 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 27 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 27 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 27 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 27 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 27 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 27 y: 04 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 27 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 27 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 27 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 27 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 27 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 27 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 27 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 27 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 27 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 27 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 27 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 27 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 27 y: 04 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 27 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 27 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 27 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 27 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0E p: 00 pc: 0268 sp: FD x: 27 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0F p: 00 pc: 026A sp: FD x: 27 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 00 pc: 026C sp: FD x: 27 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 01 pc: 026E sp: FD x: 27 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 03 pc: 0270 sp: FD x: 27 y: 04 
---
[1]    64 0272: 	rts
[2] a: 0F p: 03 pc: 0272 sp: FD x: 27 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0F p: 03 pc: 0220 sp: FF x: 27 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 27 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 27 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 27 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 27 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 27 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 27 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 27 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: A9 p: 81 pc: 0216 sp: FF x: 27 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: A9 p: 81 pc: 0218 sp: FF x: 27 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 27 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 27 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 27 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 27 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 27 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 27 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 27 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 27 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 27 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 27 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 27 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 27 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 27 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 27 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 27 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 27 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 27 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 27 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 27 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 27 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 27 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 27 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 27 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 27 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 27 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 27 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 27 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 27 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 27 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A9 p: 80 pc: 025B sp: FD x: 27 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A9 p: 81 pc: 025D sp: FD x: 27 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: A9 p: 81 pc: 026C sp: FD x: 27 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: A9 p: 00 pc: 026E sp: FD x: 27 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: A9 p: 00 pc: 0270 sp: FD x: 27 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: A9 p: 00 pc: 0259 sp: FD x: 27 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: A9 p: 80 pc: 025B sp: FD x: 27 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: A9 p: 00 pc: 025D sp: FD x: 27 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: A9 p: 00 pc: 025F sp: FD x: 27 y: 05 
---
[1]    55 0261: 	sec
[2] a: A9 p: 80 pc: 0261 sp: FD x: 27 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: A9 p: 81 pc: 0262 sp: FD x: 27 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 41 p: 40 pc: 0264 sp: FD x: 27 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 41 p: 40 pc: 0266 sp: FD x: 27 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 27 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 27 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 27 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 27 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 27 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 27 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 41 p: 40 pc: 025B sp: FD x: 27 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 41 p: 40 pc: 025D sp: FD x: 27 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 41 p: 40 pc: 025F sp: FD x: 27 y: 05 
---
[1]    55 0261: 	sec
[2] a: 41 p: 40 pc: 0261 sp: FD x: 27 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 41 p: 41 pc: 0262 sp: FD x: 27 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 27 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 27 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 27 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 27 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 27 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 27 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 27 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 27 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 27 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 27 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 27 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 27 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 27 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 27 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 27 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 02 pc: 025D sp: FD x: 27 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 02 pc: 025F sp: FD x: 27 y: 05 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 27 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 27 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 27 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 27 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 27 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 27 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 27 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 27 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 27 y: 05 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 27 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 27 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 27 y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 27 y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 27 y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 27 y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: AB p: 81 pc: 023E sp: FF x: 27 y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: AB p: 81 pc: 0240 sp: FF x: 27 y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: AB p: 81 pc: 0211 sp: FF x: 27 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: AB p: 01 pc: 0213 sp: FF x: 27 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: AB p: 81 pc: 0216 sp: FF x: 27 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: AB p: 81 pc: 0218 sp: FF x: 27 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 27 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 27 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 27 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 27 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 27 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 27 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AB p: 80 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AB p: 81 pc: 025D sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: AB p: 81 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: AB p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: AB p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: AB p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AB p: 80 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AB p: 00 pc: 025D sp: FD x: 27 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: AB p: 00 pc: 025F sp: FD x: 27 y: 01 
---
[1]    55 0261: 	sec
[2] a: AB p: 80 pc: 0261 sp: FD x: 27 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: AB p: 81 pc: 0262 sp: FD x: 27 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 4B p: 40 pc: 0264 sp: FD x: 27 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 4B p: 40 pc: 0266 sp: FD x: 27 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 27 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4B p: 40 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4B p: 40 pc: 025D sp: FD x: 27 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 4B p: 40 pc: 025F sp: FD x: 27 y: 01 
---
[1]    55 0261: 	sec
[2] a: 4B p: 40 pc: 0261 sp: FD x: 27 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4B p: 41 pc: 0262 sp: FD x: 27 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 27 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 27 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 27 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 27 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 27 y: 01 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 27 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 27 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 27 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 27 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 27 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 38 p: 00 pc: 026A sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 38 p: 00 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 38 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 38 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 27 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 27 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 27 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 27 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 27 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 27 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 38 p: 00 pc: 0268 sp: FD x: 27 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 39 p: 00 pc: 026A sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 39 p: 00 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 39 p: 01 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 39 p: 03 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    64 0272: 	rts
[2] a: 39 p: 03 pc: 0272 sp: FD x: 27 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 39 p: 03 pc: 0220 sp: FF x: 27 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 27 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 27 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 27 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 27 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: AD p: 81 pc: 023E sp: FF x: 27 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: AD p: 81 pc: 0240 sp: FF x: 27 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: AD p: 81 pc: 0211 sp: FF x: 27 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: AD p: 01 pc: 0213 sp: FF x: 27 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: AD p: 81 pc: 0216 sp: FF x: 27 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: AD p: 81 pc: 0218 sp: FF x: 27 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 27 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 27 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 27 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 27 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 27 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 27 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 27 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 27 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 27 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 27 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 27 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AD p: 80 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AD p: 81 pc: 025D sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: AD p: 81 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: AD p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: AD p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: AD p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AD p: 80 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AD p: 00 pc: 025D sp: FD x: 27 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: AD p: 00 pc: 025F sp: FD x: 27 y: 01 
---
[1]    55 0261: 	sec
[2] a: AD p: 80 pc: 0261 sp: FD x: 27 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: AD p: 81 pc: 0262 sp: FD x: 27 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 4D p: 40 pc: 0264 sp: FD x: 27 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 4D p: 40 pc: 0266 sp: FD x: 27 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 27 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4D p: 40 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4D p: 40 pc: 025D sp: FD x: 27 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 4D p: 40 pc: 025F sp: FD x: 27 y: 01 
---
[1]    55 0261: 	sec
[2] a: 4D p: 40 pc: 0261 sp: FD x: 27 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4D p: 41 pc: 0262 sp: FD x: 27 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 1D p: 00 pc: 0264 sp: FD x: 27 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 1D p: 00 pc: 0266 sp: FD x: 27 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 27 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 27 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 27 y: 01 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 27 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 27 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 27 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 27 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 27 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 38 p: 00 pc: 026A sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 38 p: 00 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 38 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 38 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 27 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 27 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 27 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 27 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 27 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 27 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 27 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 27 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 38 p: 00 pc: 0268 sp: FD x: 27 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 39 p: 00 pc: 026A sp: FD x: 27 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 39 p: 00 pc: 026C sp: FD x: 27 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 39 p: 01 pc: 026E sp: FD x: 27 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 39 p: 03 pc: 0270 sp: FD x: 27 y: 01 
---
[1]    64 0272: 	rts
[2] a: 39 p: 03 pc: 0272 sp: FD x: 27 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 39 p: 03 pc: 0220 sp: FF x: 27 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 27 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 27 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 27 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 27 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 27 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 27 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 27 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: AD p: 81 pc: 0216 sp: FF x: 27 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: AD p: 81 pc: 0218 sp: FF x: 27 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 27 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 27 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 27 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 27 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 27 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 27 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 27 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 27 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 27 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 27 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 27 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 27 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 27 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 27 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 27 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 27 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 27 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 27 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 27 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 27 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 27 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 27 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 27 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 27 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 27 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 27 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 27 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 27 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 27 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 27 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 27 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 27 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 27 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 27 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AD p: 80 pc: 025B sp: FD x: 27 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AD p: 00 pc: 025D sp: FD x: 27 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: AD p: 00 pc: 025F sp: FD x: 27 y: 02 
---
[1]    55 0261: 	sec
[2] a: AD p: 80 pc: 0261 sp: FD x: 27 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: AD p: 81 pc: 0262 sp: FD x: 27 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 27 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 27 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 27 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 27 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 27 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 27 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 27 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 27 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 27 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 27 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 27 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 27 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 27 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 27 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 27 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 27 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 27 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 27 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 27 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 27 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 27 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 27 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 27 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 27 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 27 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 27 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 27 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 27 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 27 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 27 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 27 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 27 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 27 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 27 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 22 p: 00 pc: 026A sp: FD x: 27 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 22 p: 00 pc: 026C sp: FD x: 27 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 22 p: 00 pc: 026E sp: FD x: 27 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 22 p: 00 pc: 0270 sp: FD x: 27 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 22 p: 00 pc: 0259 sp: FD x: 27 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 27 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 27 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 27 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 27 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 27 y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 27 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 27 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 27 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 27 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 27 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 27 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 27 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 27 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 27 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: AD p: 81 pc: 0216 sp: FF x: 27 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: AD p: 81 pc: 0218 sp: FF x: 27 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 27 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 27 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 27 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 27 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 27 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 27 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 27 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 27 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 27 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 27 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 27 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 27 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 27 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 27 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 27 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 27 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 27 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 27 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 27 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 27 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 27 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 27 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 27 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 27 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 27 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 27 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 27 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 27 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 27 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 27 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 27 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 27 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 27 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 27 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AD p: 80 pc: 025B sp: FD x: 27 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AD p: 81 pc: 025D sp: FD x: 27 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: AD p: 81 pc: 026C sp: FD x: 27 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: AD p: 00 pc: 026E sp: FD x: 27 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: AD p: 00 pc: 0270 sp: FD x: 27 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: AD p: 00 pc: 0259 sp: FD x: 27 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AD p: 80 pc: 025B sp: FD x: 27 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AD p: 00 pc: 025D sp: FD x: 27 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: AD p: 00 pc: 025F sp: FD x: 27 y: 03 
---
[1]    55 0261: 	sec
[2] a: AD p: 80 pc: 0261 sp: FD x: 27 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: AD p: 81 pc: 0262 sp: FD x: 27 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 3D p: 00 pc: 0264 sp: FD x: 27 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 3D p: 00 pc: 0266 sp: FD x: 27 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 27 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 27 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 27 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 27 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 27 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 27 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 27 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 00 pc: 025D sp: FD x: 27 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 3D p: 00 pc: 025F sp: FD x: 27 y: 03 
---
[1]    55 0261: 	sec
[2] a: 3D p: 00 pc: 0261 sp: FD x: 27 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3D p: 01 pc: 0262 sp: FD x: 27 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 27 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 27 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 27 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 27 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 27 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 27 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 27 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 27 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 27 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 27 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 27 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 27 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 27 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 27 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 27 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 27 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 27 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 27 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 27 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 27 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 27 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 27 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 27 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 27 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 27 y: 03 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 27 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 27 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 27 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 27 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 27 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 27 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 27 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 27 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 27 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: AD p: 81 pc: 0216 sp: FF x: 27 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: AD p: 81 pc: 0218 sp: FF x: 27 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 27 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 27 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 27 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 27 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 27 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 27 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 27 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 27 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 27 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 27 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 27 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 27 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 27 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 27 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 27 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 27 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 27 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 27 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 27 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 27 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 27 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 27 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 27 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 27 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 27 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 27 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 27 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 27 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 27 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AD p: 80 pc: 025B sp: FD x: 27 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AD p: 81 pc: 025D sp: FD x: 27 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: AD p: 81 pc: 026C sp: FD x: 27 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: AD p: 00 pc: 026E sp: FD x: 27 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: AD p: 00 pc: 0270 sp: FD x: 27 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: AD p: 00 pc: 0259 sp: FD x: 27 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AD p: 80 pc: 025B sp: FD x: 27 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AD p: 00 pc: 025D sp: FD x: 27 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: AD p: 00 pc: 025F sp: FD x: 27 y: 04 
---
[1]    55 0261: 	sec
[2] a: AD p: 80 pc: 0261 sp: FD x: 27 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: AD p: 81 pc: 0262 sp: FD x: 27 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 55 p: 40 pc: 0264 sp: FD x: 27 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 55 p: 40 pc: 0266 sp: FD x: 27 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 27 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 27 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 27 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 27 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 27 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 27 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 55 p: 40 pc: 025B sp: FD x: 27 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 55 p: 40 pc: 025D sp: FD x: 27 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 55 p: 40 pc: 025F sp: FD x: 27 y: 04 
---
[1]    55 0261: 	sec
[2] a: 55 p: 40 pc: 0261 sp: FD x: 27 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 55 p: 41 pc: 0262 sp: FD x: 27 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 29 p: 00 pc: 0264 sp: FD x: 27 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 29 p: 00 pc: 0266 sp: FD x: 27 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 27 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 27 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 27 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 27 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 27 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 27 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 27 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 00 pc: 025D sp: FD x: 27 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 29 p: 00 pc: 025F sp: FD x: 27 y: 04 
---
[1]    55 0261: 	sec
[2] a: 29 p: 00 pc: 0261 sp: FD x: 27 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 29 p: 01 pc: 0262 sp: FD x: 27 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 27 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 27 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 27 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 27 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 27 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 27 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 27 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 27 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 27 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 27 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 27 y: 04 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 27 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 27 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 08 p: 00 pc: 0264 sp: FD x: 27 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 08 p: 00 pc: 0266 sp: FD x: 27 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0E p: 00 pc: 0268 sp: FD x: 27 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0F p: 00 pc: 026A sp: FD x: 27 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 00 pc: 026C sp: FD x: 27 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 01 pc: 026E sp: FD x: 27 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 03 pc: 0270 sp: FD x: 27 y: 04 
---
[1]    64 0272: 	rts
[2] a: 0F p: 03 pc: 0272 sp: FD x: 27 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0F p: 03 pc: 0220 sp: FF x: 27 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 08 p: 01 pc: 0222 sp: FF x: 27 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 08 p: 01 pc: 0224 sp: FF x: 27 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 27 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 27 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 27 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 27 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 27 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: AD p: 81 pc: 0216 sp: FF x: 27 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: AD p: 81 pc: 0218 sp: FF x: 27 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 27 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 27 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 27 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 27 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 27 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 27 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 27 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 27 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 27 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 27 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 27 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 27 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 27 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 27 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 27 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 27 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 27 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 27 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 27 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 27 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 27 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 27 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 27 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 27 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 27 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 27 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 27 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 27 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 27 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AD p: 80 pc: 025B sp: FD x: 27 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AD p: 81 pc: 025D sp: FD x: 27 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: AD p: 81 pc: 026C sp: FD x: 27 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: AD p: 00 pc: 026E sp: FD x: 27 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: AD p: 00 pc: 0270 sp: FD x: 27 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: AD p: 00 pc: 0259 sp: FD x: 27 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AD p: 80 pc: 025B sp: FD x: 27 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AD p: 00 pc: 025D sp: FD x: 27 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: AD p: 00 pc: 025F sp: FD x: 27 y: 05 
---
[1]    55 0261: 	sec
[2] a: AD p: 80 pc: 0261 sp: FD x: 27 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: AD p: 81 pc: 0262 sp: FD x: 27 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 45 p: 40 pc: 0264 sp: FD x: 27 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 45 p: 40 pc: 0266 sp: FD x: 27 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 27 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 27 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 27 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 27 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 27 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 27 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 45 p: 40 pc: 025B sp: FD x: 27 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 45 p: 40 pc: 025D sp: FD x: 27 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 45 p: 40 pc: 025F sp: FD x: 27 y: 05 
---
[1]    55 0261: 	sec
[2] a: 45 p: 40 pc: 0261 sp: FD x: 27 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 45 p: 41 pc: 0262 sp: FD x: 27 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 27 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 27 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 27 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 27 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 27 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 27 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 27 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 27 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 27 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 27 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 27 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 27 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 27 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 27 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 27 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 27 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 27 y: 05 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 27 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 27 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 27 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 27 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 27 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 27 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 27 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 27 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 27 y: 05 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 27 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 27 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 27 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 27 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 27 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 02 pc: 0229 sp: FF x: 27 y: 05 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0D p: 02 pc: 022E sp: FF x: 27 y: 05 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: AD p: 80 pc: 0231 sp: FF x: 27 y: 05 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: AD p: 00 pc: 0232 sp: FF x: 28 y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: AD p: 00 pc: 0235 sp: FF x: 28 y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: AD p: 80 pc: 0238 sp: FF x: 28 y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: AD p: 80 pc: 023B sp: FF x: 28 y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: AF p: 80 pc: 023E sp: FF x: 28 y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: AF p: 81 pc: 0240 sp: FF x: 28 y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: AF p: 81 pc: 0211 sp: FF x: 28 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: AF p: 01 pc: 0213 sp: FF x: 28 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: AF p: 81 pc: 0216 sp: FF x: 28 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: AF p: 81 pc: 0218 sp: FF x: 28 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 28 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 28 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 28 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 28 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 28 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 28 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AF p: 80 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AF p: 81 pc: 025D sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: AF p: 81 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: AF p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: AF p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: AF p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AF p: 80 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AF p: 00 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: AF p: 00 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: AF p: 80 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: AF p: 81 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 4F p: 40 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 4F p: 40 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 40 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: 40 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 4F p: 40 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: 4F p: 40 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4F p: 41 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 1F p: 00 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 1F p: 00 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 38 p: 00 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 38 p: 00 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 38 p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 38 p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 38 p: 00 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3A p: 00 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3A p: 00 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3A p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3A p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3A p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 28 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 28 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 28 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 28 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 28 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 28 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 28 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 28 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 28 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: AF p: 81 pc: 0216 sp: FF x: 28 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: AF p: 81 pc: 0218 sp: FF x: 28 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 28 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 28 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 28 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 28 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 28 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 28 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 28 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 28 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 28 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 28 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 28 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 28 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 28 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 28 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 28 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 28 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 28 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 28 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 28 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 28 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 28 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 28 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 28 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 28 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 28 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 28 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 28 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 28 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 28 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 28 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 28 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 28 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 28 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 28 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: AF p: 80 pc: 025B sp: FD x: 28 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: AF p: 00 pc: 025D sp: FD x: 28 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: AF p: 00 pc: 025F sp: FD x: 28 y: 02 
---
[1]    55 0261: 	sec
[2] a: AF p: 80 pc: 0261 sp: FD x: 28 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: AF p: 81 pc: 0262 sp: FD x: 28 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 28 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 28 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 28 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 28 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 28 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 28 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 28 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 28 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 28 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 28 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 28 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 28 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 28 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 28 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 28 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 28 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 28 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 28 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 28 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 28 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 28 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 28 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 28 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 28 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 28 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 28 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 28 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 28 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 28 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 28 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 28 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 28 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 28 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 28 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 22 p: 00 pc: 026A sp: FD x: 28 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 22 p: 00 pc: 026C sp: FD x: 28 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 22 p: 00 pc: 026E sp: FD x: 28 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 22 p: 00 pc: 0270 sp: FD x: 28 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 22 p: 00 pc: 0259 sp: FD x: 28 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 28 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 28 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 28 y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 28 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 28 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 28 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 28 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 22 p: 00 pc: 0268 sp: FD x: 28 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 23 p: 00 pc: 026A sp: FD x: 28 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 00 pc: 026C sp: FD x: 28 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 01 pc: 026E sp: FD x: 28 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 03 pc: 0270 sp: FD x: 28 y: 02 
---
[1]    64 0272: 	rts
[2] a: 23 p: 03 pc: 0272 sp: FD x: 28 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 23 p: 03 pc: 0220 sp: FF x: 28 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 28 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 28 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 28 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 28 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: B1 p: 81 pc: 023E sp: FF x: 28 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: B1 p: 81 pc: 0240 sp: FF x: 28 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: B1 p: 81 pc: 0211 sp: FF x: 28 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: B1 p: 01 pc: 0213 sp: FF x: 28 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: B1 p: 81 pc: 0216 sp: FF x: 28 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: B1 p: 81 pc: 0218 sp: FF x: 28 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 28 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 28 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 28 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 28 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 28 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 28 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B1 p: 80 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B1 p: 81 pc: 025D sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: B1 p: 81 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: B1 p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: B1 p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: B1 p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B1 p: 80 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B1 p: 00 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: B1 p: 00 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: B1 p: 80 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B1 p: 81 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 51 p: 40 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 51 p: 40 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 51 p: 40 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 51 p: 40 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 51 p: 40 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: 51 p: 40 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 51 p: 41 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 38 p: 00 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 38 p: 00 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 38 p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 38 p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 38 p: 00 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3A p: 00 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3A p: 00 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3A p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3A p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3A p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 3A p: 00 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3B p: 00 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3B p: 00 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3B p: 01 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3B p: 03 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    64 0272: 	rts
[2] a: 3B p: 03 pc: 0272 sp: FD x: 28 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 3B p: 03 pc: 0220 sp: FF x: 28 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 28 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 28 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 28 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 28 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: B3 p: 81 pc: 023E sp: FF x: 28 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: B3 p: 81 pc: 0240 sp: FF x: 28 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: B3 p: 81 pc: 0211 sp: FF x: 28 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: B3 p: 01 pc: 0213 sp: FF x: 28 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: B3 p: 81 pc: 0216 sp: FF x: 28 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: B3 p: 81 pc: 0218 sp: FF x: 28 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 28 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 28 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 28 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 28 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 28 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 28 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 28 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 28 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 28 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 28 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 28 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B3 p: 80 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B3 p: 81 pc: 025D sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: B3 p: 81 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: B3 p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: B3 p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: B3 p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B3 p: 80 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B3 p: 00 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: B3 p: 00 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: B3 p: 80 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B3 p: 81 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 53 p: 40 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 53 p: 40 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 53 p: 40 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 53 p: 40 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 53 p: 40 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: 53 p: 40 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 53 p: 41 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 38 p: 00 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 38 p: 00 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 38 p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 38 p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 38 p: 00 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3A p: 00 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3A p: 00 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3A p: 00 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3A p: 00 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3A p: 00 pc: 0259 sp: FD x: 28 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 28 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 28 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 28 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 28 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 28 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 28 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 28 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 3A p: 00 pc: 0268 sp: FD x: 28 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3B p: 00 pc: 026A sp: FD x: 28 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3B p: 00 pc: 026C sp: FD x: 28 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3B p: 01 pc: 026E sp: FD x: 28 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3B p: 03 pc: 0270 sp: FD x: 28 y: 01 
---
[1]    64 0272: 	rts
[2] a: 3B p: 03 pc: 0272 sp: FD x: 28 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 3B p: 03 pc: 0220 sp: FF x: 28 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 28 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 28 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 28 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 28 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 28 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 28 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 28 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: B3 p: 81 pc: 0216 sp: FF x: 28 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: B3 p: 81 pc: 0218 sp: FF x: 28 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 28 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 28 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 28 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 28 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 28 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 28 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 28 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 28 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 28 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 28 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 28 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 28 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 28 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 28 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 28 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 28 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 28 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 28 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 28 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 28 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 28 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 28 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 28 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 28 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 28 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 28 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 28 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 28 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 28 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 28 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 28 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 28 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 28 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 28 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B3 p: 80 pc: 025B sp: FD x: 28 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B3 p: 00 pc: 025D sp: FD x: 28 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: B3 p: 00 pc: 025F sp: FD x: 28 y: 02 
---
[1]    55 0261: 	sec
[2] a: B3 p: 80 pc: 0261 sp: FD x: 28 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B3 p: 81 pc: 0262 sp: FD x: 28 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 28 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 28 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 28 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 28 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 28 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 28 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 28 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 28 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 28 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 28 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 28 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 28 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 28 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 28 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 28 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 28 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 28 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 28 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 28 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 28 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 28 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 28 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 28 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 28 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 28 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 28 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 28 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 28 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 28 y: 02 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 28 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 28 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 28 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 28 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 28 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 22 p: 00 pc: 026A sp: FD x: 28 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 22 p: 00 pc: 026C sp: FD x: 28 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 22 p: 00 pc: 026E sp: FD x: 28 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 22 p: 00 pc: 0270 sp: FD x: 28 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 22 p: 00 pc: 0259 sp: FD x: 28 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 28 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 28 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 28 y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 28 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 28 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 28 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 28 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 22 p: 00 pc: 0268 sp: FD x: 28 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 23 p: 00 pc: 026A sp: FD x: 28 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 00 pc: 026C sp: FD x: 28 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 01 pc: 026E sp: FD x: 28 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 03 pc: 0270 sp: FD x: 28 y: 02 
---
[1]    64 0272: 	rts
[2] a: 23 p: 03 pc: 0272 sp: FD x: 28 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 23 p: 03 pc: 0220 sp: FF x: 28 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 28 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 28 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 28 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 28 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 28 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 28 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 28 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: B3 p: 81 pc: 0216 sp: FF x: 28 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: B3 p: 81 pc: 0218 sp: FF x: 28 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 28 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 28 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 28 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 28 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 28 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 28 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 28 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 28 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 28 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 28 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 28 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 28 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 28 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 28 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 28 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 28 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 28 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 28 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 28 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 28 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 28 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 28 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 28 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 28 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 28 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 28 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 28 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 28 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 28 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 28 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 28 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 28 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 28 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 28 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B3 p: 80 pc: 025B sp: FD x: 28 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B3 p: 81 pc: 025D sp: FD x: 28 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: B3 p: 81 pc: 026C sp: FD x: 28 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: B3 p: 00 pc: 026E sp: FD x: 28 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: B3 p: 00 pc: 0270 sp: FD x: 28 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: B3 p: 00 pc: 0259 sp: FD x: 28 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B3 p: 80 pc: 025B sp: FD x: 28 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B3 p: 00 pc: 025D sp: FD x: 28 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: B3 p: 00 pc: 025F sp: FD x: 28 y: 03 
---
[1]    55 0261: 	sec
[2] a: B3 p: 80 pc: 0261 sp: FD x: 28 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B3 p: 81 pc: 0262 sp: FD x: 28 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 43 p: 40 pc: 0264 sp: FD x: 28 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 43 p: 40 pc: 0266 sp: FD x: 28 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 28 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 28 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 28 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 28 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 28 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 28 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 43 p: 40 pc: 025B sp: FD x: 28 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 43 p: 40 pc: 025D sp: FD x: 28 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 43 p: 40 pc: 025F sp: FD x: 28 y: 03 
---
[1]    55 0261: 	sec
[2] a: 43 p: 40 pc: 0261 sp: FD x: 28 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 43 p: 41 pc: 0262 sp: FD x: 28 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 28 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 28 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 28 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 28 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 28 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 28 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 28 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 28 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 28 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 28 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 28 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 28 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 28 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 28 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 28 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 28 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 28 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 28 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 28 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 28 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 28 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 28 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 28 y: 03 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 28 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 28 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 28 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 28 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 28 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 19 p: 00 pc: 026A sp: FD x: 28 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 00 pc: 026C sp: FD x: 28 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 01 pc: 026E sp: FD x: 28 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 03 pc: 0270 sp: FD x: 28 y: 03 
---
[1]    64 0272: 	rts
[2] a: 19 p: 03 pc: 0272 sp: FD x: 28 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 19 p: 03 pc: 0220 sp: FF x: 28 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 28 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 28 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 28 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 28 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 28 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 28 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 28 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: B3 p: 81 pc: 0216 sp: FF x: 28 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: B3 p: 81 pc: 0218 sp: FF x: 28 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 28 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 28 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 28 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 28 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 28 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 28 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 28 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 28 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 28 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 28 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 28 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 28 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 28 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 28 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 28 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 28 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 28 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 28 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 28 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 28 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 28 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 28 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 28 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 28 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 28 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 28 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 28 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 28 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 28 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B3 p: 80 pc: 025B sp: FD x: 28 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B3 p: 00 pc: 025D sp: FD x: 28 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: B3 p: 00 pc: 025F sp: FD x: 28 y: 04 
---
[1]    55 0261: 	sec
[2] a: B3 p: 80 pc: 0261 sp: FD x: 28 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B3 p: 81 pc: 0262 sp: FD x: 28 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 28 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 28 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 28 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 28 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 28 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 28 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 28 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 28 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 28 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 28 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 28 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 28 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 28 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 28 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 28 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 28 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 28 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 28 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 28 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 28 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 28 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 28 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 28 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 28 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 28 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 28 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 28 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 28 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 28 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 28 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 28 y: 04 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 28 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 28 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 28 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 28 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 28 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 28 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 28 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 28 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 28 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: B3 p: 81 pc: 0216 sp: FF x: 28 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: B3 p: 81 pc: 0218 sp: FF x: 28 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 28 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 28 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 28 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 28 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 28 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 28 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 28 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 28 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 28 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 28 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 28 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 28 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 28 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 28 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 28 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 28 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 28 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 28 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 28 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 28 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 28 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 28 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 28 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 28 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 28 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 28 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 28 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 28 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 28 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B3 p: 80 pc: 025B sp: FD x: 28 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B3 p: 81 pc: 025D sp: FD x: 28 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: B3 p: 81 pc: 026C sp: FD x: 28 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: B3 p: 00 pc: 026E sp: FD x: 28 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: B3 p: 00 pc: 0270 sp: FD x: 28 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: B3 p: 00 pc: 0259 sp: FD x: 28 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B3 p: 80 pc: 025B sp: FD x: 28 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B3 p: 00 pc: 025D sp: FD x: 28 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: B3 p: 00 pc: 025F sp: FD x: 28 y: 05 
---
[1]    55 0261: 	sec
[2] a: B3 p: 80 pc: 0261 sp: FD x: 28 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B3 p: 81 pc: 0262 sp: FD x: 28 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 4B p: 40 pc: 0264 sp: FD x: 28 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 4B p: 40 pc: 0266 sp: FD x: 28 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 28 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 28 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 28 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 28 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 28 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 28 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4B p: 40 pc: 025B sp: FD x: 28 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4B p: 40 pc: 025D sp: FD x: 28 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 4B p: 40 pc: 025F sp: FD x: 28 y: 05 
---
[1]    55 0261: 	sec
[2] a: 4B p: 40 pc: 0261 sp: FD x: 28 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4B p: 41 pc: 0262 sp: FD x: 28 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 28 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 28 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 28 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 28 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 28 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 28 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 28 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 28 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 28 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 28 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 28 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 28 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 28 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 28 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 28 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 28 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 28 y: 05 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 28 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 28 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 0A p: 00 pc: 0264 sp: FD x: 28 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 0A p: 00 pc: 0266 sp: FD x: 28 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 28 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 28 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 28 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 28 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 28 y: 05 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 28 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 28 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0A p: 01 pc: 0222 sp: FF x: 28 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0A p: 01 pc: 0224 sp: FF x: 28 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 28 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 02 pc: 0229 sp: FF x: 28 y: 05 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0D p: 02 pc: 022E sp: FF x: 28 y: 05 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: B3 p: 80 pc: 0231 sp: FF x: 28 y: 05 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: B3 p: 00 pc: 0232 sp: FF x: 29 y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: B3 p: 00 pc: 0235 sp: FF x: 29 y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: B3 p: 80 pc: 0238 sp: FF x: 29 y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: B3 p: 80 pc: 023B sp: FF x: 29 y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: B5 p: 80 pc: 023E sp: FF x: 29 y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: B5 p: 81 pc: 0240 sp: FF x: 29 y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: B5 p: 81 pc: 0211 sp: FF x: 29 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: B5 p: 01 pc: 0213 sp: FF x: 29 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: B5 p: 81 pc: 0216 sp: FF x: 29 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: B5 p: 81 pc: 0218 sp: FF x: 29 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 29 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 29 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 29 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 29 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 29 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 29 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 29 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 29 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 29 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 29 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 29 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 29 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 29 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 29 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 29 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 29 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 29 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 29 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 29 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 29 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 29 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 29 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 29 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 29 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 29 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 29 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 29 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 29 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 29 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 29 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 29 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 29 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 29 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 29 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 29 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 29 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 29 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 29 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 29 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B5 p: 80 pc: 025B sp: FD x: 29 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B5 p: 81 pc: 025D sp: FD x: 29 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: B5 p: 81 pc: 026C sp: FD x: 29 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: B5 p: 00 pc: 026E sp: FD x: 29 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: B5 p: 00 pc: 0270 sp: FD x: 29 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: B5 p: 00 pc: 0259 sp: FD x: 29 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B5 p: 80 pc: 025B sp: FD x: 29 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B5 p: 00 pc: 025D sp: FD x: 29 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: B5 p: 00 pc: 025F sp: FD x: 29 y: 01 
---
[1]    55 0261: 	sec
[2] a: B5 p: 80 pc: 0261 sp: FD x: 29 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B5 p: 81 pc: 0262 sp: FD x: 29 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 55 p: 40 pc: 0264 sp: FD x: 29 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 55 p: 40 pc: 0266 sp: FD x: 29 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 29 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 29 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 29 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 29 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 29 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 29 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 55 p: 40 pc: 025B sp: FD x: 29 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 55 p: 40 pc: 025D sp: FD x: 29 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 55 p: 40 pc: 025F sp: FD x: 29 y: 01 
---
[1]    55 0261: 	sec
[2] a: 55 p: 40 pc: 0261 sp: FD x: 29 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 55 p: 41 pc: 0262 sp: FD x: 29 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 25 p: 00 pc: 0264 sp: FD x: 29 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 25 p: 00 pc: 0266 sp: FD x: 29 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 29 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 29 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 29 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 29 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 29 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 29 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 29 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 29 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 29 y: 01 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 29 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 29 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 29 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 29 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 29 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 38 p: 00 pc: 026A sp: FD x: 29 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 38 p: 00 pc: 026C sp: FD x: 29 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 38 p: 00 pc: 026E sp: FD x: 29 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 38 p: 00 pc: 0270 sp: FD x: 29 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 29 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 29 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 29 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 29 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 29 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 29 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 29 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 29 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 38 p: 00 pc: 0268 sp: FD x: 29 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3C p: 00 pc: 026A sp: FD x: 29 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3C p: 00 pc: 026C sp: FD x: 29 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3C p: 00 pc: 026E sp: FD x: 29 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3C p: 00 pc: 0270 sp: FD x: 29 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3C p: 00 pc: 0259 sp: FD x: 29 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 29 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 29 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 29 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 29 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 29 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 29 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 29 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 29 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 29 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 29 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 29 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 29 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 29 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 29 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 29 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 29 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 29 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 29 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 29 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 29 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: B5 p: 81 pc: 0216 sp: FF x: 29 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: B5 p: 81 pc: 0218 sp: FF x: 29 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 29 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 29 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 29 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 29 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 29 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 29 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 29 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 29 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 29 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 29 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 29 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 29 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 29 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 29 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 29 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 29 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 29 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 29 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 29 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 29 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 29 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 29 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 29 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 29 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 29 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 29 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 29 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 29 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 29 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 29 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 29 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 29 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 29 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 29 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B5 p: 80 pc: 025B sp: FD x: 29 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B5 p: 00 pc: 025D sp: FD x: 29 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: B5 p: 00 pc: 025F sp: FD x: 29 y: 02 
---
[1]    55 0261: 	sec
[2] a: B5 p: 80 pc: 0261 sp: FD x: 29 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B5 p: 81 pc: 0262 sp: FD x: 29 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 29 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 29 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 29 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 29 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 29 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 29 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 29 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 29 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 29 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 29 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 29 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 29 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 29 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 29 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 29 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 29 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 29 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 29 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 29 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 29 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 29 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 29 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 29 y: 02 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 29 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 29 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 29 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 29 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 29 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 29 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 29 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 29 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 29 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 29 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 29 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 29 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 29 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 29 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 29 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 29 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 29 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 29 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 29 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 29 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 29 y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 29 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 29 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 29 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 29 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 29 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 29 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 29 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 29 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 29 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: B5 p: 81 pc: 0216 sp: FF x: 29 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: B5 p: 81 pc: 0218 sp: FF x: 29 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 29 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 29 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 29 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 29 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 29 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 29 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 29 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 29 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 29 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 29 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 29 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 29 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 29 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 29 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 29 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 29 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 29 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 29 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 29 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 29 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 29 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 29 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 29 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 29 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 29 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 29 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 29 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 29 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 29 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 29 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 29 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 29 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 29 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 29 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B5 p: 80 pc: 025B sp: FD x: 29 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B5 p: 81 pc: 025D sp: FD x: 29 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: B5 p: 81 pc: 026C sp: FD x: 29 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: B5 p: 00 pc: 026E sp: FD x: 29 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: B5 p: 00 pc: 0270 sp: FD x: 29 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: B5 p: 00 pc: 0259 sp: FD x: 29 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B5 p: 80 pc: 025B sp: FD x: 29 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B5 p: 00 pc: 025D sp: FD x: 29 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: B5 p: 00 pc: 025F sp: FD x: 29 y: 03 
---
[1]    55 0261: 	sec
[2] a: B5 p: 80 pc: 0261 sp: FD x: 29 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B5 p: 81 pc: 0262 sp: FD x: 29 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 45 p: 40 pc: 0264 sp: FD x: 29 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 45 p: 40 pc: 0266 sp: FD x: 29 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 29 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 29 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 29 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 29 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 29 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 29 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 45 p: 40 pc: 025B sp: FD x: 29 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 45 p: 40 pc: 025D sp: FD x: 29 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 45 p: 40 pc: 025F sp: FD x: 29 y: 03 
---
[1]    55 0261: 	sec
[2] a: 45 p: 40 pc: 0261 sp: FD x: 29 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 45 p: 41 pc: 0262 sp: FD x: 29 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 29 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 29 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 29 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 29 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 29 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 29 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 29 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 29 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 29 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 29 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 29 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 29 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 29 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 29 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 29 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 29 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 29 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 29 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 29 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 29 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 29 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 29 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 29 y: 03 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 29 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 29 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 29 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 29 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 29 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 19 p: 00 pc: 026A sp: FD x: 29 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 00 pc: 026C sp: FD x: 29 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 01 pc: 026E sp: FD x: 29 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 03 pc: 0270 sp: FD x: 29 y: 03 
---
[1]    64 0272: 	rts
[2] a: 19 p: 03 pc: 0272 sp: FD x: 29 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 19 p: 03 pc: 0220 sp: FF x: 29 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 29 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 29 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 29 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 29 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 29 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 29 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 29 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: B5 p: 81 pc: 0216 sp: FF x: 29 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: B5 p: 81 pc: 0218 sp: FF x: 29 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 29 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 29 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 29 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 29 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 29 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 29 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 29 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 29 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 29 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 29 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 29 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 29 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 29 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 29 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 29 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 29 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 29 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 29 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 29 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 29 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 29 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 29 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 29 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 29 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 29 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 29 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 29 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 29 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 29 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B5 p: 80 pc: 025B sp: FD x: 29 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B5 p: 00 pc: 025D sp: FD x: 29 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: B5 p: 00 pc: 025F sp: FD x: 29 y: 04 
---
[1]    55 0261: 	sec
[2] a: B5 p: 80 pc: 0261 sp: FD x: 29 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B5 p: 81 pc: 0262 sp: FD x: 29 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 29 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 29 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 29 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 29 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 29 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 29 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 29 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 29 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 29 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 29 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 29 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 29 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 29 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 29 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 29 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 29 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 29 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 29 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 29 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 29 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 29 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 29 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 29 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 29 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 29 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 29 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 29 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 29 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 29 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 29 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 29 y: 04 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 29 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 29 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 29 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 29 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 29 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 29 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 29 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 29 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 29 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: B5 p: 81 pc: 0216 sp: FF x: 29 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: B5 p: 81 pc: 0218 sp: FF x: 29 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 29 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 29 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 29 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 29 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 29 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 29 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 29 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 29 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 29 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 29 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 29 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 29 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 29 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 29 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 29 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 29 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 29 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 29 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 29 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 29 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 29 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 29 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 29 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 29 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 29 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 29 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 29 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 29 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 29 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B5 p: 80 pc: 025B sp: FD x: 29 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B5 p: 81 pc: 025D sp: FD x: 29 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: B5 p: 81 pc: 026C sp: FD x: 29 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: B5 p: 00 pc: 026E sp: FD x: 29 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: B5 p: 00 pc: 0270 sp: FD x: 29 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: B5 p: 00 pc: 0259 sp: FD x: 29 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B5 p: 80 pc: 025B sp: FD x: 29 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B5 p: 00 pc: 025D sp: FD x: 29 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: B5 p: 00 pc: 025F sp: FD x: 29 y: 05 
---
[1]    55 0261: 	sec
[2] a: B5 p: 80 pc: 0261 sp: FD x: 29 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B5 p: 81 pc: 0262 sp: FD x: 29 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 4D p: 40 pc: 0264 sp: FD x: 29 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 4D p: 40 pc: 0266 sp: FD x: 29 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 29 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 29 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 29 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 29 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 29 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 29 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4D p: 40 pc: 025B sp: FD x: 29 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4D p: 40 pc: 025D sp: FD x: 29 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 4D p: 40 pc: 025F sp: FD x: 29 y: 05 
---
[1]    55 0261: 	sec
[2] a: 4D p: 40 pc: 0261 sp: FD x: 29 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4D p: 41 pc: 0262 sp: FD x: 29 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 29 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 29 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 29 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 29 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 29 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 29 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 29 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 29 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 29 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 29 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 29 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 29 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 29 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 29 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 29 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 29 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 29 y: 05 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 29 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 29 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 0C p: 00 pc: 0264 sp: FD x: 29 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 0C p: 00 pc: 0266 sp: FD x: 29 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 29 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 29 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 29 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 29 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 29 y: 05 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 29 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 29 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0C p: 01 pc: 0222 sp: FF x: 29 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0C p: 01 pc: 0224 sp: FF x: 29 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 29 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 02 pc: 0229 sp: FF x: 29 y: 05 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 0D p: 02 pc: 022E sp: FF x: 29 y: 05 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: B5 p: 80 pc: 0231 sp: FF x: 29 y: 05 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: B5 p: 00 pc: 0232 sp: FF x: 2A y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: B5 p: 00 pc: 0235 sp: FF x: 2A y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: B5 p: 80 pc: 0238 sp: FF x: 2A y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: B5 p: 80 pc: 023B sp: FF x: 2A y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: B7 p: 80 pc: 023E sp: FF x: 2A y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: B7 p: 81 pc: 0240 sp: FF x: 2A y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: B7 p: 81 pc: 0211 sp: FF x: 2A y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: B7 p: 01 pc: 0213 sp: FF x: 2A y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: B7 p: 81 pc: 0216 sp: FF x: 2A y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: B7 p: 81 pc: 0218 sp: FF x: 2A y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2A y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2A y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2A y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B7 p: 80 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B7 p: 81 pc: 025D sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: B7 p: 81 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: B7 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: B7 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: B7 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B7 p: 80 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B7 p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: B7 p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: B7 p: 80 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B7 p: 81 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 57 p: 40 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 57 p: 40 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 57 p: 40 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 57 p: 40 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 57 p: 40 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 57 p: 40 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 57 p: 41 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 27 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 27 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 38 p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 38 p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 38 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 38 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 38 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3C p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3C p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3C p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3C p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3C p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 3C p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3D p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3D p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3D p: 01 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3D p: 03 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    64 0272: 	rts
[2] a: 3D p: 03 pc: 0272 sp: FD x: 2A y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 3D p: 03 pc: 0220 sp: FF x: 2A y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2A y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2A y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2A y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2A y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: B9 p: 81 pc: 023E sp: FF x: 2A y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: B9 p: 81 pc: 0240 sp: FF x: 2A y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: B9 p: 81 pc: 0211 sp: FF x: 2A y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: B9 p: 01 pc: 0213 sp: FF x: 2A y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: B9 p: 81 pc: 0216 sp: FF x: 2A y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: B9 p: 81 pc: 0218 sp: FF x: 2A y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2A y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2A y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2A y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B9 p: 80 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B9 p: 81 pc: 025D sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: B9 p: 81 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: B9 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: B9 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: B9 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B9 p: 80 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B9 p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: B9 p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: B9 p: 80 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B9 p: 81 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 59 p: 40 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 59 p: 40 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 59 p: 40 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 59 p: 40 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 59 p: 40 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 59 p: 40 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 59 p: 41 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 29 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 29 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 29 p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 29 p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 29 p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 38 p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 38 p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 38 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 38 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 38 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3C p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3C p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3C p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3C p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3C p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 3C p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3D p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3D p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3D p: 01 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3D p: 03 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    64 0272: 	rts
[2] a: 3D p: 03 pc: 0272 sp: FD x: 2A y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 3D p: 03 pc: 0220 sp: FF x: 2A y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2A y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2A y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2A y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2A y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2A y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2A y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2A y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: B9 p: 81 pc: 0216 sp: FF x: 2A y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: B9 p: 81 pc: 0218 sp: FF x: 2A y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2A y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2A y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2A y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: B9 p: 80 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: B9 p: 00 pc: 025D sp: FD x: 2A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: B9 p: 00 pc: 025F sp: FD x: 2A y: 02 
---
[1]    55 0261: 	sec
[2] a: B9 p: 80 pc: 0261 sp: FD x: 2A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: B9 p: 81 pc: 0262 sp: FD x: 2A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 2A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 2A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 2A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 2A y: 02 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 2A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 2A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 2A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 2A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 2A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 2A y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 2A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 2A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 24 p: 00 pc: 0268 sp: FD x: 2A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 25 p: 00 pc: 026A sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 00 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 01 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 03 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    64 0272: 	rts
[2] a: 25 p: 03 pc: 0272 sp: FD x: 2A y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 25 p: 03 pc: 0220 sp: FF x: 2A y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2A y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2A y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2A y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2A y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: BB p: 81 pc: 023E sp: FF x: 2A y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: BB p: 81 pc: 0240 sp: FF x: 2A y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: BB p: 81 pc: 0211 sp: FF x: 2A y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: BB p: 01 pc: 0213 sp: FF x: 2A y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: BB p: 81 pc: 0216 sp: FF x: 2A y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: BB p: 81 pc: 0218 sp: FF x: 2A y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2A y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2A y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2A y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BB p: 80 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BB p: 81 pc: 025D sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: BB p: 81 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: BB p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: BB p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: BB p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BB p: 80 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BB p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: BB p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: BB p: 80 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: BB p: 81 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 5B p: 40 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 5B p: 40 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5B p: 40 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5B p: 40 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 5B p: 40 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 5B p: 40 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5B p: 41 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 2B p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 2B p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2B p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 2B p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2B p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 38 p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 38 p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 38 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 38 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 38 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3C p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3C p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3C p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3C p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3C p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 3C p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3E p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3E p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3E p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3E p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3E p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2A y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2A y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2A y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2A y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2A y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2A y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2A y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2A y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2A y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: BB p: 81 pc: 0216 sp: FF x: 2A y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: BB p: 81 pc: 0218 sp: FF x: 2A y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2A y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2A y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2A y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BB p: 80 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BB p: 00 pc: 025D sp: FD x: 2A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: BB p: 00 pc: 025F sp: FD x: 2A y: 02 
---
[1]    55 0261: 	sec
[2] a: BB p: 80 pc: 0261 sp: FD x: 2A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: BB p: 81 pc: 0262 sp: FD x: 2A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 2A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 2A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 2A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 2A y: 02 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 2A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 2A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 2A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 2A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 2A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 2A y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 2A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 2A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 24 p: 00 pc: 0268 sp: FD x: 2A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 25 p: 00 pc: 026A sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 00 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 01 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 03 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    64 0272: 	rts
[2] a: 25 p: 03 pc: 0272 sp: FD x: 2A y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 25 p: 03 pc: 0220 sp: FF x: 2A y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2A y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2A y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 2A y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 2A y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 2A y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 2A y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 2A y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: BB p: 81 pc: 0216 sp: FF x: 2A y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: BB p: 81 pc: 0218 sp: FF x: 2A y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 2A y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 2A y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 2A y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 2A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 2A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 2A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 2A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 2A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 2A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 2A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 2A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 2A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 2A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 2A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 2A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 2A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 2A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 2A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 2A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 2A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 2A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 2A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 2A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 2A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 2A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 2A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 2A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 2A y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 2A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 2A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BB p: 80 pc: 025B sp: FD x: 2A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BB p: 81 pc: 025D sp: FD x: 2A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: BB p: 81 pc: 026C sp: FD x: 2A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: BB p: 00 pc: 026E sp: FD x: 2A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: BB p: 00 pc: 0270 sp: FD x: 2A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: BB p: 00 pc: 0259 sp: FD x: 2A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BB p: 80 pc: 025B sp: FD x: 2A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BB p: 00 pc: 025D sp: FD x: 2A y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: BB p: 00 pc: 025F sp: FD x: 2A y: 03 
---
[1]    55 0261: 	sec
[2] a: BB p: 80 pc: 0261 sp: FD x: 2A y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: BB p: 81 pc: 0262 sp: FD x: 2A y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 4B p: 40 pc: 0264 sp: FD x: 2A y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 4B p: 40 pc: 0266 sp: FD x: 2A y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2A y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 2A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 2A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 2A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 2A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 2A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4B p: 40 pc: 025B sp: FD x: 2A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4B p: 40 pc: 025D sp: FD x: 2A y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 4B p: 40 pc: 025F sp: FD x: 2A y: 03 
---
[1]    55 0261: 	sec
[2] a: 4B p: 40 pc: 0261 sp: FD x: 2A y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4B p: 41 pc: 0262 sp: FD x: 2A y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 2A y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 2A y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2A y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 2A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 2A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 2A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 2A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 2A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 2A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 2A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 2A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 2A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 2A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 2A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 2A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 2A y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 2A y: 03 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 2A y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 2A y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 2A y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 2A y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 2A y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1A p: 00 pc: 026A sp: FD x: 2A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1A p: 00 pc: 026C sp: FD x: 2A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1A p: 00 pc: 026E sp: FD x: 2A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1A p: 00 pc: 0270 sp: FD x: 2A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1A p: 00 pc: 0259 sp: FD x: 2A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 2A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 2A y: 03 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 2A y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 2A y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 2A y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 2A y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 2A y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 2A y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 2A y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 2A y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 2A y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: BB p: 81 pc: 0216 sp: FF x: 2A y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: BB p: 81 pc: 0218 sp: FF x: 2A y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 2A y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 2A y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 2A y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 2A y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 2A y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 2A y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 2A y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 2A y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 2A y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 2A y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 2A y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 2A y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 2A y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 2A y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 2A y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 2A y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 2A y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 2A y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 2A y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 2A y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 2A y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 2A y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 2A y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 2A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 2A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BB p: 80 pc: 025B sp: FD x: 2A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BB p: 00 pc: 025D sp: FD x: 2A y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: BB p: 00 pc: 025F sp: FD x: 2A y: 04 
---
[1]    55 0261: 	sec
[2] a: BB p: 80 pc: 0261 sp: FD x: 2A y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: BB p: 81 pc: 0262 sp: FD x: 2A y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 2A y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 2A y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2A y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 2A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 2A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 2A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 2A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 2A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 2A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 2A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 2A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 2A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 2A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 2A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 2A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 2A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 2A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 2A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 2A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 2A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 2A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 2A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 2A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 02 pc: 025D sp: FD x: 2A y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 02 pc: 025F sp: FD x: 2A y: 04 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 2A y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 2A y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2A y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2A y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2A y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 2A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 2A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 2A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 2A y: 04 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 2A y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 2A y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2A y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2A y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2A y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2A y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: BD p: 81 pc: 023E sp: FF x: 2A y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: BD p: 81 pc: 0240 sp: FF x: 2A y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: BD p: 81 pc: 0211 sp: FF x: 2A y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: BD p: 01 pc: 0213 sp: FF x: 2A y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: BD p: 81 pc: 0216 sp: FF x: 2A y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: BD p: 81 pc: 0218 sp: FF x: 2A y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2A y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2A y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2A y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BD p: 80 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BD p: 81 pc: 025D sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: BD p: 81 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: BD p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: BD p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: BD p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BD p: 80 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BD p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: BD p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: BD p: 80 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: BD p: 81 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 5D p: 40 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 5D p: 40 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5D p: 40 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5D p: 40 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 5D p: 40 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 5D p: 40 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5D p: 41 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 2D p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 2D p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2D p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 2D p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2D p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 38 p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 38 p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 38 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 38 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 38 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3C p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3C p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3C p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3C p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3C p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 3C p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3E p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3E p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3E p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3E p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3E p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 3E p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3F p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3F p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3F p: 01 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3F p: 03 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    64 0272: 	rts
[2] a: 3F p: 03 pc: 0272 sp: FD x: 2A y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 3F p: 03 pc: 0220 sp: FF x: 2A y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2A y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2A y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2A y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2A y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: BF p: 81 pc: 023E sp: FF x: 2A y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: BF p: 81 pc: 0240 sp: FF x: 2A y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: BF p: 81 pc: 0211 sp: FF x: 2A y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: BF p: 01 pc: 0213 sp: FF x: 2A y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: BF p: 81 pc: 0216 sp: FF x: 2A y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: BF p: 81 pc: 0218 sp: FF x: 2A y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2A y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2A y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2A y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2A y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2A y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2A y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2A y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2A y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BF p: 80 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BF p: 81 pc: 025D sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: BF p: 81 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: BF p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: BF p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: BF p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BF p: 80 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BF p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: BF p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: BF p: 80 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: BF p: 81 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 5F p: 40 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 5F p: 40 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5F p: 40 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5F p: 40 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 5F p: 40 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 5F p: 40 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5F p: 41 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 2F p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 2F p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2F p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 2F p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2F p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 38 p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 38 p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 38 p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 38 p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 38 p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 38 p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3C p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3C p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3C p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3C p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3C p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 3C p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3E p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3E p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3E p: 00 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3E p: 00 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3E p: 00 pc: 0259 sp: FD x: 2A y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2A y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 2A y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 2A y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 2A y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 2A y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2A y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2A y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 3E p: 00 pc: 0268 sp: FD x: 2A y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 3F p: 00 pc: 026A sp: FD x: 2A y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3F p: 00 pc: 026C sp: FD x: 2A y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3F p: 01 pc: 026E sp: FD x: 2A y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3F p: 03 pc: 0270 sp: FD x: 2A y: 01 
---
[1]    64 0272: 	rts
[2] a: 3F p: 03 pc: 0272 sp: FD x: 2A y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 3F p: 03 pc: 0220 sp: FF x: 2A y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2A y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2A y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2A y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2A y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2A y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2A y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2A y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: BF p: 81 pc: 0216 sp: FF x: 2A y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: BF p: 81 pc: 0218 sp: FF x: 2A y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2A y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2A y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2A y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2A y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2A y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2A y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2A y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2A y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BF p: 80 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BF p: 00 pc: 025D sp: FD x: 2A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: BF p: 00 pc: 025F sp: FD x: 2A y: 02 
---
[1]    55 0261: 	sec
[2] a: BF p: 80 pc: 0261 sp: FD x: 2A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: BF p: 81 pc: 0262 sp: FD x: 2A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 1F p: 00 pc: 0264 sp: FD x: 2A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 1F p: 00 pc: 0266 sp: FD x: 2A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 81 pc: 025D sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 81 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1F p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 81 pc: 025D sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 81 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1F p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 2A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 2A y: 02 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 2A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 2A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 2A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 2A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 2A y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 2A y: 02 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 2A y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 2A y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2A y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2A y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 24 p: 00 pc: 0268 sp: FD x: 2A y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 26 p: 00 pc: 026A sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 26 p: 00 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 26 p: 00 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 26 p: 00 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 26 p: 00 pc: 0259 sp: FD x: 2A y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2A y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2A y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2A y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2A y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2A y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2A y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2A y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2A y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2A y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 2A y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 2A y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 2A y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 2A y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 2A y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: BF p: 81 pc: 0216 sp: FF x: 2A y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: BF p: 81 pc: 0218 sp: FF x: 2A y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 2A y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 2A y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 2A y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 2A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 2A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 2A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 2A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 2A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 2A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 2A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 2A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 2A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 2A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 2A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 2A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 2A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 2A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 2A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 2A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 2A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 2A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 2A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 2A y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 2A y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 2A y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 2A y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 2A y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 2A y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 2A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 2A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BF p: 80 pc: 025B sp: FD x: 2A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BF p: 81 pc: 025D sp: FD x: 2A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: BF p: 81 pc: 026C sp: FD x: 2A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: BF p: 00 pc: 026E sp: FD x: 2A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: BF p: 00 pc: 0270 sp: FD x: 2A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: BF p: 00 pc: 0259 sp: FD x: 2A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BF p: 80 pc: 025B sp: FD x: 2A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BF p: 00 pc: 025D sp: FD x: 2A y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: BF p: 00 pc: 025F sp: FD x: 2A y: 03 
---
[1]    55 0261: 	sec
[2] a: BF p: 80 pc: 0261 sp: FD x: 2A y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: BF p: 81 pc: 0262 sp: FD x: 2A y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 4F p: 40 pc: 0264 sp: FD x: 2A y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 4F p: 40 pc: 0266 sp: FD x: 2A y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2A y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 2A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 2A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 2A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 2A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 2A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 40 pc: 025B sp: FD x: 2A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: 40 pc: 025D sp: FD x: 2A y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 4F p: 40 pc: 025F sp: FD x: 2A y: 03 
---
[1]    55 0261: 	sec
[2] a: 4F p: 40 pc: 0261 sp: FD x: 2A y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4F p: 41 pc: 0262 sp: FD x: 2A y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 2A y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 2A y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2A y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 2A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 2A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 2A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 2A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 2A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 2A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 2A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 2A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 2A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 2A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 2A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 2A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 2A y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 2A y: 03 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 2A y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 2A y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 2A y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 2A y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 2A y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1A p: 00 pc: 026A sp: FD x: 2A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1A p: 00 pc: 026C sp: FD x: 2A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1A p: 00 pc: 026E sp: FD x: 2A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1A p: 00 pc: 0270 sp: FD x: 2A y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1A p: 00 pc: 0259 sp: FD x: 2A y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2A y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 2A y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 2A y: 03 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 2A y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 2A y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2A y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2A y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1A p: 00 pc: 0268 sp: FD x: 2A y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1B p: 00 pc: 026A sp: FD x: 2A y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 00 pc: 026C sp: FD x: 2A y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 01 pc: 026E sp: FD x: 2A y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 03 pc: 0270 sp: FD x: 2A y: 03 
---
[1]    64 0272: 	rts
[2] a: 1B p: 03 pc: 0272 sp: FD x: 2A y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1B p: 03 pc: 0220 sp: FF x: 2A y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2A y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2A y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 2A y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 2A y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 2A y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 2A y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 2A y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: BF p: 81 pc: 0216 sp: FF x: 2A y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: BF p: 81 pc: 0218 sp: FF x: 2A y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 2A y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 2A y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 2A y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 2A y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 2A y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 2A y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 2A y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 2A y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 2A y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 2A y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 2A y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 2A y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 2A y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 2A y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 2A y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 2A y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 2A y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 2A y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 2A y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 2A y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 2A y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 2A y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 2A y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 2A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 2A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BF p: 80 pc: 025B sp: FD x: 2A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BF p: 00 pc: 025D sp: FD x: 2A y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: BF p: 00 pc: 025F sp: FD x: 2A y: 04 
---
[1]    55 0261: 	sec
[2] a: BF p: 80 pc: 0261 sp: FD x: 2A y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: BF p: 81 pc: 0262 sp: FD x: 2A y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 2A y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 2A y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2A y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 2A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 2A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 2A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 2A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 2A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 2A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 2A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 2A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 2A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 2A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 2A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 2A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 2A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 2A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 2A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 2A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 2A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 2A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 2A y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 2A y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2A y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 2A y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 2A y: 04 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 2A y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 2A y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 2A y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 2A y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2A y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 2A y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 2A y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 2A y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 2A y: 04 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 2A y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 2A y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 2A y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 2A y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 2A y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 2A y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 2A y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 2A y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 2A y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: BF p: 81 pc: 0216 sp: FF x: 2A y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: BF p: 81 pc: 0218 sp: FF x: 2A y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 2A y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 2A y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 2A y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 2A y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 2A y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 2A y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 2A y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 2A y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 2A y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 2A y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 2A y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 2A y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 2A y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 2A y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 2A y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 2A y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 2A y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 2A y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 2A y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 2A y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 2A y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 2A y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 2A y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 2A y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 2A y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BF p: 80 pc: 025B sp: FD x: 2A y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BF p: 81 pc: 025D sp: FD x: 2A y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: BF p: 81 pc: 026C sp: FD x: 2A y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: BF p: 00 pc: 026E sp: FD x: 2A y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: BF p: 00 pc: 0270 sp: FD x: 2A y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: BF p: 00 pc: 0259 sp: FD x: 2A y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BF p: 80 pc: 025B sp: FD x: 2A y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BF p: 00 pc: 025D sp: FD x: 2A y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: BF p: 00 pc: 025F sp: FD x: 2A y: 05 
---
[1]    55 0261: 	sec
[2] a: BF p: 80 pc: 0261 sp: FD x: 2A y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: BF p: 81 pc: 0262 sp: FD x: 2A y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 57 p: 40 pc: 0264 sp: FD x: 2A y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 57 p: 40 pc: 0266 sp: FD x: 2A y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2A y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 2A y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 2A y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 2A y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 2A y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 2A y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 57 p: 40 pc: 025B sp: FD x: 2A y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 57 p: 40 pc: 025D sp: FD x: 2A y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 57 p: 40 pc: 025F sp: FD x: 2A y: 05 
---
[1]    55 0261: 	sec
[2] a: 57 p: 40 pc: 0261 sp: FD x: 2A y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 57 p: 41 pc: 0262 sp: FD x: 2A y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 2A y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 2A y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 2A y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 2A y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 2A y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 2A y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 2A y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 2A y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 2A y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 2A y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 2A y: 05 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 2A y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 2A y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 2A y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 2A y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 2A y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 2A y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 2A y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 2A y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 2A y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 2A y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2A y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 2A y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 2A y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 2A y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 2A y: 05 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 2A y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 2A y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 09 p: 01 pc: 0222 sp: FF x: 2A y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 09 p: 01 pc: 0224 sp: FF x: 2A y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 2A y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 81 pc: 0229 sp: FF x: 2A y: 05 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0D p: 81 pc: 022B sp: FF x: 2A y: 05 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0D p: 01 pc: 022C sp: FF x: 2A y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 2A y: 06 
---
[1]    18 0216: 	sta dividend
[2] a: BF p: 81 pc: 0216 sp: FF x: 2A y: 06 
---
[1]    19 0218: 	lda pstore, y
[2] a: BF p: 81 pc: 0218 sp: FF x: 2A y: 06 
---
[1]    20 021B: 	sta divisor
[2] a: 11 p: 01 pc: 021B sp: FF x: 2A y: 06 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 11 p: 01 pc: 021D sp: FF x: 2A y: 06 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 11 p: 01 pc: 0244 sp: FD x: 2A y: 06 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2A y: 06 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2A y: 06 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2A y: 06 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2A y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 11 p: 01 pc: 024E sp: FD x: 2A y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 11 p: 81 pc: 0250 sp: FD x: 2A y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 11 p: 81 pc: 0252 sp: FD x: 2A y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 11 p: 00 pc: 0254 sp: FD x: 2A y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 22 p: 00 pc: 0255 sp: FD x: 2A y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 22 p: 00 pc: 024E sp: FD x: 2A y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 22 p: 81 pc: 0250 sp: FD x: 2A y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 22 p: 81 pc: 0252 sp: FD x: 2A y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 22 p: 00 pc: 0254 sp: FD x: 2A y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 44 p: 00 pc: 0255 sp: FD x: 2A y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 44 p: 00 pc: 024E sp: FD x: 2A y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 44 p: 81 pc: 0250 sp: FD x: 2A y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 44 p: 81 pc: 0252 sp: FD x: 2A y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 44 p: 00 pc: 0254 sp: FD x: 2A y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 88 p: 80 pc: 0255 sp: FD x: 2A y: 06 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 88 p: 80 pc: 0257 sp: FD x: 2A y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 88 p: 80 pc: 0259 sp: FD x: 2A y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: BF p: 80 pc: 025B sp: FD x: 2A y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: BF p: 00 pc: 025D sp: FD x: 2A y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: BF p: 00 pc: 025F sp: FD x: 2A y: 06 
---
[1]    55 0261: 	sec
[2] a: BF p: 80 pc: 0261 sp: FD x: 2A y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: BF p: 81 pc: 0262 sp: FD x: 2A y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 37 p: 00 pc: 0264 sp: FD x: 2A y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 37 p: 00 pc: 0266 sp: FD x: 2A y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2A y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 2A y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 2A y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 2A y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 2A y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 2A y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 2A y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 81 pc: 025D sp: FD x: 2A y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 37 p: 81 pc: 026C sp: FD x: 2A y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 37 p: 00 pc: 026E sp: FD x: 2A y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 37 p: 00 pc: 0270 sp: FD x: 2A y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 37 p: 00 pc: 0259 sp: FD x: 2A y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 2A y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 00 pc: 025D sp: FD x: 2A y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 37 p: 00 pc: 025F sp: FD x: 2A y: 06 
---
[1]    55 0261: 	sec
[2] a: 37 p: 00 pc: 0261 sp: FD x: 2A y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 37 p: 01 pc: 0262 sp: FD x: 2A y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 2A y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 2A y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 2A y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 2A y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 2A y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 2A y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 2A y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 2A y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 2A y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 2A y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 2A y: 06 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 2A y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 2A y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 2A y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 2A y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 2A y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 2A y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 2A y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 2A y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 2A y: 06 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 2A y: 06 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 2A y: 06 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 2A y: 06 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 2A y: 06 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 11 p: 01 pc: 0227 sp: FF x: 2A y: 06 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 11 p: 00 pc: 0229 sp: FF x: 2A y: 06 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 11 p: 00 pc: 022E sp: FF x: 2A y: 06 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: BF p: 80 pc: 0231 sp: FF x: 2A y: 06 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: BF p: 00 pc: 0232 sp: FF x: 2B y: 06 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: BF p: 00 pc: 0235 sp: FF x: 2B y: 06 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: BF p: 80 pc: 0238 sp: FF x: 2B y: 06 
---
[1]    34 023B: 	lda pstore, x
[2] a: BF p: 80 pc: 023B sp: FF x: 2B y: 06 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: C1 p: 80 pc: 023E sp: FF x: 2B y: 06 
---
[1]    36 0240: 	bmi checkp
[2] a: C1 p: 81 pc: 0240 sp: FF x: 2B y: 06 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: C1 p: 81 pc: 0211 sp: FF x: 2B y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: C1 p: 01 pc: 0213 sp: FF x: 2B y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: C1 p: 81 pc: 0216 sp: FF x: 2B y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: C1 p: 81 pc: 0218 sp: FF x: 2B y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2B y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2B y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2B y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2B y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2B y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2B y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2B y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2B y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2B y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2B y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2B y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2B y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C1 p: 80 pc: 025B sp: FD x: 2B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C1 p: 00 pc: 025D sp: FD x: 2B y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: C1 p: 00 pc: 025F sp: FD x: 2B y: 01 
---
[1]    55 0261: 	sec
[2] a: C1 p: 80 pc: 0261 sp: FD x: 2B y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C1 p: 81 pc: 0262 sp: FD x: 2B y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2B y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2B y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2B y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 2B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 2B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 2B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 2B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 2B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 2B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 2B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 2B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 2B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 2B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 2B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 2B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 2B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 2B y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 2B y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2B y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2B y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2B y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2B y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2B y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2B y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2B y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2B y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2B y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2B y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2B y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2B y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2B y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2B y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: C1 p: 81 pc: 0216 sp: FF x: 2B y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: C1 p: 81 pc: 0218 sp: FF x: 2B y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2B y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2B y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2B y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2B y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2B y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2B y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2B y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2B y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2B y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2B y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2B y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2B y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C1 p: 80 pc: 025B sp: FD x: 2B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C1 p: 00 pc: 025D sp: FD x: 2B y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: C1 p: 00 pc: 025F sp: FD x: 2B y: 02 
---
[1]    55 0261: 	sec
[2] a: C1 p: 80 pc: 0261 sp: FD x: 2B y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C1 p: 81 pc: 0262 sp: FD x: 2B y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 2B y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 2B y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2B y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 2B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 2B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 2B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 2B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 2B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 2B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 2B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 2B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 2B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 2B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 2B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 2B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 2B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 2B y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 2B y: 02 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 2B y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 2B y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 2B y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 2B y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2B y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 2B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 2B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 2B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 2B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 2B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 2B y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 2B y: 02 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 2B y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 2B y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2B y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2B y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 24 p: 00 pc: 0268 sp: FD x: 2B y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 26 p: 00 pc: 026A sp: FD x: 2B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 26 p: 00 pc: 026C sp: FD x: 2B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 26 p: 00 pc: 026E sp: FD x: 2B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 26 p: 00 pc: 0270 sp: FD x: 2B y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 26 p: 00 pc: 0259 sp: FD x: 2B y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2B y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2B y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2B y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 2B y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 2B y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 2B y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 2B y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 2B y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 2B y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 2B y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 2B y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 2B y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 2B y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 2B y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: C1 p: 81 pc: 0216 sp: FF x: 2B y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: C1 p: 81 pc: 0218 sp: FF x: 2B y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 2B y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 2B y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 2B y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2B y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2B y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2B y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 2B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 2B y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 2B y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 2B y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 2B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 2B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 2B y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 2B y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 2B y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 2B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 2B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 2B y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 2B y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 2B y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 2B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 2B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 2B y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 2B y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 2B y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 2B y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 2B y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 2B y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 2B y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 2B y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 2B y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 2B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 2B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C1 p: 80 pc: 025B sp: FD x: 2B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C1 p: 81 pc: 025D sp: FD x: 2B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: C1 p: 81 pc: 026C sp: FD x: 2B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: C1 p: 00 pc: 026E sp: FD x: 2B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: C1 p: 00 pc: 0270 sp: FD x: 2B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: C1 p: 00 pc: 0259 sp: FD x: 2B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C1 p: 80 pc: 025B sp: FD x: 2B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C1 p: 00 pc: 025D sp: FD x: 2B y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: C1 p: 00 pc: 025F sp: FD x: 2B y: 03 
---
[1]    55 0261: 	sec
[2] a: C1 p: 80 pc: 0261 sp: FD x: 2B y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C1 p: 81 pc: 0262 sp: FD x: 2B y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 51 p: 40 pc: 0264 sp: FD x: 2B y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 51 p: 40 pc: 0266 sp: FD x: 2B y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2B y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 2B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 2B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 2B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 2B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 2B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 51 p: 40 pc: 025B sp: FD x: 2B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 51 p: 40 pc: 025D sp: FD x: 2B y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 51 p: 40 pc: 025F sp: FD x: 2B y: 03 
---
[1]    55 0261: 	sec
[2] a: 51 p: 40 pc: 0261 sp: FD x: 2B y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 51 p: 41 pc: 0262 sp: FD x: 2B y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 2B y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 2B y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2B y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 2B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 2B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 2B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 2B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 2B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 2B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 2B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 2B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 2B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 2B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 2B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 2B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 2B y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 2B y: 03 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 2B y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 2B y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 2B y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 2B y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 2B y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1A p: 00 pc: 026A sp: FD x: 2B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1A p: 00 pc: 026C sp: FD x: 2B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1A p: 00 pc: 026E sp: FD x: 2B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1A p: 00 pc: 0270 sp: FD x: 2B y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1A p: 00 pc: 0259 sp: FD x: 2B y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2B y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 2B y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 2B y: 03 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 2B y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 2B y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 2B y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 2B y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1A p: 00 pc: 0268 sp: FD x: 2B y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1B p: 00 pc: 026A sp: FD x: 2B y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 00 pc: 026C sp: FD x: 2B y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 01 pc: 026E sp: FD x: 2B y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 03 pc: 0270 sp: FD x: 2B y: 03 
---
[1]    64 0272: 	rts
[2] a: 1B p: 03 pc: 0272 sp: FD x: 2B y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1B p: 03 pc: 0220 sp: FF x: 2B y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 2B y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 2B y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 2B y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 2B y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 2B y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 2B y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 2B y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: C1 p: 81 pc: 0216 sp: FF x: 2B y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: C1 p: 81 pc: 0218 sp: FF x: 2B y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 2B y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 2B y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 2B y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2B y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2B y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2B y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2B y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 2B y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 2B y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 2B y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 2B y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 2B y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 2B y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 2B y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 2B y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 2B y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 2B y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 2B y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 2B y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 2B y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 2B y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 2B y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 2B y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 2B y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 2B y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 2B y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 2B y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 2B y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 2B y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C1 p: 80 pc: 025B sp: FD x: 2B y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C1 p: 00 pc: 025D sp: FD x: 2B y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: C1 p: 00 pc: 025F sp: FD x: 2B y: 04 
---
[1]    55 0261: 	sec
[2] a: C1 p: 80 pc: 0261 sp: FD x: 2B y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C1 p: 81 pc: 0262 sp: FD x: 2B y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 2B y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 2B y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2B y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 2B y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 2B y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 2B y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 2B y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 2B y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2B y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 2B y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 2B y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 2B y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 2B y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 2B y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2B y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 2B y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 2B y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 2B y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 2B y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 2B y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2B y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 2B y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 2B y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 2B y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 2B y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 2B y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2B y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 2B y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 2B y: 04 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 2B y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 2B y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 2B y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 2B y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2B y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 2B y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 2B y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 2B y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 2B y: 04 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 2B y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 2B y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 2B y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 2B y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 2B y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 2B y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 2B y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 2B y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 2B y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: C1 p: 81 pc: 0216 sp: FF x: 2B y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: C1 p: 81 pc: 0218 sp: FF x: 2B y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 2B y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 2B y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 2B y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2B y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2B y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2B y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2B y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 2B y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 2B y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 2B y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 2B y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 2B y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 2B y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 2B y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 2B y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 2B y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 2B y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 2B y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 2B y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 2B y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 2B y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 2B y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 2B y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 2B y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 2B y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 2B y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 2B y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 2B y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 2B y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C1 p: 80 pc: 025B sp: FD x: 2B y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C1 p: 81 pc: 025D sp: FD x: 2B y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: C1 p: 81 pc: 026C sp: FD x: 2B y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: C1 p: 00 pc: 026E sp: FD x: 2B y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: C1 p: 00 pc: 0270 sp: FD x: 2B y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: C1 p: 00 pc: 0259 sp: FD x: 2B y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C1 p: 80 pc: 025B sp: FD x: 2B y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C1 p: 00 pc: 025D sp: FD x: 2B y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: C1 p: 00 pc: 025F sp: FD x: 2B y: 05 
---
[1]    55 0261: 	sec
[2] a: C1 p: 80 pc: 0261 sp: FD x: 2B y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C1 p: 81 pc: 0262 sp: FD x: 2B y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 59 p: 40 pc: 0264 sp: FD x: 2B y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 59 p: 40 pc: 0266 sp: FD x: 2B y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2B y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 2B y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 2B y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 2B y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 2B y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 2B y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 59 p: 40 pc: 025B sp: FD x: 2B y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 59 p: 40 pc: 025D sp: FD x: 2B y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 59 p: 40 pc: 025F sp: FD x: 2B y: 05 
---
[1]    55 0261: 	sec
[2] a: 59 p: 40 pc: 0261 sp: FD x: 2B y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 59 p: 41 pc: 0262 sp: FD x: 2B y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 25 p: 00 pc: 0264 sp: FD x: 2B y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 25 p: 00 pc: 0266 sp: FD x: 2B y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 2B y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 2B y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 2B y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 2B y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 2B y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 2B y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 2B y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 2B y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 2B y: 05 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 2B y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 2B y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 2B y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 2B y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 2B y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 2B y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 2B y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 2B y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 2B y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 2B y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2B y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 2B y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 2B y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 2B y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 2B y: 05 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 2B y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 2B y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0B p: 01 pc: 0222 sp: FF x: 2B y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0B p: 01 pc: 0224 sp: FF x: 2B y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 2B y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 81 pc: 0229 sp: FF x: 2B y: 05 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0D p: 81 pc: 022B sp: FF x: 2B y: 05 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0D p: 01 pc: 022C sp: FF x: 2B y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 2B y: 06 
---
[1]    18 0216: 	sta dividend
[2] a: C1 p: 81 pc: 0216 sp: FF x: 2B y: 06 
---
[1]    19 0218: 	lda pstore, y
[2] a: C1 p: 81 pc: 0218 sp: FF x: 2B y: 06 
---
[1]    20 021B: 	sta divisor
[2] a: 11 p: 01 pc: 021B sp: FF x: 2B y: 06 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 11 p: 01 pc: 021D sp: FF x: 2B y: 06 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 11 p: 01 pc: 0244 sp: FD x: 2B y: 06 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2B y: 06 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2B y: 06 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2B y: 06 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2B y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 11 p: 01 pc: 024E sp: FD x: 2B y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 11 p: 81 pc: 0250 sp: FD x: 2B y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 11 p: 81 pc: 0252 sp: FD x: 2B y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 11 p: 00 pc: 0254 sp: FD x: 2B y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 22 p: 00 pc: 0255 sp: FD x: 2B y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 22 p: 00 pc: 024E sp: FD x: 2B y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 22 p: 81 pc: 0250 sp: FD x: 2B y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 22 p: 81 pc: 0252 sp: FD x: 2B y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 22 p: 00 pc: 0254 sp: FD x: 2B y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 44 p: 00 pc: 0255 sp: FD x: 2B y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 44 p: 00 pc: 024E sp: FD x: 2B y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 44 p: 81 pc: 0250 sp: FD x: 2B y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 44 p: 81 pc: 0252 sp: FD x: 2B y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 44 p: 00 pc: 0254 sp: FD x: 2B y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 88 p: 80 pc: 0255 sp: FD x: 2B y: 06 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 88 p: 80 pc: 0257 sp: FD x: 2B y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 88 p: 80 pc: 0259 sp: FD x: 2B y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C1 p: 80 pc: 025B sp: FD x: 2B y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C1 p: 00 pc: 025D sp: FD x: 2B y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: C1 p: 00 pc: 025F sp: FD x: 2B y: 06 
---
[1]    55 0261: 	sec
[2] a: C1 p: 80 pc: 0261 sp: FD x: 2B y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C1 p: 81 pc: 0262 sp: FD x: 2B y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 39 p: 00 pc: 0264 sp: FD x: 2B y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 39 p: 00 pc: 0266 sp: FD x: 2B y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2B y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 2B y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 2B y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 2B y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 2B y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 2B y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 2B y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 81 pc: 025D sp: FD x: 2B y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 39 p: 81 pc: 026C sp: FD x: 2B y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 39 p: 00 pc: 026E sp: FD x: 2B y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 39 p: 00 pc: 0270 sp: FD x: 2B y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 39 p: 00 pc: 0259 sp: FD x: 2B y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 2B y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 00 pc: 025D sp: FD x: 2B y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 39 p: 00 pc: 025F sp: FD x: 2B y: 06 
---
[1]    55 0261: 	sec
[2] a: 39 p: 00 pc: 0261 sp: FD x: 2B y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 39 p: 01 pc: 0262 sp: FD x: 2B y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 2B y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 2B y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 2B y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 2B y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 2B y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 2B y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 2B y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 2B y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 2B y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 2B y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 2B y: 06 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 2B y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 2B y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 2B y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 2B y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 2B y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 2B y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 2B y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 2B y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 2B y: 06 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 2B y: 06 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 2B y: 06 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 2B y: 06 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 2B y: 06 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 11 p: 01 pc: 0227 sp: FF x: 2B y: 06 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 11 p: 00 pc: 0229 sp: FF x: 2B y: 06 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 11 p: 00 pc: 022E sp: FF x: 2B y: 06 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: C1 p: 80 pc: 0231 sp: FF x: 2B y: 06 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: C1 p: 00 pc: 0232 sp: FF x: 2C y: 06 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: C1 p: 00 pc: 0235 sp: FF x: 2C y: 06 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: C1 p: 80 pc: 0238 sp: FF x: 2C y: 06 
---
[1]    34 023B: 	lda pstore, x
[2] a: C1 p: 80 pc: 023B sp: FF x: 2C y: 06 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: C3 p: 80 pc: 023E sp: FF x: 2C y: 06 
---
[1]    36 0240: 	bmi checkp
[2] a: C3 p: 81 pc: 0240 sp: FF x: 2C y: 06 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: C3 p: 81 pc: 0211 sp: FF x: 2C y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: C3 p: 01 pc: 0213 sp: FF x: 2C y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: C3 p: 81 pc: 0216 sp: FF x: 2C y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: C3 p: 81 pc: 0218 sp: FF x: 2C y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2C y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2C y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2C y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2C y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2C y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2C y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2C y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C3 p: 80 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C3 p: 00 pc: 025D sp: FD x: 2C y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: C3 p: 00 pc: 025F sp: FD x: 2C y: 01 
---
[1]    55 0261: 	sec
[2] a: C3 p: 80 pc: 0261 sp: FD x: 2C y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C3 p: 81 pc: 0262 sp: FD x: 2C y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2C y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2C y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2C y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 2C y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 2C y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 2C y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 2C y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2C y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2C y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2C y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 41 p: 00 pc: 026A sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 41 p: 00 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 41 p: 01 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 41 p: 03 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    64 0272: 	rts
[2] a: 41 p: 03 pc: 0272 sp: FD x: 2C y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 41 p: 03 pc: 0220 sp: FF x: 2C y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2C y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2C y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2C y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2C y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: C5 p: 81 pc: 023E sp: FF x: 2C y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: C5 p: 81 pc: 0240 sp: FF x: 2C y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: C5 p: 81 pc: 0211 sp: FF x: 2C y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: C5 p: 01 pc: 0213 sp: FF x: 2C y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: C5 p: 81 pc: 0216 sp: FF x: 2C y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: C5 p: 81 pc: 0218 sp: FF x: 2C y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2C y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2C y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2C y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2C y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2C y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2C y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2C y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2C y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2C y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2C y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2C y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2C y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C5 p: 80 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C5 p: 00 pc: 025D sp: FD x: 2C y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: C5 p: 00 pc: 025F sp: FD x: 2C y: 01 
---
[1]    55 0261: 	sec
[2] a: C5 p: 80 pc: 0261 sp: FD x: 2C y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C5 p: 81 pc: 0262 sp: FD x: 2C y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 2C y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 2C y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2C y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 2C y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2C y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 2C y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 2C y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 2C y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 2C y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2C y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2C y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2C y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 41 p: 00 pc: 026A sp: FD x: 2C y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 41 p: 00 pc: 026C sp: FD x: 2C y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 41 p: 01 pc: 026E sp: FD x: 2C y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 41 p: 03 pc: 0270 sp: FD x: 2C y: 01 
---
[1]    64 0272: 	rts
[2] a: 41 p: 03 pc: 0272 sp: FD x: 2C y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 41 p: 03 pc: 0220 sp: FF x: 2C y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2C y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2C y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2C y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2C y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2C y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2C y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2C y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: C5 p: 81 pc: 0216 sp: FF x: 2C y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: C5 p: 81 pc: 0218 sp: FF x: 2C y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2C y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2C y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2C y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2C y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2C y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2C y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2C y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2C y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2C y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2C y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2C y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2C y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C5 p: 80 pc: 025B sp: FD x: 2C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C5 p: 00 pc: 025D sp: FD x: 2C y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: C5 p: 00 pc: 025F sp: FD x: 2C y: 02 
---
[1]    55 0261: 	sec
[2] a: C5 p: 80 pc: 0261 sp: FD x: 2C y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C5 p: 81 pc: 0262 sp: FD x: 2C y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 25 p: 00 pc: 0264 sp: FD x: 2C y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 25 p: 00 pc: 0266 sp: FD x: 2C y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2C y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 2C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 81 pc: 025D sp: FD x: 2C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 81 pc: 026C sp: FD x: 2C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 00 pc: 026E sp: FD x: 2C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 00 pc: 0270 sp: FD x: 2C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 25 p: 00 pc: 0259 sp: FD x: 2C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 2C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 81 pc: 025D sp: FD x: 2C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 81 pc: 026C sp: FD x: 2C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 00 pc: 026E sp: FD x: 2C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 00 pc: 0270 sp: FD x: 2C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 25 p: 00 pc: 0259 sp: FD x: 2C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 2C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 2C y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 2C y: 02 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 2C y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 2C y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 2C y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 2C y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2C y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 2C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 2C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 2C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 2C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 2C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 2C y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 2C y: 02 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 2C y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 2C y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 2C y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 2C y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 24 p: 00 pc: 0268 sp: FD x: 2C y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 26 p: 00 pc: 026A sp: FD x: 2C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 26 p: 00 pc: 026C sp: FD x: 2C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 26 p: 00 pc: 026E sp: FD x: 2C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 26 p: 00 pc: 0270 sp: FD x: 2C y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 26 p: 00 pc: 0259 sp: FD x: 2C y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2C y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 2C y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 2C y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 2C y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 2C y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2C y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2C y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 26 p: 00 pc: 0268 sp: FD x: 2C y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 27 p: 00 pc: 026A sp: FD x: 2C y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 00 pc: 026C sp: FD x: 2C y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 01 pc: 026E sp: FD x: 2C y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 03 pc: 0270 sp: FD x: 2C y: 02 
---
[1]    64 0272: 	rts
[2] a: 27 p: 03 pc: 0272 sp: FD x: 2C y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 27 p: 03 pc: 0220 sp: FF x: 2C y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2C y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2C y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 2C y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 2C y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 2C y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 2C y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 2C y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: C5 p: 81 pc: 0216 sp: FF x: 2C y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: C5 p: 81 pc: 0218 sp: FF x: 2C y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 2C y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 2C y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 2C y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2C y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2C y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2C y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 2C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 2C y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 2C y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 2C y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 2C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 2C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 2C y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 2C y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 2C y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 2C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 2C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 2C y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 2C y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 2C y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 2C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 2C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 2C y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 2C y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 2C y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 2C y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 2C y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 2C y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 2C y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 2C y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 2C y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 2C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 2C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C5 p: 80 pc: 025B sp: FD x: 2C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C5 p: 81 pc: 025D sp: FD x: 2C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: C5 p: 81 pc: 026C sp: FD x: 2C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: C5 p: 00 pc: 026E sp: FD x: 2C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: C5 p: 00 pc: 0270 sp: FD x: 2C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: C5 p: 00 pc: 0259 sp: FD x: 2C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C5 p: 80 pc: 025B sp: FD x: 2C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C5 p: 00 pc: 025D sp: FD x: 2C y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: C5 p: 00 pc: 025F sp: FD x: 2C y: 03 
---
[1]    55 0261: 	sec
[2] a: C5 p: 80 pc: 0261 sp: FD x: 2C y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C5 p: 81 pc: 0262 sp: FD x: 2C y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 55 p: 40 pc: 0264 sp: FD x: 2C y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 55 p: 40 pc: 0266 sp: FD x: 2C y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2C y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 2C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 2C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 2C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 2C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 2C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 55 p: 40 pc: 025B sp: FD x: 2C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 55 p: 40 pc: 025D sp: FD x: 2C y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 55 p: 40 pc: 025F sp: FD x: 2C y: 03 
---
[1]    55 0261: 	sec
[2] a: 55 p: 40 pc: 0261 sp: FD x: 2C y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 55 p: 41 pc: 0262 sp: FD x: 2C y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 1D p: 00 pc: 0264 sp: FD x: 2C y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 1D p: 00 pc: 0266 sp: FD x: 2C y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2C y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 2C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 2C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 2C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 2C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 2C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 2C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 2C y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 2C y: 03 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 2C y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 2C y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2C y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2C y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 2C y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 2C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 2C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 2C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 2C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 2C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 2C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 2C y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 2C y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2C y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2C y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2C y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2C y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2C y: 03 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2C y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2C y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2C y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2C y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 2C y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 2C y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 2C y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 2C y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 2C y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: C5 p: 81 pc: 0216 sp: FF x: 2C y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: C5 p: 81 pc: 0218 sp: FF x: 2C y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 2C y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 2C y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 2C y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2C y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2C y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2C y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2C y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 2C y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 2C y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 2C y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 2C y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 2C y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 2C y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 2C y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 2C y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 2C y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 2C y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 2C y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 2C y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 2C y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 2C y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 2C y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 2C y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 2C y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 2C y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 2C y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 2C y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 2C y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 2C y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C5 p: 80 pc: 025B sp: FD x: 2C y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C5 p: 00 pc: 025D sp: FD x: 2C y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: C5 p: 00 pc: 025F sp: FD x: 2C y: 04 
---
[1]    55 0261: 	sec
[2] a: C5 p: 80 pc: 0261 sp: FD x: 2C y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C5 p: 81 pc: 0262 sp: FD x: 2C y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 2C y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 2C y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2C y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 2C y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 2C y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 2C y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 2C y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 2C y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 2C y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 2C y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 2C y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 2C y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 2C y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 2C y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 2C y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 2C y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 2C y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 2C y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 2C y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 2C y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 2C y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 2C y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 2C y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 2C y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 2C y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 2C y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 2C y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 2C y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 2C y: 04 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 2C y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 2C y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0A p: 00 pc: 0264 sp: FD x: 2C y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0A p: 00 pc: 0266 sp: FD x: 2C y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2C y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 2C y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 2C y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 2C y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 2C y: 04 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 2C y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 2C y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0A p: 01 pc: 0222 sp: FF x: 2C y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0A p: 01 pc: 0224 sp: FF x: 2C y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 2C y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 2C y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 2C y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 2C y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 2C y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: C5 p: 81 pc: 0216 sp: FF x: 2C y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: C5 p: 81 pc: 0218 sp: FF x: 2C y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 2C y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 2C y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 2C y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2C y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2C y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2C y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2C y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 2C y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 2C y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 2C y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 2C y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 2C y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 2C y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 2C y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 2C y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 2C y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 2C y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 2C y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 2C y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 2C y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 2C y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 2C y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 2C y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 2C y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 2C y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 2C y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 2C y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 2C y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 2C y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C5 p: 80 pc: 025B sp: FD x: 2C y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C5 p: 81 pc: 025D sp: FD x: 2C y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: C5 p: 81 pc: 026C sp: FD x: 2C y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: C5 p: 00 pc: 026E sp: FD x: 2C y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: C5 p: 00 pc: 0270 sp: FD x: 2C y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: C5 p: 00 pc: 0259 sp: FD x: 2C y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C5 p: 80 pc: 025B sp: FD x: 2C y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C5 p: 00 pc: 025D sp: FD x: 2C y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: C5 p: 00 pc: 025F sp: FD x: 2C y: 05 
---
[1]    55 0261: 	sec
[2] a: C5 p: 80 pc: 0261 sp: FD x: 2C y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C5 p: 81 pc: 0262 sp: FD x: 2C y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 5D p: 40 pc: 0264 sp: FD x: 2C y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 5D p: 40 pc: 0266 sp: FD x: 2C y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2C y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 2C y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 2C y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 2C y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 2C y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 2C y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5D p: 40 pc: 025B sp: FD x: 2C y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5D p: 40 pc: 025D sp: FD x: 2C y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 5D p: 40 pc: 025F sp: FD x: 2C y: 05 
---
[1]    55 0261: 	sec
[2] a: 5D p: 40 pc: 0261 sp: FD x: 2C y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5D p: 41 pc: 0262 sp: FD x: 2C y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 29 p: 00 pc: 0264 sp: FD x: 2C y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 29 p: 00 pc: 0266 sp: FD x: 2C y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 2C y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 2C y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 2C y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 2C y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 2C y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 2C y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 2C y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 00 pc: 025D sp: FD x: 2C y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 29 p: 00 pc: 025F sp: FD x: 2C y: 05 
---
[1]    55 0261: 	sec
[2] a: 29 p: 00 pc: 0261 sp: FD x: 2C y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 29 p: 01 pc: 0262 sp: FD x: 2C y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 2C y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 2C y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 2C y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 2C y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 2C y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 2C y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 2C y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 2C y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2C y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 2C y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 2C y: 05 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 2C y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 2C y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2C y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2C y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0E p: 00 pc: 0268 sp: FD x: 2C y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0F p: 00 pc: 026A sp: FD x: 2C y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 00 pc: 026C sp: FD x: 2C y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 01 pc: 026E sp: FD x: 2C y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 03 pc: 0270 sp: FD x: 2C y: 05 
---
[1]    64 0272: 	rts
[2] a: 0F p: 03 pc: 0272 sp: FD x: 2C y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0F p: 03 pc: 0220 sp: FF x: 2C y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2C y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2C y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 2C y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 81 pc: 0229 sp: FF x: 2C y: 05 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0D p: 81 pc: 022B sp: FF x: 2C y: 05 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0D p: 01 pc: 022C sp: FF x: 2C y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 2C y: 06 
---
[1]    18 0216: 	sta dividend
[2] a: C5 p: 81 pc: 0216 sp: FF x: 2C y: 06 
---
[1]    19 0218: 	lda pstore, y
[2] a: C5 p: 81 pc: 0218 sp: FF x: 2C y: 06 
---
[1]    20 021B: 	sta divisor
[2] a: 11 p: 01 pc: 021B sp: FF x: 2C y: 06 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 11 p: 01 pc: 021D sp: FF x: 2C y: 06 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 11 p: 01 pc: 0244 sp: FD x: 2C y: 06 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2C y: 06 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2C y: 06 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2C y: 06 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2C y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 11 p: 01 pc: 024E sp: FD x: 2C y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 11 p: 81 pc: 0250 sp: FD x: 2C y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 11 p: 81 pc: 0252 sp: FD x: 2C y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 11 p: 00 pc: 0254 sp: FD x: 2C y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 22 p: 00 pc: 0255 sp: FD x: 2C y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 22 p: 00 pc: 024E sp: FD x: 2C y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 22 p: 81 pc: 0250 sp: FD x: 2C y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 22 p: 81 pc: 0252 sp: FD x: 2C y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 22 p: 00 pc: 0254 sp: FD x: 2C y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 44 p: 00 pc: 0255 sp: FD x: 2C y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 44 p: 00 pc: 024E sp: FD x: 2C y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 44 p: 81 pc: 0250 sp: FD x: 2C y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 44 p: 81 pc: 0252 sp: FD x: 2C y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 44 p: 00 pc: 0254 sp: FD x: 2C y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 88 p: 80 pc: 0255 sp: FD x: 2C y: 06 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 88 p: 80 pc: 0257 sp: FD x: 2C y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 88 p: 80 pc: 0259 sp: FD x: 2C y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C5 p: 80 pc: 025B sp: FD x: 2C y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C5 p: 00 pc: 025D sp: FD x: 2C y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: C5 p: 00 pc: 025F sp: FD x: 2C y: 06 
---
[1]    55 0261: 	sec
[2] a: C5 p: 80 pc: 0261 sp: FD x: 2C y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C5 p: 81 pc: 0262 sp: FD x: 2C y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 3D p: 00 pc: 0264 sp: FD x: 2C y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 3D p: 00 pc: 0266 sp: FD x: 2C y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2C y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 2C y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 2C y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 2C y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 2C y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 2C y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 2C y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 81 pc: 025D sp: FD x: 2C y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3D p: 81 pc: 026C sp: FD x: 2C y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 3D p: 00 pc: 026E sp: FD x: 2C y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3D p: 00 pc: 0270 sp: FD x: 2C y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3D p: 00 pc: 0259 sp: FD x: 2C y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 2C y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 00 pc: 025D sp: FD x: 2C y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 3D p: 00 pc: 025F sp: FD x: 2C y: 06 
---
[1]    55 0261: 	sec
[2] a: 3D p: 00 pc: 0261 sp: FD x: 2C y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3D p: 01 pc: 0262 sp: FD x: 2C y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 2C y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 2C y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 2C y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 2C y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 2C y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 2C y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 2C y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 2C y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 2C y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 2C y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 2C y: 06 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 2C y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 2C y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 0A p: 00 pc: 0264 sp: FD x: 2C y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 0A p: 00 pc: 0266 sp: FD x: 2C y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 2C y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 2C y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 2C y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 2C y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 2C y: 06 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 2C y: 06 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 2C y: 06 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0A p: 01 pc: 0222 sp: FF x: 2C y: 06 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0A p: 01 pc: 0224 sp: FF x: 2C y: 06 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 11 p: 01 pc: 0227 sp: FF x: 2C y: 06 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 11 p: 00 pc: 0229 sp: FF x: 2C y: 06 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 11 p: 00 pc: 022E sp: FF x: 2C y: 06 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: C5 p: 80 pc: 0231 sp: FF x: 2C y: 06 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: C5 p: 00 pc: 0232 sp: FF x: 2D y: 06 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: C5 p: 00 pc: 0235 sp: FF x: 2D y: 06 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: C5 p: 80 pc: 0238 sp: FF x: 2D y: 06 
---
[1]    34 023B: 	lda pstore, x
[2] a: C5 p: 80 pc: 023B sp: FF x: 2D y: 06 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: C7 p: 80 pc: 023E sp: FF x: 2D y: 06 
---
[1]    36 0240: 	bmi checkp
[2] a: C7 p: 81 pc: 0240 sp: FF x: 2D y: 06 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: C7 p: 81 pc: 0211 sp: FF x: 2D y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: C7 p: 01 pc: 0213 sp: FF x: 2D y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: C7 p: 81 pc: 0216 sp: FF x: 2D y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: C7 p: 81 pc: 0218 sp: FF x: 2D y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2D y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2D y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2D y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2D y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2D y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2D y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2D y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2D y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2D y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2D y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2D y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2D y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C7 p: 80 pc: 025B sp: FD x: 2D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C7 p: 00 pc: 025D sp: FD x: 2D y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: C7 p: 00 pc: 025F sp: FD x: 2D y: 01 
---
[1]    55 0261: 	sec
[2] a: C7 p: 80 pc: 0261 sp: FD x: 2D y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C7 p: 81 pc: 0262 sp: FD x: 2D y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 2D y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 2D y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2D y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 2D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 2D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 2D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 2D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 2D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 2D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 2D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 2D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 2D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 2D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 2D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 2D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 2D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 2D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 2D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 2D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 2D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 2D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 2D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 2D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 2D y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 2D y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 2D y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 2D y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2D y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2D y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2D y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 42 p: 00 pc: 026A sp: FD x: 2D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 42 p: 00 pc: 026C sp: FD x: 2D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 42 p: 00 pc: 026E sp: FD x: 2D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 42 p: 00 pc: 0270 sp: FD x: 2D y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 42 p: 00 pc: 0259 sp: FD x: 2D y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2D y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2D y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2D y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2D y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2D y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2D y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2D y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2D y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2D y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2D y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2D y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2D y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2D y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2D y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: C7 p: 81 pc: 0216 sp: FF x: 2D y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: C7 p: 81 pc: 0218 sp: FF x: 2D y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2D y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2D y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2D y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2D y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2D y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2D y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2D y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2D y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2D y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2D y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2D y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2D y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C7 p: 80 pc: 025B sp: FD x: 2D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C7 p: 00 pc: 025D sp: FD x: 2D y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: C7 p: 00 pc: 025F sp: FD x: 2D y: 02 
---
[1]    55 0261: 	sec
[2] a: C7 p: 80 pc: 0261 sp: FD x: 2D y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C7 p: 81 pc: 0262 sp: FD x: 2D y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 27 p: 00 pc: 0264 sp: FD x: 2D y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 27 p: 00 pc: 0266 sp: FD x: 2D y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2D y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 2D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 81 pc: 025D sp: FD x: 2D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 81 pc: 026C sp: FD x: 2D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 00 pc: 026E sp: FD x: 2D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 00 pc: 0270 sp: FD x: 2D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 27 p: 00 pc: 0259 sp: FD x: 2D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 2D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 81 pc: 025D sp: FD x: 2D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 81 pc: 026C sp: FD x: 2D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 00 pc: 026E sp: FD x: 2D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 00 pc: 0270 sp: FD x: 2D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 27 p: 00 pc: 0259 sp: FD x: 2D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 2D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 2D y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 2D y: 02 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 2D y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 2D y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 2D y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 2D y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2D y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 2D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 2D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 2D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 2D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 2D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 2D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 2D y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 2D y: 02 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 2D y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 2D y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 2D y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 2D y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 24 p: 00 pc: 0268 sp: FD x: 2D y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 26 p: 00 pc: 026A sp: FD x: 2D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 26 p: 00 pc: 026C sp: FD x: 2D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 26 p: 00 pc: 026E sp: FD x: 2D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 26 p: 00 pc: 0270 sp: FD x: 2D y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 26 p: 00 pc: 0259 sp: FD x: 2D y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2D y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 2D y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 2D y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 2D y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 2D y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 2D y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 2D y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 26 p: 00 pc: 0268 sp: FD x: 2D y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 27 p: 00 pc: 026A sp: FD x: 2D y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 00 pc: 026C sp: FD x: 2D y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 01 pc: 026E sp: FD x: 2D y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 03 pc: 0270 sp: FD x: 2D y: 02 
---
[1]    64 0272: 	rts
[2] a: 27 p: 03 pc: 0272 sp: FD x: 2D y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 27 p: 03 pc: 0220 sp: FF x: 2D y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 2D y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 2D y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 2D y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 2D y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 2D y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 2D y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 2D y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: C7 p: 81 pc: 0216 sp: FF x: 2D y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: C7 p: 81 pc: 0218 sp: FF x: 2D y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 2D y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 2D y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 2D y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2D y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2D y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2D y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 2D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 2D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 2D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 2D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 2D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 2D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 2D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 2D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 2D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 2D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 2D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 2D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 2D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 2D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 2D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 2D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 2D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 2D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 2D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 2D y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 2D y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 2D y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 2D y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 2D y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 2D y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 2D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 2D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C7 p: 80 pc: 025B sp: FD x: 2D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C7 p: 81 pc: 025D sp: FD x: 2D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: C7 p: 81 pc: 026C sp: FD x: 2D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: C7 p: 00 pc: 026E sp: FD x: 2D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: C7 p: 00 pc: 0270 sp: FD x: 2D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: C7 p: 00 pc: 0259 sp: FD x: 2D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C7 p: 80 pc: 025B sp: FD x: 2D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C7 p: 00 pc: 025D sp: FD x: 2D y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: C7 p: 00 pc: 025F sp: FD x: 2D y: 03 
---
[1]    55 0261: 	sec
[2] a: C7 p: 80 pc: 0261 sp: FD x: 2D y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C7 p: 81 pc: 0262 sp: FD x: 2D y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 57 p: 40 pc: 0264 sp: FD x: 2D y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 57 p: 40 pc: 0266 sp: FD x: 2D y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2D y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 2D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 2D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 2D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 2D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 2D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 57 p: 40 pc: 025B sp: FD x: 2D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 57 p: 40 pc: 025D sp: FD x: 2D y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 57 p: 40 pc: 025F sp: FD x: 2D y: 03 
---
[1]    55 0261: 	sec
[2] a: 57 p: 40 pc: 0261 sp: FD x: 2D y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 57 p: 41 pc: 0262 sp: FD x: 2D y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 1F p: 00 pc: 0264 sp: FD x: 2D y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 1F p: 00 pc: 0266 sp: FD x: 2D y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2D y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 2D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 2D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 2D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 2D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 2D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 2D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 2D y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 2D y: 03 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 2D y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 2D y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2D y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2D y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 2D y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 2D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 2D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 2D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 2D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 2D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2D y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2D y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2D y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2D y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2D y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 2D y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 2D y: 03 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 2D y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 2D y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 2D y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 2D y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 2D y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 2D y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 2D y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 2D y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 2D y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: C7 p: 81 pc: 0216 sp: FF x: 2D y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: C7 p: 81 pc: 0218 sp: FF x: 2D y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 2D y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 2D y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 2D y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2D y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2D y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2D y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2D y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 2D y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 2D y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 2D y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 2D y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 2D y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 2D y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 2D y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 2D y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 2D y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 2D y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 2D y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 2D y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 2D y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 2D y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 2D y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 2D y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 2D y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 2D y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 2D y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 2D y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 2D y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 2D y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C7 p: 80 pc: 025B sp: FD x: 2D y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C7 p: 00 pc: 025D sp: FD x: 2D y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: C7 p: 00 pc: 025F sp: FD x: 2D y: 04 
---
[1]    55 0261: 	sec
[2] a: C7 p: 80 pc: 0261 sp: FD x: 2D y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C7 p: 81 pc: 0262 sp: FD x: 2D y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 2D y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 2D y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2D y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 2D y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 2D y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 2D y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 2D y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 2D y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 2D y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 2D y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 2D y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 2D y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 2D y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 2D y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 2D y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 2D y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 2D y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 2D y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 2D y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 2D y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 2D y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 2D y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 2D y: 04 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 2D y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 2D y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2D y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2D y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2D y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 2D y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 2D y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 2D y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 2D y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 2D y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2D y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2D y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2D y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2D y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2D y: 04 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2D y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2D y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2D y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2D y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 2D y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 2D y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 2D y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 2D y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 2D y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: C7 p: 81 pc: 0216 sp: FF x: 2D y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: C7 p: 81 pc: 0218 sp: FF x: 2D y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 2D y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 2D y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 2D y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2D y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2D y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2D y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2D y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 2D y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 2D y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 2D y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 2D y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 2D y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 2D y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 2D y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 2D y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 2D y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 2D y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 2D y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 2D y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 2D y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 2D y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 2D y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 2D y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 2D y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 2D y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 2D y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 2D y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 2D y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 2D y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C7 p: 80 pc: 025B sp: FD x: 2D y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C7 p: 81 pc: 025D sp: FD x: 2D y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: C7 p: 81 pc: 026C sp: FD x: 2D y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: C7 p: 00 pc: 026E sp: FD x: 2D y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: C7 p: 00 pc: 0270 sp: FD x: 2D y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: C7 p: 00 pc: 0259 sp: FD x: 2D y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C7 p: 80 pc: 025B sp: FD x: 2D y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C7 p: 00 pc: 025D sp: FD x: 2D y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: C7 p: 00 pc: 025F sp: FD x: 2D y: 05 
---
[1]    55 0261: 	sec
[2] a: C7 p: 80 pc: 0261 sp: FD x: 2D y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C7 p: 81 pc: 0262 sp: FD x: 2D y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 5F p: 40 pc: 0264 sp: FD x: 2D y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 5F p: 40 pc: 0266 sp: FD x: 2D y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2D y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 2D y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 2D y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 2D y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 2D y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 2D y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5F p: 40 pc: 025B sp: FD x: 2D y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5F p: 40 pc: 025D sp: FD x: 2D y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 5F p: 40 pc: 025F sp: FD x: 2D y: 05 
---
[1]    55 0261: 	sec
[2] a: 5F p: 40 pc: 0261 sp: FD x: 2D y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5F p: 41 pc: 0262 sp: FD x: 2D y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 2B p: 00 pc: 0264 sp: FD x: 2D y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 2B p: 00 pc: 0266 sp: FD x: 2D y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 2D y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 2D y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 2D y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 2D y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 2D y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 2D y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 2D y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 00 pc: 025D sp: FD x: 2D y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 2B p: 00 pc: 025F sp: FD x: 2D y: 05 
---
[1]    55 0261: 	sec
[2] a: 2B p: 00 pc: 0261 sp: FD x: 2D y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2B p: 01 pc: 0262 sp: FD x: 2D y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 2D y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 2D y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 2D y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 2D y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 2D y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 2D y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 2D y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 2D y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2D y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 2D y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 2D y: 05 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 2D y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 2D y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 2D y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 2D y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0E p: 00 pc: 0268 sp: FD x: 2D y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0F p: 00 pc: 026A sp: FD x: 2D y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 00 pc: 026C sp: FD x: 2D y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 01 pc: 026E sp: FD x: 2D y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 03 pc: 0270 sp: FD x: 2D y: 05 
---
[1]    64 0272: 	rts
[2] a: 0F p: 03 pc: 0272 sp: FD x: 2D y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0F p: 03 pc: 0220 sp: FF x: 2D y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 2D y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 2D y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 2D y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 81 pc: 0229 sp: FF x: 2D y: 05 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0D p: 81 pc: 022B sp: FF x: 2D y: 05 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0D p: 01 pc: 022C sp: FF x: 2D y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 2D y: 06 
---
[1]    18 0216: 	sta dividend
[2] a: C7 p: 81 pc: 0216 sp: FF x: 2D y: 06 
---
[1]    19 0218: 	lda pstore, y
[2] a: C7 p: 81 pc: 0218 sp: FF x: 2D y: 06 
---
[1]    20 021B: 	sta divisor
[2] a: 11 p: 01 pc: 021B sp: FF x: 2D y: 06 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 11 p: 01 pc: 021D sp: FF x: 2D y: 06 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 11 p: 01 pc: 0244 sp: FD x: 2D y: 06 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2D y: 06 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2D y: 06 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2D y: 06 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2D y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 11 p: 01 pc: 024E sp: FD x: 2D y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 11 p: 81 pc: 0250 sp: FD x: 2D y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 11 p: 81 pc: 0252 sp: FD x: 2D y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 11 p: 00 pc: 0254 sp: FD x: 2D y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 22 p: 00 pc: 0255 sp: FD x: 2D y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 22 p: 00 pc: 024E sp: FD x: 2D y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 22 p: 81 pc: 0250 sp: FD x: 2D y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 22 p: 81 pc: 0252 sp: FD x: 2D y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 22 p: 00 pc: 0254 sp: FD x: 2D y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 44 p: 00 pc: 0255 sp: FD x: 2D y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 44 p: 00 pc: 024E sp: FD x: 2D y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 44 p: 81 pc: 0250 sp: FD x: 2D y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 44 p: 81 pc: 0252 sp: FD x: 2D y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 44 p: 00 pc: 0254 sp: FD x: 2D y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 88 p: 80 pc: 0255 sp: FD x: 2D y: 06 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 88 p: 80 pc: 0257 sp: FD x: 2D y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 88 p: 80 pc: 0259 sp: FD x: 2D y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C7 p: 80 pc: 025B sp: FD x: 2D y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C7 p: 00 pc: 025D sp: FD x: 2D y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: C7 p: 00 pc: 025F sp: FD x: 2D y: 06 
---
[1]    55 0261: 	sec
[2] a: C7 p: 80 pc: 0261 sp: FD x: 2D y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C7 p: 81 pc: 0262 sp: FD x: 2D y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 3F p: 00 pc: 0264 sp: FD x: 2D y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 3F p: 00 pc: 0266 sp: FD x: 2D y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2D y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 00 pc: 026A sp: FD x: 2D y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 00 pc: 026C sp: FD x: 2D y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 00 pc: 026E sp: FD x: 2D y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 00 pc: 0270 sp: FD x: 2D y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 00 pc: 0259 sp: FD x: 2D y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3F p: 00 pc: 025B sp: FD x: 2D y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3F p: 81 pc: 025D sp: FD x: 2D y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3F p: 81 pc: 026C sp: FD x: 2D y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 3F p: 00 pc: 026E sp: FD x: 2D y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3F p: 00 pc: 0270 sp: FD x: 2D y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3F p: 00 pc: 0259 sp: FD x: 2D y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3F p: 00 pc: 025B sp: FD x: 2D y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3F p: 00 pc: 025D sp: FD x: 2D y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 3F p: 00 pc: 025F sp: FD x: 2D y: 06 
---
[1]    55 0261: 	sec
[2] a: 3F p: 00 pc: 0261 sp: FD x: 2D y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3F p: 01 pc: 0262 sp: FD x: 2D y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 1D p: 00 pc: 0264 sp: FD x: 2D y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 1D p: 00 pc: 0266 sp: FD x: 2D y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 2D y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0A p: 00 pc: 026A sp: FD x: 2D y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0A p: 00 pc: 026C sp: FD x: 2D y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0A p: 00 pc: 026E sp: FD x: 2D y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0A p: 00 pc: 0270 sp: FD x: 2D y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0A p: 00 pc: 0259 sp: FD x: 2D y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 2D y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 2D y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 2D y: 06 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 2D y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 2D y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 0C p: 00 pc: 0264 sp: FD x: 2D y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 0C p: 00 pc: 0266 sp: FD x: 2D y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0A p: 00 pc: 0268 sp: FD x: 2D y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0B p: 00 pc: 026A sp: FD x: 2D y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 00 pc: 026C sp: FD x: 2D y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 01 pc: 026E sp: FD x: 2D y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 03 pc: 0270 sp: FD x: 2D y: 06 
---
[1]    64 0272: 	rts
[2] a: 0B p: 03 pc: 0272 sp: FD x: 2D y: 06 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0B p: 03 pc: 0220 sp: FF x: 2D y: 06 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0C p: 01 pc: 0222 sp: FF x: 2D y: 06 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0C p: 01 pc: 0224 sp: FF x: 2D y: 06 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 11 p: 01 pc: 0227 sp: FF x: 2D y: 06 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 11 p: 00 pc: 0229 sp: FF x: 2D y: 06 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 11 p: 00 pc: 022E sp: FF x: 2D y: 06 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: C7 p: 80 pc: 0231 sp: FF x: 2D y: 06 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: C7 p: 00 pc: 0232 sp: FF x: 2E y: 06 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: C7 p: 00 pc: 0235 sp: FF x: 2E y: 06 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: C7 p: 80 pc: 0238 sp: FF x: 2E y: 06 
---
[1]    34 023B: 	lda pstore, x
[2] a: C7 p: 80 pc: 023B sp: FF x: 2E y: 06 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: C9 p: 80 pc: 023E sp: FF x: 2E y: 06 
---
[1]    36 0240: 	bmi checkp
[2] a: C9 p: 81 pc: 0240 sp: FF x: 2E y: 06 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: C9 p: 81 pc: 0211 sp: FF x: 2E y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: C9 p: 01 pc: 0213 sp: FF x: 2E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: C9 p: 81 pc: 0216 sp: FF x: 2E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: C9 p: 81 pc: 0218 sp: FF x: 2E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: C9 p: 80 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: C9 p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: C9 p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: C9 p: 80 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: C9 p: 81 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 42 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 42 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 42 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 42 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 42 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 42 p: 00 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 43 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 43 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 43 p: 01 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 43 p: 03 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    64 0272: 	rts
[2] a: 43 p: 03 pc: 0272 sp: FD x: 2E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 43 p: 03 pc: 0220 sp: FF x: 2E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2E y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2E y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2E y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2E y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: CB p: 81 pc: 023E sp: FF x: 2E y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: CB p: 81 pc: 0240 sp: FF x: 2E y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: CB p: 81 pc: 0211 sp: FF x: 2E y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: CB p: 01 pc: 0213 sp: FF x: 2E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: CB p: 81 pc: 0216 sp: FF x: 2E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: CB p: 81 pc: 0218 sp: FF x: 2E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: CB p: 80 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: CB p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: CB p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: CB p: 80 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: CB p: 81 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 42 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 42 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 42 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 42 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 42 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 42 p: 00 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 43 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 43 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 43 p: 01 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 43 p: 03 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    64 0272: 	rts
[2] a: 43 p: 03 pc: 0272 sp: FD x: 2E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 43 p: 03 pc: 0220 sp: FF x: 2E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2E y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2E y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2E y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2E y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2E y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2E y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: CB p: 81 pc: 0216 sp: FF x: 2E y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: CB p: 81 pc: 0218 sp: FF x: 2E y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2E y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2E y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2E y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: CB p: 80 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: CB p: 00 pc: 025D sp: FD x: 2E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: CB p: 00 pc: 025F sp: FD x: 2E y: 02 
---
[1]    55 0261: 	sec
[2] a: CB p: 80 pc: 0261 sp: FD x: 2E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: CB p: 81 pc: 0262 sp: FD x: 2E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 2B p: 00 pc: 0264 sp: FD x: 2E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 2B p: 00 pc: 0266 sp: FD x: 2E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2B p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 00 pc: 025D sp: FD x: 2E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 2B p: 00 pc: 025F sp: FD x: 2E y: 02 
---
[1]    55 0261: 	sec
[2] a: 2B p: 00 pc: 0261 sp: FD x: 2E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2B p: 01 pc: 0262 sp: FD x: 2E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 2E y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 2E y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 2E y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 2E y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 2E y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 2E y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 2E y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 2E y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 2E y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: CB p: 81 pc: 0216 sp: FF x: 2E y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: CB p: 81 pc: 0218 sp: FF x: 2E y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 2E y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 2E y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 2E y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: CB p: 80 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: CB p: 81 pc: 025D sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: CB p: 81 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: CB p: 00 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: CB p: 00 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: CB p: 00 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: CB p: 80 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: CB p: 00 pc: 025D sp: FD x: 2E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: CB p: 00 pc: 025F sp: FD x: 2E y: 03 
---
[1]    55 0261: 	sec
[2] a: CB p: 80 pc: 0261 sp: FD x: 2E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: CB p: 81 pc: 0262 sp: FD x: 2E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 5B p: 40 pc: 0264 sp: FD x: 2E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 5B p: 40 pc: 0266 sp: FD x: 2E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5B p: 40 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5B p: 40 pc: 025D sp: FD x: 2E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 5B p: 40 pc: 025F sp: FD x: 2E y: 03 
---
[1]    55 0261: 	sec
[2] a: 5B p: 40 pc: 0261 sp: FD x: 2E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5B p: 41 pc: 0262 sp: FD x: 2E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 2E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 2E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 2E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 2E y: 03 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 2E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 2E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 2E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 2E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 2E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 02 pc: 025D sp: FD x: 2E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 02 pc: 025F sp: FD x: 2E y: 03 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 2E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 2E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 2E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1D p: 00 pc: 026A sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 00 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 01 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 03 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    64 0272: 	rts
[2] a: 1D p: 03 pc: 0272 sp: FD x: 2E y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1D p: 03 pc: 0220 sp: FF x: 2E y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2E y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2E y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2E y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2E y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: CD p: 81 pc: 023E sp: FF x: 2E y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: CD p: 81 pc: 0240 sp: FF x: 2E y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: CD p: 81 pc: 0211 sp: FF x: 2E y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: CD p: 01 pc: 0213 sp: FF x: 2E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: CD p: 81 pc: 0216 sp: FF x: 2E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: CD p: 81 pc: 0218 sp: FF x: 2E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: CD p: 80 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: CD p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: CD p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: CD p: 80 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: CD p: 81 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 44 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 44 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 44 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 44 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 44 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2E y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2E y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2E y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2E y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2E y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2E y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: CD p: 81 pc: 0216 sp: FF x: 2E y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: CD p: 81 pc: 0218 sp: FF x: 2E y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2E y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2E y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2E y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: CD p: 80 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: CD p: 00 pc: 025D sp: FD x: 2E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: CD p: 00 pc: 025F sp: FD x: 2E y: 02 
---
[1]    55 0261: 	sec
[2] a: CD p: 80 pc: 0261 sp: FD x: 2E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: CD p: 81 pc: 0262 sp: FD x: 2E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 2D p: 00 pc: 0264 sp: FD x: 2E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 2D p: 00 pc: 0266 sp: FD x: 2E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2D p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2D p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2D p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2D p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 00 pc: 025D sp: FD x: 2E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 2D p: 00 pc: 025F sp: FD x: 2E y: 02 
---
[1]    55 0261: 	sec
[2] a: 2D p: 00 pc: 0261 sp: FD x: 2E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2D p: 01 pc: 0262 sp: FD x: 2E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 2E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 2E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 2E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 2E y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 2E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 2E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 2E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 29 p: 00 pc: 026A sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 29 p: 00 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 29 p: 01 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 29 p: 03 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    64 0272: 	rts
[2] a: 29 p: 03 pc: 0272 sp: FD x: 2E y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 29 p: 03 pc: 0220 sp: FF x: 2E y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2E y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2E y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2E y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2E y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: CF p: 81 pc: 023E sp: FF x: 2E y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: CF p: 81 pc: 0240 sp: FF x: 2E y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: CF p: 81 pc: 0211 sp: FF x: 2E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: CF p: 01 pc: 0213 sp: FF x: 2E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: CF p: 81 pc: 0216 sp: FF x: 2E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: CF p: 81 pc: 0218 sp: FF x: 2E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: CF p: 80 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: CF p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: CF p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: CF p: 80 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: CF p: 81 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 44 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 44 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 44 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 44 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 44 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 44 p: 00 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 45 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 45 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 45 p: 01 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 45 p: 03 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    64 0272: 	rts
[2] a: 45 p: 03 pc: 0272 sp: FD x: 2E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 45 p: 03 pc: 0220 sp: FF x: 2E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2E y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2E y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2E y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2E y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: D1 p: 81 pc: 023E sp: FF x: 2E y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: D1 p: 81 pc: 0240 sp: FF x: 2E y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: D1 p: 81 pc: 0211 sp: FF x: 2E y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: D1 p: 01 pc: 0213 sp: FF x: 2E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: D1 p: 81 pc: 0216 sp: FF x: 2E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: D1 p: 81 pc: 0218 sp: FF x: 2E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D1 p: 80 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D1 p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: D1 p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: D1 p: 80 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D1 p: 81 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 44 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 44 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 44 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 44 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 44 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 44 p: 00 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 45 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 45 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 45 p: 01 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 45 p: 03 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    64 0272: 	rts
[2] a: 45 p: 03 pc: 0272 sp: FD x: 2E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 45 p: 03 pc: 0220 sp: FF x: 2E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2E y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2E y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2E y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2E y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2E y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2E y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: D1 p: 81 pc: 0216 sp: FF x: 2E y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: D1 p: 81 pc: 0218 sp: FF x: 2E y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2E y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2E y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2E y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D1 p: 80 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D1 p: 00 pc: 025D sp: FD x: 2E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: D1 p: 00 pc: 025F sp: FD x: 2E y: 02 
---
[1]    55 0261: 	sec
[2] a: D1 p: 80 pc: 0261 sp: FD x: 2E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D1 p: 81 pc: 0262 sp: FD x: 2E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 31 p: 00 pc: 0264 sp: FD x: 2E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 31 p: 00 pc: 0266 sp: FD x: 2E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 31 p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 31 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 31 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 31 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 00 pc: 025D sp: FD x: 2E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 31 p: 00 pc: 025F sp: FD x: 2E y: 02 
---
[1]    55 0261: 	sec
[2] a: 31 p: 00 pc: 0261 sp: FD x: 2E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 31 p: 01 pc: 0262 sp: FD x: 2E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 2E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 2E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 2E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 2E y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 2E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 2E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 2E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 2E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 2E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 29 p: 00 pc: 026A sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 29 p: 00 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 29 p: 01 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 29 p: 03 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    64 0272: 	rts
[2] a: 29 p: 03 pc: 0272 sp: FD x: 2E y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 29 p: 03 pc: 0220 sp: FF x: 2E y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 2E y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 2E y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 2E y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 2E y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 2E y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 2E y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 2E y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: D1 p: 81 pc: 0216 sp: FF x: 2E y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: D1 p: 81 pc: 0218 sp: FF x: 2E y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 2E y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 2E y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 2E y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D1 p: 80 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D1 p: 81 pc: 025D sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: D1 p: 81 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: D1 p: 00 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: D1 p: 00 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: D1 p: 00 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D1 p: 80 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D1 p: 00 pc: 025D sp: FD x: 2E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: D1 p: 00 pc: 025F sp: FD x: 2E y: 03 
---
[1]    55 0261: 	sec
[2] a: D1 p: 80 pc: 0261 sp: FD x: 2E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D1 p: 81 pc: 0262 sp: FD x: 2E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 61 p: 40 pc: 0264 sp: FD x: 2E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 61 p: 40 pc: 0266 sp: FD x: 2E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 61 p: 40 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 61 p: 40 pc: 025D sp: FD x: 2E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 61 p: 40 pc: 025F sp: FD x: 2E y: 03 
---
[1]    55 0261: 	sec
[2] a: 61 p: 40 pc: 0261 sp: FD x: 2E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 61 p: 41 pc: 0262 sp: FD x: 2E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 29 p: 00 pc: 0264 sp: FD x: 2E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 29 p: 00 pc: 0266 sp: FD x: 2E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 00 pc: 025D sp: FD x: 2E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 29 p: 00 pc: 025F sp: FD x: 2E y: 03 
---
[1]    55 0261: 	sec
[2] a: 29 p: 00 pc: 0261 sp: FD x: 2E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 29 p: 01 pc: 0262 sp: FD x: 2E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 2E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 2E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 2E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 2E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 2E y: 03 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 2E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 2E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 2E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 2E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 2E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1D p: 00 pc: 026A sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 00 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 01 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 03 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    64 0272: 	rts
[2] a: 1D p: 03 pc: 0272 sp: FD x: 2E y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1D p: 03 pc: 0220 sp: FF x: 2E y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 2E y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 2E y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 2E y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 2E y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 2E y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 2E y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 2E y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: D1 p: 81 pc: 0216 sp: FF x: 2E y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: D1 p: 81 pc: 0218 sp: FF x: 2E y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 2E y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 2E y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 2E y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 2E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 2E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 2E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 2E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 2E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 2E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 2E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 2E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 2E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 2E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 2E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 2E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 2E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 2E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 2E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 2E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 2E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 2E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 2E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 2E y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 2E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 2E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D1 p: 80 pc: 025B sp: FD x: 2E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D1 p: 00 pc: 025D sp: FD x: 2E y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: D1 p: 00 pc: 025F sp: FD x: 2E y: 04 
---
[1]    55 0261: 	sec
[2] a: D1 p: 80 pc: 0261 sp: FD x: 2E y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D1 p: 81 pc: 0262 sp: FD x: 2E y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 2E y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 2E y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 2E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 2E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 2E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 2E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 2E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 2E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 2E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 2E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 2E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 2E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 2E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 2E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 2E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 2E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 2E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 2E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 2E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 2E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 2E y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 2E y: 04 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 2E y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 2E y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 2E y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 2E y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2E y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 2E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 2E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 2E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 2E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 2E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 02 pc: 025D sp: FD x: 2E y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 02 pc: 025F sp: FD x: 2E y: 04 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 2E y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 2E y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2E y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2E y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 12 p: 00 pc: 0268 sp: FD x: 2E y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 13 p: 00 pc: 026A sp: FD x: 2E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 00 pc: 026C sp: FD x: 2E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 01 pc: 026E sp: FD x: 2E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 03 pc: 0270 sp: FD x: 2E y: 04 
---
[1]    64 0272: 	rts
[2] a: 13 p: 03 pc: 0272 sp: FD x: 2E y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 13 p: 03 pc: 0220 sp: FF x: 2E y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2E y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2E y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2E y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2E y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: D3 p: 81 pc: 023E sp: FF x: 2E y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: D3 p: 81 pc: 0240 sp: FF x: 2E y: 04 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: D3 p: 81 pc: 0211 sp: FF x: 2E y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: D3 p: 01 pc: 0213 sp: FF x: 2E y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: D3 p: 81 pc: 0216 sp: FF x: 2E y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: D3 p: 81 pc: 0218 sp: FF x: 2E y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2E y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2E y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2E y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2E y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2E y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2E y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2E y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2E y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D3 p: 80 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D3 p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: D3 p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: D3 p: 80 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D3 p: 81 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 44 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 44 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 44 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 44 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 44 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 2E y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 2E y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 2E y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 2E y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2E y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2E y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 44 p: 00 pc: 0268 sp: FD x: 2E y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 46 p: 00 pc: 026A sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 46 p: 00 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 46 p: 00 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 46 p: 00 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 46 p: 00 pc: 0259 sp: FD x: 2E y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2E y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2E y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2E y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2E y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2E y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2E y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2E y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2E y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2E y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2E y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2E y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2E y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2E y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2E y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: D3 p: 81 pc: 0216 sp: FF x: 2E y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: D3 p: 81 pc: 0218 sp: FF x: 2E y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2E y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2E y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2E y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2E y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2E y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2E y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2E y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2E y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D3 p: 80 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D3 p: 00 pc: 025D sp: FD x: 2E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: D3 p: 00 pc: 025F sp: FD x: 2E y: 02 
---
[1]    55 0261: 	sec
[2] a: D3 p: 80 pc: 0261 sp: FD x: 2E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D3 p: 81 pc: 0262 sp: FD x: 2E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 33 p: 00 pc: 0264 sp: FD x: 2E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 33 p: 00 pc: 0266 sp: FD x: 2E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 33 p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 33 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 33 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 33 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 00 pc: 025D sp: FD x: 2E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 33 p: 00 pc: 025F sp: FD x: 2E y: 02 
---
[1]    55 0261: 	sec
[2] a: 33 p: 00 pc: 0261 sp: FD x: 2E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 33 p: 01 pc: 0262 sp: FD x: 2E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 2E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 2E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 2E y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 2E y: 02 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 2E y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 2E y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2E y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2E y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 2E y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2A p: 00 pc: 026A sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2A p: 00 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2A p: 00 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2A p: 00 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2A p: 00 pc: 0259 sp: FD x: 2E y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2E y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2E y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2E y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2E y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2E y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2E y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2E y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2E y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2E y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 2E y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 2E y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 2E y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 2E y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 2E y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: D3 p: 81 pc: 0216 sp: FF x: 2E y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: D3 p: 81 pc: 0218 sp: FF x: 2E y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 2E y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 2E y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 2E y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 2E y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 2E y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 2E y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 2E y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 2E y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D3 p: 80 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D3 p: 81 pc: 025D sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: D3 p: 81 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: D3 p: 00 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: D3 p: 00 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: D3 p: 00 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D3 p: 80 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D3 p: 00 pc: 025D sp: FD x: 2E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: D3 p: 00 pc: 025F sp: FD x: 2E y: 03 
---
[1]    55 0261: 	sec
[2] a: D3 p: 80 pc: 0261 sp: FD x: 2E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D3 p: 81 pc: 0262 sp: FD x: 2E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 63 p: 40 pc: 0264 sp: FD x: 2E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 63 p: 40 pc: 0266 sp: FD x: 2E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 63 p: 40 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 63 p: 40 pc: 025D sp: FD x: 2E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 63 p: 40 pc: 025F sp: FD x: 2E y: 03 
---
[1]    55 0261: 	sec
[2] a: 63 p: 40 pc: 0261 sp: FD x: 2E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 63 p: 41 pc: 0262 sp: FD x: 2E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 2B p: 00 pc: 0264 sp: FD x: 2E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 2B p: 00 pc: 0266 sp: FD x: 2E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 00 pc: 025D sp: FD x: 2E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 2B p: 00 pc: 025F sp: FD x: 2E y: 03 
---
[1]    55 0261: 	sec
[2] a: 2B p: 00 pc: 0261 sp: FD x: 2E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2B p: 01 pc: 0262 sp: FD x: 2E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 2E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 2E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 2E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 2E y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 2E y: 03 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 2E y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 2E y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2E y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2E y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 2E y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1E p: 00 pc: 026A sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1E p: 00 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1E p: 00 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1E p: 00 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1E p: 00 pc: 0259 sp: FD x: 2E y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2E y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2E y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2E y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2E y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2E y: 03 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2E y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2E y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2E y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2E y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 2E y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 2E y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 2E y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 2E y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 2E y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: D3 p: 81 pc: 0216 sp: FF x: 2E y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: D3 p: 81 pc: 0218 sp: FF x: 2E y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 2E y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 2E y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 2E y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 2E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 2E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 2E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 2E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 2E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 2E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 2E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 2E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 2E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 2E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 2E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 2E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 2E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 2E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 2E y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 2E y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 2E y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 2E y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 2E y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 2E y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 2E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 2E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D3 p: 80 pc: 025B sp: FD x: 2E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D3 p: 00 pc: 025D sp: FD x: 2E y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: D3 p: 00 pc: 025F sp: FD x: 2E y: 04 
---
[1]    55 0261: 	sec
[2] a: D3 p: 80 pc: 0261 sp: FD x: 2E y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D3 p: 81 pc: 0262 sp: FD x: 2E y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 2E y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 2E y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 2E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 2E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 2E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 2E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 2E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 2E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 81 pc: 025D sp: FD x: 2E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 81 pc: 026C sp: FD x: 2E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 00 pc: 026E sp: FD x: 2E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 00 pc: 0270 sp: FD x: 2E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 23 p: 00 pc: 0259 sp: FD x: 2E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 2E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 81 pc: 025D sp: FD x: 2E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 81 pc: 026C sp: FD x: 2E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 00 pc: 026E sp: FD x: 2E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 00 pc: 0270 sp: FD x: 2E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 23 p: 00 pc: 0259 sp: FD x: 2E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 2E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 2E y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 2E y: 04 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 2E y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 2E y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 2E y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 2E y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2E y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 2E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 2E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 2E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 2E y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 2E y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2E y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 2E y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 2E y: 04 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 2E y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 2E y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2E y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2E y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 12 p: 00 pc: 0268 sp: FD x: 2E y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 13 p: 00 pc: 026A sp: FD x: 2E y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 00 pc: 026C sp: FD x: 2E y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 01 pc: 026E sp: FD x: 2E y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 03 pc: 0270 sp: FD x: 2E y: 04 
---
[1]    64 0272: 	rts
[2] a: 13 p: 03 pc: 0272 sp: FD x: 2E y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 13 p: 03 pc: 0220 sp: FF x: 2E y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2E y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2E y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 2E y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 2E y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 2E y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 2E y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 2E y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: D3 p: 81 pc: 0216 sp: FF x: 2E y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: D3 p: 81 pc: 0218 sp: FF x: 2E y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 2E y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 2E y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 2E y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 2E y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 2E y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 2E y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 2E y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 2E y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 2E y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 2E y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 2E y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 2E y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 2E y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 2E y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 2E y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 2E y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 2E y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 2E y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 2E y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 2E y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 2E y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 2E y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 2E y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 2E y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 2E y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D3 p: 80 pc: 025B sp: FD x: 2E y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D3 p: 00 pc: 025D sp: FD x: 2E y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: D3 p: 00 pc: 025F sp: FD x: 2E y: 05 
---
[1]    55 0261: 	sec
[2] a: D3 p: 80 pc: 0261 sp: FD x: 2E y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D3 p: 81 pc: 0262 sp: FD x: 2E y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2E y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2E y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2E y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 2E y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 2E y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 2E y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 2E y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 2E y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2E y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2E y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2E y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2E y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2E y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2E y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2E y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2E y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2E y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2E y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2E y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2E y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2E y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2E y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2E y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2E y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2E y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2E y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2E y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2E y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2E y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 2E y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 2E y: 05 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 2E y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 2E y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 2E y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 2E y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 2E y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 81 pc: 0229 sp: FF x: 2E y: 05 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0D p: 81 pc: 022B sp: FF x: 2E y: 05 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0D p: 01 pc: 022C sp: FF x: 2E y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 2E y: 06 
---
[1]    18 0216: 	sta dividend
[2] a: D3 p: 81 pc: 0216 sp: FF x: 2E y: 06 
---
[1]    19 0218: 	lda pstore, y
[2] a: D3 p: 81 pc: 0218 sp: FF x: 2E y: 06 
---
[1]    20 021B: 	sta divisor
[2] a: 11 p: 01 pc: 021B sp: FF x: 2E y: 06 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 11 p: 01 pc: 021D sp: FF x: 2E y: 06 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 11 p: 01 pc: 0244 sp: FD x: 2E y: 06 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2E y: 06 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2E y: 06 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2E y: 06 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2E y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 11 p: 01 pc: 024E sp: FD x: 2E y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 11 p: 81 pc: 0250 sp: FD x: 2E y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 11 p: 81 pc: 0252 sp: FD x: 2E y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 11 p: 00 pc: 0254 sp: FD x: 2E y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 22 p: 00 pc: 0255 sp: FD x: 2E y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 22 p: 00 pc: 024E sp: FD x: 2E y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 22 p: 81 pc: 0250 sp: FD x: 2E y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 22 p: 81 pc: 0252 sp: FD x: 2E y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 22 p: 00 pc: 0254 sp: FD x: 2E y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 44 p: 00 pc: 0255 sp: FD x: 2E y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 44 p: 00 pc: 024E sp: FD x: 2E y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 44 p: 81 pc: 0250 sp: FD x: 2E y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 44 p: 81 pc: 0252 sp: FD x: 2E y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 44 p: 00 pc: 0254 sp: FD x: 2E y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 88 p: 80 pc: 0255 sp: FD x: 2E y: 06 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 88 p: 80 pc: 0257 sp: FD x: 2E y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 88 p: 80 pc: 0259 sp: FD x: 2E y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D3 p: 80 pc: 025B sp: FD x: 2E y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D3 p: 00 pc: 025D sp: FD x: 2E y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: D3 p: 00 pc: 025F sp: FD x: 2E y: 06 
---
[1]    55 0261: 	sec
[2] a: D3 p: 80 pc: 0261 sp: FD x: 2E y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D3 p: 81 pc: 0262 sp: FD x: 2E y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 4B p: 40 pc: 0264 sp: FD x: 2E y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 4B p: 40 pc: 0266 sp: FD x: 2E y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2E y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 2E y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 2E y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 2E y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 2E y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 2E y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4B p: 40 pc: 025B sp: FD x: 2E y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4B p: 40 pc: 025D sp: FD x: 2E y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 4B p: 40 pc: 025F sp: FD x: 2E y: 06 
---
[1]    55 0261: 	sec
[2] a: 4B p: 40 pc: 0261 sp: FD x: 2E y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4B p: 41 pc: 0262 sp: FD x: 2E y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 2E y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 2E y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 2E y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 2E y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 2E y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 2E y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 2E y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 2E y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2E y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 2E y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 2E y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 2E y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 2E y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 2E y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2E y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 2E y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 2E y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 2E y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 2E y: 06 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 2E y: 06 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 2E y: 06 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 07 p: 01 pc: 0222 sp: FF x: 2E y: 06 
---
[1]    24 0224: 	lda pstore, y
[2] a: 07 p: 01 pc: 0224 sp: FF x: 2E y: 06 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 11 p: 01 pc: 0227 sp: FF x: 2E y: 06 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 11 p: 00 pc: 0229 sp: FF x: 2E y: 06 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 11 p: 00 pc: 022E sp: FF x: 2E y: 06 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: D3 p: 80 pc: 0231 sp: FF x: 2E y: 06 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: D3 p: 00 pc: 0232 sp: FF x: 2F y: 06 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: D3 p: 00 pc: 0235 sp: FF x: 2F y: 06 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: D3 p: 80 pc: 0238 sp: FF x: 2F y: 06 
---
[1]    34 023B: 	lda pstore, x
[2] a: D3 p: 80 pc: 023B sp: FF x: 2F y: 06 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: D5 p: 80 pc: 023E sp: FF x: 2F y: 06 
---
[1]    36 0240: 	bmi checkp
[2] a: D5 p: 81 pc: 0240 sp: FF x: 2F y: 06 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: D5 p: 81 pc: 0211 sp: FF x: 2F y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: D5 p: 01 pc: 0213 sp: FF x: 2F y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: D5 p: 81 pc: 0216 sp: FF x: 2F y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: D5 p: 81 pc: 0218 sp: FF x: 2F y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2F y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2F y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2F y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D5 p: 80 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D5 p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: D5 p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: D5 p: 80 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D5 p: 81 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 44 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 44 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 44 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 44 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 44 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 44 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 46 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 46 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 46 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 46 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 46 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 46 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 47 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 47 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 47 p: 01 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 47 p: 03 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    64 0272: 	rts
[2] a: 47 p: 03 pc: 0272 sp: FD x: 2F y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 47 p: 03 pc: 0220 sp: FF x: 2F y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2F y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2F y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2F y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2F y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: D7 p: 81 pc: 023E sp: FF x: 2F y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: D7 p: 81 pc: 0240 sp: FF x: 2F y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: D7 p: 81 pc: 0211 sp: FF x: 2F y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: D7 p: 01 pc: 0213 sp: FF x: 2F y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: D7 p: 81 pc: 0216 sp: FF x: 2F y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: D7 p: 81 pc: 0218 sp: FF x: 2F y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2F y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2F y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2F y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D7 p: 80 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D7 p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: D7 p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: D7 p: 80 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D7 p: 81 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 44 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 44 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 44 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 44 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 44 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 44 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 46 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 46 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 46 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 46 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 46 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 46 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 47 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 47 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 47 p: 01 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 47 p: 03 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    64 0272: 	rts
[2] a: 47 p: 03 pc: 0272 sp: FD x: 2F y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 47 p: 03 pc: 0220 sp: FF x: 2F y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2F y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2F y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2F y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2F y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2F y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2F y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2F y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: D7 p: 81 pc: 0216 sp: FF x: 2F y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: D7 p: 81 pc: 0218 sp: FF x: 2F y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2F y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2F y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2F y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D7 p: 80 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D7 p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: D7 p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: D7 p: 80 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D7 p: 81 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 37 p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 37 p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 81 pc: 025D sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 37 p: 81 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 37 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 37 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 37 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 37 p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: 37 p: 00 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 37 p: 01 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2A p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2A p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2A p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2A p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2A p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2A p: 00 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2B p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 01 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 03 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    64 0272: 	rts
[2] a: 2B p: 03 pc: 0272 sp: FD x: 2F y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 2B p: 03 pc: 0220 sp: FF x: 2F y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2F y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2F y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2F y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2F y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: D9 p: 81 pc: 023E sp: FF x: 2F y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: D9 p: 81 pc: 0240 sp: FF x: 2F y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: D9 p: 81 pc: 0211 sp: FF x: 2F y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: D9 p: 01 pc: 0213 sp: FF x: 2F y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: D9 p: 81 pc: 0216 sp: FF x: 2F y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: D9 p: 81 pc: 0218 sp: FF x: 2F y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2F y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2F y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2F y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D9 p: 80 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D9 p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: D9 p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: D9 p: 80 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D9 p: 81 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 48 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 48 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 48 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 48 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 48 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2F y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2F y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2F y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2F y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2F y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2F y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2F y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2F y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2F y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: D9 p: 81 pc: 0216 sp: FF x: 2F y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: D9 p: 81 pc: 0218 sp: FF x: 2F y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2F y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2F y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2F y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D9 p: 80 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D9 p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: D9 p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: D9 p: 80 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D9 p: 81 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 39 p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 39 p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 81 pc: 025D sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 39 p: 81 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 39 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 39 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 39 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 39 p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: 39 p: 00 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 39 p: 01 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2A p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2A p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2A p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2A p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2A p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2A p: 00 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2B p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 01 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 03 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    64 0272: 	rts
[2] a: 2B p: 03 pc: 0272 sp: FD x: 2F y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 2B p: 03 pc: 0220 sp: FF x: 2F y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2F y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2F y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 2F y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 2F y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 2F y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 2F y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 2F y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: D9 p: 81 pc: 0216 sp: FF x: 2F y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: D9 p: 81 pc: 0218 sp: FF x: 2F y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 2F y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 2F y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 2F y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D9 p: 80 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D9 p: 81 pc: 025D sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: D9 p: 81 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: D9 p: 00 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: D9 p: 00 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: D9 p: 00 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: D9 p: 80 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: D9 p: 00 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: D9 p: 00 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: D9 p: 80 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: D9 p: 81 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 69 p: 40 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 69 p: 40 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 69 p: 40 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 69 p: 40 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 69 p: 40 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: 69 p: 40 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 69 p: 41 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 31 p: 00 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 31 p: 00 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 00 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 31 p: 00 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: 31 p: 00 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 31 p: 01 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1E p: 00 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1E p: 00 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1E p: 00 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1E p: 00 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1E p: 00 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 02 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 02 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1E p: 00 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1F p: 00 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 00 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 01 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 03 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    64 0272: 	rts
[2] a: 1F p: 03 pc: 0272 sp: FD x: 2F y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1F p: 03 pc: 0220 sp: FF x: 2F y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2F y: 03 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2F y: 03 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2F y: 03 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2F y: 03 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: DB p: 81 pc: 023E sp: FF x: 2F y: 03 
---
[1]    36 0240: 	bmi checkp
[2] a: DB p: 81 pc: 0240 sp: FF x: 2F y: 03 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: DB p: 81 pc: 0211 sp: FF x: 2F y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: DB p: 01 pc: 0213 sp: FF x: 2F y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: DB p: 81 pc: 0216 sp: FF x: 2F y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: DB p: 81 pc: 0218 sp: FF x: 2F y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2F y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2F y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2F y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DB p: 80 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DB p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: DB p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: DB p: 80 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: DB p: 81 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 48 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 48 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 48 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 48 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 48 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 48 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 49 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 49 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 49 p: 01 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 49 p: 03 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    64 0272: 	rts
[2] a: 49 p: 03 pc: 0272 sp: FD x: 2F y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 49 p: 03 pc: 0220 sp: FF x: 2F y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2F y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2F y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2F y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2F y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: DD p: 81 pc: 023E sp: FF x: 2F y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: DD p: 81 pc: 0240 sp: FF x: 2F y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: DD p: 81 pc: 0211 sp: FF x: 2F y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: DD p: 01 pc: 0213 sp: FF x: 2F y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: DD p: 81 pc: 0216 sp: FF x: 2F y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: DD p: 81 pc: 0218 sp: FF x: 2F y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2F y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2F y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2F y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DD p: 80 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DD p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: DD p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: DD p: 80 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: DD p: 81 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 1D p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 1D p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1D p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1D p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 48 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 48 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 48 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 48 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 48 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 48 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 49 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 49 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 49 p: 01 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 49 p: 03 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    64 0272: 	rts
[2] a: 49 p: 03 pc: 0272 sp: FD x: 2F y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 49 p: 03 pc: 0220 sp: FF x: 2F y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2F y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2F y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2F y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2F y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2F y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2F y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2F y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: DD p: 81 pc: 0216 sp: FF x: 2F y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: DD p: 81 pc: 0218 sp: FF x: 2F y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2F y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2F y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2F y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DD p: 80 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DD p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: DD p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: DD p: 80 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: DD p: 81 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 3D p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 3D p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 81 pc: 025D sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3D p: 81 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 3D p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3D p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3D p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 3D p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: 3D p: 00 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3D p: 01 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2F y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2F y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2F y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2F y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 2F y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 2F y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 2F y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 2F y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 2F y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: DD p: 81 pc: 0216 sp: FF x: 2F y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: DD p: 81 pc: 0218 sp: FF x: 2F y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 2F y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 2F y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 2F y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DD p: 80 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DD p: 81 pc: 025D sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: DD p: 81 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: DD p: 00 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: DD p: 00 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: DD p: 00 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DD p: 80 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DD p: 00 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: DD p: 00 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: DD p: 80 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: DD p: 81 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 6D p: 40 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 6D p: 40 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6D p: 40 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6D p: 40 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 6D p: 40 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: 6D p: 40 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 6D p: 41 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 35 p: 00 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 35 p: 00 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 00 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 35 p: 00 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: 35 p: 00 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 35 p: 01 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1E p: 00 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1E p: 00 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1E p: 00 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1E p: 00 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1E p: 00 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1E p: 00 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1F p: 00 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 00 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 01 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 03 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    64 0272: 	rts
[2] a: 1F p: 03 pc: 0272 sp: FD x: 2F y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1F p: 03 pc: 0220 sp: FF x: 2F y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 2F y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 2F y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 2F y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 2F y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 2F y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 2F y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 2F y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: DD p: 81 pc: 0216 sp: FF x: 2F y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: DD p: 81 pc: 0218 sp: FF x: 2F y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 2F y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 2F y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 2F y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 2F y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 2F y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 2F y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 2F y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 2F y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 2F y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 2F y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 2F y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 2F y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 2F y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 2F y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 2F y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 2F y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 2F y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 2F y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 2F y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 2F y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 2F y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 2F y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 2F y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 2F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 2F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DD p: 80 pc: 025B sp: FD x: 2F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DD p: 00 pc: 025D sp: FD x: 2F y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: DD p: 00 pc: 025F sp: FD x: 2F y: 04 
---
[1]    55 0261: 	sec
[2] a: DD p: 80 pc: 0261 sp: FD x: 2F y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: DD p: 81 pc: 0262 sp: FD x: 2F y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 2D p: 00 pc: 0264 sp: FD x: 2F y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 2D p: 00 pc: 0266 sp: FD x: 2F y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 2F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 2F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 2F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 2F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 2F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 2F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 81 pc: 025D sp: FD x: 2F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2D p: 81 pc: 026C sp: FD x: 2F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 2D p: 00 pc: 026E sp: FD x: 2F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2D p: 00 pc: 0270 sp: FD x: 2F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2D p: 00 pc: 0259 sp: FD x: 2F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 2F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 00 pc: 025D sp: FD x: 2F y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 2D p: 00 pc: 025F sp: FD x: 2F y: 04 
---
[1]    55 0261: 	sec
[2] a: 2D p: 00 pc: 0261 sp: FD x: 2F y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2D p: 01 pc: 0262 sp: FD x: 2F y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2F y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2F y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2F y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 2F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 2F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 2F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 2F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 2F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 2F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 2F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 2F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2F y: 04 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2F y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2F y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2F y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2F y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 2F y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 2F y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 2F y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 2F y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 2F y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: DD p: 81 pc: 0216 sp: FF x: 2F y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: DD p: 81 pc: 0218 sp: FF x: 2F y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 2F y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 2F y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 2F y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 2F y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 2F y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 2F y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 2F y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 2F y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 2F y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 2F y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 2F y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 2F y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 2F y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 2F y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 2F y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 2F y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 2F y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 2F y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 2F y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 2F y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 2F y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 2F y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 2F y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 2F y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 2F y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DD p: 80 pc: 025B sp: FD x: 2F y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DD p: 00 pc: 025D sp: FD x: 2F y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: DD p: 00 pc: 025F sp: FD x: 2F y: 05 
---
[1]    55 0261: 	sec
[2] a: DD p: 80 pc: 0261 sp: FD x: 2F y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: DD p: 81 pc: 0262 sp: FD x: 2F y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 2F y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 2F y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 2F y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 2F y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 2F y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 2F y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 2F y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2F y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 2F y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 2F y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 2F y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 2F y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 2F y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2F y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 2F y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 2F y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 2F y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 2F y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 2F y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2F y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 2F y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 2F y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 2F y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 2F y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 2F y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2F y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 02 pc: 025D sp: FD x: 2F y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 02 pc: 025F sp: FD x: 2F y: 05 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 2F y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 2F y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 2F y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 2F y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2F y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 2F y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 2F y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 2F y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 2F y: 05 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 2F y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 2F y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 2F y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 2F y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 2F y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 2F y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: DF p: 81 pc: 023E sp: FF x: 2F y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: DF p: 81 pc: 0240 sp: FF x: 2F y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: DF p: 81 pc: 0211 sp: FF x: 2F y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: DF p: 01 pc: 0213 sp: FF x: 2F y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: DF p: 81 pc: 0216 sp: FF x: 2F y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: DF p: 81 pc: 0218 sp: FF x: 2F y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 2F y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 2F y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 2F y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 2F y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 2F y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 2F y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 2F y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 2F y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DF p: 80 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DF p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: DF p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: DF p: 80 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: DF p: 81 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 1F p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 1F p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1F p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1F p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 48 p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 48 p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 48 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 48 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 48 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 2F y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 2F y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 2F y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 2F y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 2F y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 2F y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 48 p: 00 pc: 0268 sp: FD x: 2F y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4A p: 00 pc: 026A sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4A p: 00 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4A p: 00 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4A p: 00 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4A p: 00 pc: 0259 sp: FD x: 2F y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 2F y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 2F y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 2F y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 2F y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 2F y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 2F y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 2F y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 2F y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 2F y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 2F y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 2F y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 2F y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 2F y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 2F y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: DF p: 81 pc: 0216 sp: FF x: 2F y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: DF p: 81 pc: 0218 sp: FF x: 2F y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 2F y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 2F y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 2F y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 2F y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 2F y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 2F y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 2F y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 2F y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DF p: 80 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DF p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: DF p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: DF p: 80 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: DF p: 81 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 3F p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 3F p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3F p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3F p: 81 pc: 025D sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3F p: 81 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 3F p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3F p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3F p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3F p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3F p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 3F p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: 3F p: 00 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3F p: 01 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 2F y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 2F y: 02 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 2F y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 2F y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2F y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2F y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 2F y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2F y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2F y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2F y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2F y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 2F y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 2F y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 2F y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 2F y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 2F y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 2F y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 2F y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 2F y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 2F y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 2F y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 2F y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: DF p: 81 pc: 0216 sp: FF x: 2F y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: DF p: 81 pc: 0218 sp: FF x: 2F y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 2F y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 2F y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 2F y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 2F y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 2F y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 2F y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 2F y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 2F y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DF p: 80 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DF p: 81 pc: 025D sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: DF p: 81 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: DF p: 00 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: DF p: 00 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: DF p: 00 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DF p: 80 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DF p: 00 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: DF p: 00 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: DF p: 80 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: DF p: 81 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 6F p: 40 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 6F p: 40 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 6F p: 40 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 6F p: 40 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 6F p: 40 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: 6F p: 40 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 6F p: 41 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 37 p: 00 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 37 p: 00 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 18 p: 00 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 18 p: 00 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 18 p: 00 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 18 p: 00 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 18 p: 00 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 00 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 37 p: 00 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: 37 p: 00 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 37 p: 01 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 18 p: 00 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1C p: 00 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1C p: 00 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1C p: 00 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1C p: 00 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1C p: 00 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1C p: 00 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1E p: 00 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1E p: 00 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1E p: 00 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1E p: 00 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1E p: 00 pc: 0259 sp: FD x: 2F y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 2F y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 2F y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 2F y: 03 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 2F y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 2F y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 2F y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 2F y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 1E p: 00 pc: 0268 sp: FD x: 2F y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 1F p: 00 pc: 026A sp: FD x: 2F y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 00 pc: 026C sp: FD x: 2F y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 01 pc: 026E sp: FD x: 2F y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 03 pc: 0270 sp: FD x: 2F y: 03 
---
[1]    64 0272: 	rts
[2] a: 1F p: 03 pc: 0272 sp: FD x: 2F y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 1F p: 03 pc: 0220 sp: FF x: 2F y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 2F y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 2F y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 2F y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 2F y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 2F y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 2F y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 2F y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: DF p: 81 pc: 0216 sp: FF x: 2F y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: DF p: 81 pc: 0218 sp: FF x: 2F y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 2F y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 2F y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 2F y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 2F y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 2F y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 2F y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 2F y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 2F y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 2F y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 2F y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 2F y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 2F y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 2F y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 2F y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 2F y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 2F y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 2F y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 2F y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 2F y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 2F y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 2F y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 2F y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 2F y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 2F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 2F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DF p: 80 pc: 025B sp: FD x: 2F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DF p: 00 pc: 025D sp: FD x: 2F y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: DF p: 00 pc: 025F sp: FD x: 2F y: 04 
---
[1]    55 0261: 	sec
[2] a: DF p: 80 pc: 0261 sp: FD x: 2F y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: DF p: 81 pc: 0262 sp: FD x: 2F y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 2F p: 00 pc: 0264 sp: FD x: 2F y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 2F p: 00 pc: 0266 sp: FD x: 2F y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 2F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 2F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 2F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 2F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 2F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 2F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 81 pc: 025D sp: FD x: 2F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2F p: 81 pc: 026C sp: FD x: 2F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 2F p: 00 pc: 026E sp: FD x: 2F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2F p: 00 pc: 0270 sp: FD x: 2F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2F p: 00 pc: 0259 sp: FD x: 2F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 2F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 00 pc: 025D sp: FD x: 2F y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 2F p: 00 pc: 025F sp: FD x: 2F y: 04 
---
[1]    55 0261: 	sec
[2] a: 2F p: 00 pc: 0261 sp: FD x: 2F y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2F p: 01 pc: 0262 sp: FD x: 2F y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 2F y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 2F y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2F y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 2F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 2F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 2F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 2F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 2F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 2F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 2F y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 2F y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 2F y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 2F y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 2F y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 2F y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 2F y: 04 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 2F y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 2F y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 2F y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 2F y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 2F y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 2F y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 2F y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 2F y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 2F y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: DF p: 81 pc: 0216 sp: FF x: 2F y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: DF p: 81 pc: 0218 sp: FF x: 2F y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 2F y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 2F y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 2F y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 2F y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 2F y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 2F y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 2F y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 2F y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 2F y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 2F y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 2F y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 2F y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 2F y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 2F y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 2F y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 2F y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 2F y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 2F y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 2F y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 2F y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 2F y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 2F y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 2F y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 2F y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 2F y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DF p: 80 pc: 025B sp: FD x: 2F y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DF p: 00 pc: 025D sp: FD x: 2F y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: DF p: 00 pc: 025F sp: FD x: 2F y: 05 
---
[1]    55 0261: 	sec
[2] a: DF p: 80 pc: 0261 sp: FD x: 2F y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: DF p: 81 pc: 0262 sp: FD x: 2F y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 2F y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 2F y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 2F y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 2F y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 2F y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 2F y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 2F y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 2F y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2F y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 2F y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 2F y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 2F y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 2F y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 2F y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2F y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 2F y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 2F y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 2F y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 2F y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 2F y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2F y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 2F y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 2F y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 2F y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 2F y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 2F y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 2F y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 2F y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 2F y: 05 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 2F y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 2F y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2F y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2F y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 2F y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 2F y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 2F y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 2F y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 2F y: 05 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 2F y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 2F y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2F y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2F y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 2F y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 81 pc: 0229 sp: FF x: 2F y: 05 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0D p: 81 pc: 022B sp: FF x: 2F y: 05 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0D p: 01 pc: 022C sp: FF x: 2F y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 2F y: 06 
---
[1]    18 0216: 	sta dividend
[2] a: DF p: 81 pc: 0216 sp: FF x: 2F y: 06 
---
[1]    19 0218: 	lda pstore, y
[2] a: DF p: 81 pc: 0218 sp: FF x: 2F y: 06 
---
[1]    20 021B: 	sta divisor
[2] a: 11 p: 01 pc: 021B sp: FF x: 2F y: 06 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 11 p: 01 pc: 021D sp: FF x: 2F y: 06 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 11 p: 01 pc: 0244 sp: FD x: 2F y: 06 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 2F y: 06 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 2F y: 06 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 2F y: 06 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 2F y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 11 p: 01 pc: 024E sp: FD x: 2F y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 11 p: 81 pc: 0250 sp: FD x: 2F y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 11 p: 81 pc: 0252 sp: FD x: 2F y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 11 p: 00 pc: 0254 sp: FD x: 2F y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 22 p: 00 pc: 0255 sp: FD x: 2F y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 22 p: 00 pc: 024E sp: FD x: 2F y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 22 p: 81 pc: 0250 sp: FD x: 2F y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 22 p: 81 pc: 0252 sp: FD x: 2F y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 22 p: 00 pc: 0254 sp: FD x: 2F y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 44 p: 00 pc: 0255 sp: FD x: 2F y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 44 p: 00 pc: 024E sp: FD x: 2F y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 44 p: 81 pc: 0250 sp: FD x: 2F y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 44 p: 81 pc: 0252 sp: FD x: 2F y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 44 p: 00 pc: 0254 sp: FD x: 2F y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 88 p: 80 pc: 0255 sp: FD x: 2F y: 06 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 88 p: 80 pc: 0257 sp: FD x: 2F y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 88 p: 80 pc: 0259 sp: FD x: 2F y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: DF p: 80 pc: 025B sp: FD x: 2F y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: DF p: 00 pc: 025D sp: FD x: 2F y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: DF p: 00 pc: 025F sp: FD x: 2F y: 06 
---
[1]    55 0261: 	sec
[2] a: DF p: 80 pc: 0261 sp: FD x: 2F y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: DF p: 81 pc: 0262 sp: FD x: 2F y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 57 p: 40 pc: 0264 sp: FD x: 2F y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 57 p: 40 pc: 0266 sp: FD x: 2F y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 2F y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 2F y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 2F y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 2F y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 2F y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 2F y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 57 p: 40 pc: 025B sp: FD x: 2F y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 57 p: 40 pc: 025D sp: FD x: 2F y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 57 p: 40 pc: 025F sp: FD x: 2F y: 06 
---
[1]    55 0261: 	sec
[2] a: 57 p: 40 pc: 0261 sp: FD x: 2F y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 57 p: 41 pc: 0262 sp: FD x: 2F y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 2F y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 2F y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 2F y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 2F y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 2F y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 2F y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 2F y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 2F y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 2F y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 2F y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 2F y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 2F y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 2F y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 2F y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 2F y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 2F y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 2F y: 06 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 2F y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 2F y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 2F y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 2F y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 2F y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 2F y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 2F y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 2F y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 2F y: 06 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 2F y: 06 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 2F y: 06 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 2F y: 06 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 2F y: 06 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 11 p: 01 pc: 0227 sp: FF x: 2F y: 06 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 11 p: 00 pc: 0229 sp: FF x: 2F y: 06 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 11 p: 00 pc: 022E sp: FF x: 2F y: 06 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: DF p: 80 pc: 0231 sp: FF x: 2F y: 06 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: DF p: 00 pc: 0232 sp: FF x: 30 y: 06 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: DF p: 00 pc: 0235 sp: FF x: 30 y: 06 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: DF p: 80 pc: 0238 sp: FF x: 30 y: 06 
---
[1]    34 023B: 	lda pstore, x
[2] a: DF p: 80 pc: 023B sp: FF x: 30 y: 06 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: E1 p: 80 pc: 023E sp: FF x: 30 y: 06 
---
[1]    36 0240: 	bmi checkp
[2] a: E1 p: 81 pc: 0240 sp: FF x: 30 y: 06 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: E1 p: 81 pc: 0211 sp: FF x: 30 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: E1 p: 01 pc: 0213 sp: FF x: 30 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: E1 p: 81 pc: 0216 sp: FF x: 30 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: E1 p: 81 pc: 0218 sp: FF x: 30 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 30 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 30 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 30 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 30 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 30 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 30 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 30 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 30 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 30 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 30 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 30 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 30 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 30 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 30 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 30 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 30 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 30 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 30 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 30 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 30 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 30 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 30 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 30 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 30 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 30 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 30 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 30 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 30 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 30 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 30 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 30 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 30 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 30 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 30 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 30 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 30 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 30 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E1 p: 80 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E1 p: 00 pc: 025D sp: FD x: 30 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: E1 p: 00 pc: 025F sp: FD x: 30 y: 01 
---
[1]    55 0261: 	sec
[2] a: E1 p: 80 pc: 0261 sp: FD x: 30 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E1 p: 81 pc: 0262 sp: FD x: 30 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 30 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 30 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 30 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 30 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 30 y: 01 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 30 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 30 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 30 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 30 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 30 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 48 p: 00 pc: 026A sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 48 p: 00 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 48 p: 00 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 48 p: 00 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 48 p: 00 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 30 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 30 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 30 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 30 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 30 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 30 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 48 p: 00 pc: 0268 sp: FD x: 30 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4A p: 00 pc: 026A sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4A p: 00 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4A p: 00 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4A p: 00 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4A p: 00 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 30 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 30 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 30 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 30 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 30 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 30 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 4A p: 00 pc: 0268 sp: FD x: 30 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4B p: 00 pc: 026A sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4B p: 00 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4B p: 01 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4B p: 03 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    64 0272: 	rts
[2] a: 4B p: 03 pc: 0272 sp: FD x: 30 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 4B p: 03 pc: 0220 sp: FF x: 30 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 30 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 30 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 30 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 30 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: E3 p: 81 pc: 023E sp: FF x: 30 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: E3 p: 81 pc: 0240 sp: FF x: 30 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: E3 p: 81 pc: 0211 sp: FF x: 30 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: E3 p: 01 pc: 0213 sp: FF x: 30 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: E3 p: 81 pc: 0216 sp: FF x: 30 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: E3 p: 81 pc: 0218 sp: FF x: 30 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 30 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 30 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 30 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 30 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 30 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 30 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 30 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 30 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 30 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 30 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 30 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 30 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 30 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 30 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 30 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 30 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 30 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 30 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 30 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 30 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 30 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 30 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 30 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 30 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 30 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 30 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 30 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 30 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 30 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 30 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 30 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 30 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 30 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 30 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 30 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 30 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 30 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E3 p: 80 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E3 p: 00 pc: 025D sp: FD x: 30 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: E3 p: 00 pc: 025F sp: FD x: 30 y: 01 
---
[1]    55 0261: 	sec
[2] a: E3 p: 80 pc: 0261 sp: FD x: 30 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E3 p: 81 pc: 0262 sp: FD x: 30 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 30 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 30 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 30 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 81 pc: 025D sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 81 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 00 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 00 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 23 p: 00 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 81 pc: 025D sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 81 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 00 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 00 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 23 p: 00 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 30 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 30 y: 01 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 30 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 30 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 30 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 30 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 30 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 48 p: 00 pc: 026A sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 48 p: 00 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 48 p: 00 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 48 p: 00 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 48 p: 00 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 30 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 30 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 30 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 30 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 30 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 30 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 48 p: 00 pc: 0268 sp: FD x: 30 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4A p: 00 pc: 026A sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4A p: 00 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4A p: 00 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4A p: 00 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4A p: 00 pc: 0259 sp: FD x: 30 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 30 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 30 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 30 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 30 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 30 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 30 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 30 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 4A p: 00 pc: 0268 sp: FD x: 30 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4B p: 00 pc: 026A sp: FD x: 30 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4B p: 00 pc: 026C sp: FD x: 30 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4B p: 01 pc: 026E sp: FD x: 30 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4B p: 03 pc: 0270 sp: FD x: 30 y: 01 
---
[1]    64 0272: 	rts
[2] a: 4B p: 03 pc: 0272 sp: FD x: 30 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 4B p: 03 pc: 0220 sp: FF x: 30 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 30 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 30 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 30 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 30 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 30 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 30 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 30 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: E3 p: 81 pc: 0216 sp: FF x: 30 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: E3 p: 81 pc: 0218 sp: FF x: 30 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 30 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 30 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 30 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 30 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 30 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 30 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 30 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 30 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 30 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 30 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 30 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 30 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 30 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 30 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 30 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 30 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 30 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 30 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 30 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 30 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 30 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 30 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 30 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 30 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 30 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 30 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 30 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 30 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 30 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 30 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 30 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 30 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 30 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 30 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E3 p: 80 pc: 025B sp: FD x: 30 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E3 p: 00 pc: 025D sp: FD x: 30 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: E3 p: 00 pc: 025F sp: FD x: 30 y: 02 
---
[1]    55 0261: 	sec
[2] a: E3 p: 80 pc: 0261 sp: FD x: 30 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E3 p: 81 pc: 0262 sp: FD x: 30 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 43 p: 40 pc: 0264 sp: FD x: 30 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 43 p: 40 pc: 0266 sp: FD x: 30 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 30 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 30 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 30 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 30 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 30 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 30 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 43 p: 40 pc: 025B sp: FD x: 30 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 43 p: C1 pc: 025D sp: FD x: 30 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 43 p: C1 pc: 026C sp: FD x: 30 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 43 p: 40 pc: 026E sp: FD x: 30 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 43 p: 40 pc: 0270 sp: FD x: 30 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 43 p: 40 pc: 0259 sp: FD x: 30 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 43 p: 40 pc: 025B sp: FD x: 30 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 43 p: 40 pc: 025D sp: FD x: 30 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 43 p: 40 pc: 025F sp: FD x: 30 y: 02 
---
[1]    55 0261: 	sec
[2] a: 43 p: 40 pc: 0261 sp: FD x: 30 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 43 p: 41 pc: 0262 sp: FD x: 30 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 30 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 30 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 30 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 30 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 30 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 30 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 30 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 30 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 30 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 30 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 30 y: 02 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 30 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 30 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 30 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 30 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 30 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 30 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 30 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 30 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 30 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 30 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 30 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 30 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 30 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 30 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 30 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 30 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 30 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 30 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 30 y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 30 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 30 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 30 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 30 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2C p: 00 pc: 0268 sp: FD x: 30 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2D p: 00 pc: 026A sp: FD x: 30 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2D p: 00 pc: 026C sp: FD x: 30 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2D p: 01 pc: 026E sp: FD x: 30 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2D p: 03 pc: 0270 sp: FD x: 30 y: 02 
---
[1]    64 0272: 	rts
[2] a: 2D p: 03 pc: 0272 sp: FD x: 30 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 2D p: 03 pc: 0220 sp: FF x: 30 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 30 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 30 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 30 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 30 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 30 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 30 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 30 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: E3 p: 81 pc: 0216 sp: FF x: 30 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: E3 p: 81 pc: 0218 sp: FF x: 30 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 30 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 30 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 30 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 30 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 30 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 30 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 30 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 30 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 30 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 30 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 30 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 30 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 30 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 30 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 30 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 30 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 30 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 30 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 30 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 30 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 30 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 30 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 30 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 30 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 30 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 30 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 30 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 30 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 30 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 30 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 30 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 30 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 30 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 30 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E3 p: 80 pc: 025B sp: FD x: 30 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E3 p: 00 pc: 025D sp: FD x: 30 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: E3 p: 00 pc: 025F sp: FD x: 30 y: 03 
---
[1]    55 0261: 	sec
[2] a: E3 p: 80 pc: 0261 sp: FD x: 30 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E3 p: 81 pc: 0262 sp: FD x: 30 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 30 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 30 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 30 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 30 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 30 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 30 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 30 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 30 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 30 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 30 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 30 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 30 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 30 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 30 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 30 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 30 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 30 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 30 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 30 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 30 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 30 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 30 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 30 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 30 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 30 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 30 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 30 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 30 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 30 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 30 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 30 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 30 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 30 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 30 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 30 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 30 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 30 y: 03 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 30 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 30 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 30 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 30 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 30 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 30 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 30 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 30 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 30 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: E3 p: 81 pc: 0216 sp: FF x: 30 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: E3 p: 81 pc: 0218 sp: FF x: 30 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 30 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 30 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 30 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 30 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 30 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 30 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 30 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 30 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 30 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 30 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 30 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 30 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 30 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 30 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 30 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 30 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 30 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 30 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 30 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 30 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 30 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 30 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 30 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 30 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 30 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 30 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 30 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 30 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 30 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E3 p: 80 pc: 025B sp: FD x: 30 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E3 p: 00 pc: 025D sp: FD x: 30 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: E3 p: 00 pc: 025F sp: FD x: 30 y: 04 
---
[1]    55 0261: 	sec
[2] a: E3 p: 80 pc: 0261 sp: FD x: 30 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E3 p: 81 pc: 0262 sp: FD x: 30 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 33 p: 00 pc: 0264 sp: FD x: 30 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 33 p: 00 pc: 0266 sp: FD x: 30 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 30 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 30 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 30 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 30 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 30 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 30 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 30 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 81 pc: 025D sp: FD x: 30 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 33 p: 81 pc: 026C sp: FD x: 30 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 33 p: 00 pc: 026E sp: FD x: 30 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 33 p: 00 pc: 0270 sp: FD x: 30 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 33 p: 00 pc: 0259 sp: FD x: 30 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 30 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 00 pc: 025D sp: FD x: 30 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 33 p: 00 pc: 025F sp: FD x: 30 y: 04 
---
[1]    55 0261: 	sec
[2] a: 33 p: 00 pc: 0261 sp: FD x: 30 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 33 p: 01 pc: 0262 sp: FD x: 30 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 30 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 30 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 30 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 30 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 30 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 30 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 30 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 30 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 30 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 30 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 30 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 30 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 30 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 30 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 30 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 30 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 30 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 30 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 30 y: 04 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 30 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 30 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 07 p: 01 pc: 0222 sp: FF x: 30 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 07 p: 01 pc: 0224 sp: FF x: 30 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 30 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 30 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 30 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 30 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 30 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: E3 p: 81 pc: 0216 sp: FF x: 30 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: E3 p: 81 pc: 0218 sp: FF x: 30 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 30 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 30 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 30 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 30 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 30 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 30 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 30 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 30 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 30 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 30 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 30 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 30 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 30 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 30 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 30 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 30 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 30 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 30 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 30 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 30 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 30 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 30 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 30 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 30 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 30 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 30 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 30 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 30 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 30 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E3 p: 80 pc: 025B sp: FD x: 30 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E3 p: 00 pc: 025D sp: FD x: 30 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: E3 p: 00 pc: 025F sp: FD x: 30 y: 05 
---
[1]    55 0261: 	sec
[2] a: E3 p: 80 pc: 0261 sp: FD x: 30 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E3 p: 81 pc: 0262 sp: FD x: 30 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 30 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 30 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 30 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 30 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 30 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 30 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 30 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 30 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 30 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 30 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 30 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 30 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 30 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 30 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 30 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 30 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 30 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 30 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 30 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 30 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 30 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 30 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 30 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 30 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 30 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 30 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 30 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 30 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 30 y: 05 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 30 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 30 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 30 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 30 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 30 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 30 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 30 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 30 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 30 y: 05 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 30 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 30 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 30 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 30 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 30 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 81 pc: 0229 sp: FF x: 30 y: 05 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0D p: 81 pc: 022B sp: FF x: 30 y: 05 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0D p: 01 pc: 022C sp: FF x: 30 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 30 y: 06 
---
[1]    18 0216: 	sta dividend
[2] a: E3 p: 81 pc: 0216 sp: FF x: 30 y: 06 
---
[1]    19 0218: 	lda pstore, y
[2] a: E3 p: 81 pc: 0218 sp: FF x: 30 y: 06 
---
[1]    20 021B: 	sta divisor
[2] a: 11 p: 01 pc: 021B sp: FF x: 30 y: 06 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 11 p: 01 pc: 021D sp: FF x: 30 y: 06 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 11 p: 01 pc: 0244 sp: FD x: 30 y: 06 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 30 y: 06 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 30 y: 06 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 30 y: 06 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 30 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 11 p: 01 pc: 024E sp: FD x: 30 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 11 p: 81 pc: 0250 sp: FD x: 30 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 11 p: 81 pc: 0252 sp: FD x: 30 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 11 p: 00 pc: 0254 sp: FD x: 30 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 22 p: 00 pc: 0255 sp: FD x: 30 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 22 p: 00 pc: 024E sp: FD x: 30 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 22 p: 81 pc: 0250 sp: FD x: 30 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 22 p: 81 pc: 0252 sp: FD x: 30 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 22 p: 00 pc: 0254 sp: FD x: 30 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 44 p: 00 pc: 0255 sp: FD x: 30 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 44 p: 00 pc: 024E sp: FD x: 30 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 44 p: 81 pc: 0250 sp: FD x: 30 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 44 p: 81 pc: 0252 sp: FD x: 30 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 44 p: 00 pc: 0254 sp: FD x: 30 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 88 p: 80 pc: 0255 sp: FD x: 30 y: 06 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 88 p: 80 pc: 0257 sp: FD x: 30 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 88 p: 80 pc: 0259 sp: FD x: 30 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E3 p: 80 pc: 025B sp: FD x: 30 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E3 p: 00 pc: 025D sp: FD x: 30 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: E3 p: 00 pc: 025F sp: FD x: 30 y: 06 
---
[1]    55 0261: 	sec
[2] a: E3 p: 80 pc: 0261 sp: FD x: 30 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E3 p: 81 pc: 0262 sp: FD x: 30 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 5B p: 40 pc: 0264 sp: FD x: 30 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 5B p: 40 pc: 0266 sp: FD x: 30 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 30 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 30 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 30 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 30 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 30 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 30 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5B p: 40 pc: 025B sp: FD x: 30 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5B p: 40 pc: 025D sp: FD x: 30 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 5B p: 40 pc: 025F sp: FD x: 30 y: 06 
---
[1]    55 0261: 	sec
[2] a: 5B p: 40 pc: 0261 sp: FD x: 30 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5B p: 41 pc: 0262 sp: FD x: 30 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 30 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 30 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 30 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 30 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 30 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 30 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 30 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 30 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 30 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 30 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 30 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 30 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 30 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 30 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 30 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 30 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 30 y: 06 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 30 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 30 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 30 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 30 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 30 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 30 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 30 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 30 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 30 y: 06 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 30 y: 06 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 30 y: 06 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 30 y: 06 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 30 y: 06 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 11 p: 01 pc: 0227 sp: FF x: 30 y: 06 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 11 p: 00 pc: 0229 sp: FF x: 30 y: 06 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 11 p: 00 pc: 022E sp: FF x: 30 y: 06 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: E3 p: 80 pc: 0231 sp: FF x: 30 y: 06 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: E3 p: 00 pc: 0232 sp: FF x: 31 y: 06 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: E3 p: 00 pc: 0235 sp: FF x: 31 y: 06 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: E3 p: 80 pc: 0238 sp: FF x: 31 y: 06 
---
[1]    34 023B: 	lda pstore, x
[2] a: E3 p: 80 pc: 023B sp: FF x: 31 y: 06 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: E5 p: 80 pc: 023E sp: FF x: 31 y: 06 
---
[1]    36 0240: 	bmi checkp
[2] a: E5 p: 81 pc: 0240 sp: FF x: 31 y: 06 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: E5 p: 81 pc: 0211 sp: FF x: 31 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: E5 p: 01 pc: 0213 sp: FF x: 31 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: E5 p: 81 pc: 0216 sp: FF x: 31 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: E5 p: 81 pc: 0218 sp: FF x: 31 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 31 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 31 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 31 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 31 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 31 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 31 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 31 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 31 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 31 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 31 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 31 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 31 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 31 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 31 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 31 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 31 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 31 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 31 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 31 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 31 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 31 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 31 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 31 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 31 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 31 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 31 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 31 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 31 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 31 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 31 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 31 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 31 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 31 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 31 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 31 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 31 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 31 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 31 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 31 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E5 p: 80 pc: 025B sp: FD x: 31 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E5 p: 00 pc: 025D sp: FD x: 31 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: E5 p: 00 pc: 025F sp: FD x: 31 y: 01 
---
[1]    55 0261: 	sec
[2] a: E5 p: 80 pc: 0261 sp: FD x: 31 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E5 p: 81 pc: 0262 sp: FD x: 31 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 25 p: 00 pc: 0264 sp: FD x: 31 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 25 p: 00 pc: 0266 sp: FD x: 31 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 31 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 31 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 31 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 31 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 31 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 31 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 31 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 81 pc: 025D sp: FD x: 31 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 81 pc: 026C sp: FD x: 31 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 00 pc: 026E sp: FD x: 31 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 00 pc: 0270 sp: FD x: 31 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 25 p: 00 pc: 0259 sp: FD x: 31 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 31 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 81 pc: 025D sp: FD x: 31 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 25 p: 81 pc: 026C sp: FD x: 31 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 25 p: 00 pc: 026E sp: FD x: 31 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 25 p: 00 pc: 0270 sp: FD x: 31 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 25 p: 00 pc: 0259 sp: FD x: 31 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 31 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 31 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 31 y: 01 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 31 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 31 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 31 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 31 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 31 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 48 p: 00 pc: 026A sp: FD x: 31 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 48 p: 00 pc: 026C sp: FD x: 31 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 48 p: 00 pc: 026E sp: FD x: 31 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 48 p: 00 pc: 0270 sp: FD x: 31 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 48 p: 00 pc: 0259 sp: FD x: 31 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 31 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 31 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 31 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 31 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 31 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 31 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 31 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 48 p: 00 pc: 0268 sp: FD x: 31 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4C p: 00 pc: 026A sp: FD x: 31 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4C p: 00 pc: 026C sp: FD x: 31 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4C p: 00 pc: 026E sp: FD x: 31 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4C p: 00 pc: 0270 sp: FD x: 31 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4C p: 00 pc: 0259 sp: FD x: 31 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 31 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 31 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 31 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 31 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 31 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 31 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 31 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 31 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 31 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 31 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 31 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 31 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 31 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 31 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 31 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 31 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 31 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 31 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 31 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 31 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: E5 p: 81 pc: 0216 sp: FF x: 31 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: E5 p: 81 pc: 0218 sp: FF x: 31 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 31 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 31 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 31 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 31 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 31 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 31 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 31 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 31 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 31 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 31 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 31 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 31 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 31 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 31 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 31 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 31 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 31 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 31 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 31 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 31 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 31 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 31 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 31 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 31 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 31 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 31 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 31 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 31 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 31 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 31 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 31 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 31 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 31 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 31 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E5 p: 80 pc: 025B sp: FD x: 31 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E5 p: 00 pc: 025D sp: FD x: 31 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: E5 p: 00 pc: 025F sp: FD x: 31 y: 02 
---
[1]    55 0261: 	sec
[2] a: E5 p: 80 pc: 0261 sp: FD x: 31 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E5 p: 81 pc: 0262 sp: FD x: 31 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 45 p: 40 pc: 0264 sp: FD x: 31 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 45 p: 40 pc: 0266 sp: FD x: 31 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 31 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 31 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 31 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 31 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 31 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 31 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 45 p: 40 pc: 025B sp: FD x: 31 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 45 p: C1 pc: 025D sp: FD x: 31 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 45 p: C1 pc: 026C sp: FD x: 31 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 45 p: 40 pc: 026E sp: FD x: 31 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 45 p: 40 pc: 0270 sp: FD x: 31 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 45 p: 40 pc: 0259 sp: FD x: 31 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 45 p: 40 pc: 025B sp: FD x: 31 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 45 p: 40 pc: 025D sp: FD x: 31 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 45 p: 40 pc: 025F sp: FD x: 31 y: 02 
---
[1]    55 0261: 	sec
[2] a: 45 p: 40 pc: 0261 sp: FD x: 31 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 45 p: 41 pc: 0262 sp: FD x: 31 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 1D p: 00 pc: 0264 sp: FD x: 31 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 1D p: 00 pc: 0266 sp: FD x: 31 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 31 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 31 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 31 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 31 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 31 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 31 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 31 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 31 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 31 y: 02 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 31 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 31 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 31 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 31 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 31 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 31 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 31 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 31 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 31 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 31 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 31 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 31 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 31 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 31 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 31 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 31 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 31 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 31 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 31 y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 31 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 31 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 31 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 31 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2C p: 00 pc: 0268 sp: FD x: 31 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2D p: 00 pc: 026A sp: FD x: 31 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2D p: 00 pc: 026C sp: FD x: 31 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2D p: 01 pc: 026E sp: FD x: 31 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2D p: 03 pc: 0270 sp: FD x: 31 y: 02 
---
[1]    64 0272: 	rts
[2] a: 2D p: 03 pc: 0272 sp: FD x: 31 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 2D p: 03 pc: 0220 sp: FF x: 31 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 31 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 31 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 31 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 31 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 31 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 31 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 31 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: E5 p: 81 pc: 0216 sp: FF x: 31 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: E5 p: 81 pc: 0218 sp: FF x: 31 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 31 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 31 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 31 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 31 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 31 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 31 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 31 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 31 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 31 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 31 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 31 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 31 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 31 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 31 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 31 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 31 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 31 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 31 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 31 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 31 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 31 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 31 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 31 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 31 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 31 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 31 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 31 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 31 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 31 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 31 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 31 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 31 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 31 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 31 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E5 p: 80 pc: 025B sp: FD x: 31 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E5 p: 00 pc: 025D sp: FD x: 31 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: E5 p: 00 pc: 025F sp: FD x: 31 y: 03 
---
[1]    55 0261: 	sec
[2] a: E5 p: 80 pc: 0261 sp: FD x: 31 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E5 p: 81 pc: 0262 sp: FD x: 31 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 31 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 31 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 31 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 31 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 31 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 31 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 31 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 31 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 31 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 31 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 31 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 31 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 31 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 31 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 31 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 31 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 31 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 31 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 31 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 31 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 31 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 31 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 31 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 31 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 31 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 31 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 31 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 31 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 31 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 31 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 31 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 31 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 31 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 31 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 31 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 31 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 31 y: 03 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 31 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 31 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 31 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 31 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 31 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 31 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 31 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 31 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 31 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: E5 p: 81 pc: 0216 sp: FF x: 31 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: E5 p: 81 pc: 0218 sp: FF x: 31 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 31 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 31 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 31 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 31 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 31 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 31 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 31 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 31 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 31 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 31 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 31 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 31 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 31 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 31 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 31 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 31 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 31 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 31 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 31 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 31 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 31 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 31 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 31 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 31 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 31 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 31 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 31 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 31 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 31 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E5 p: 80 pc: 025B sp: FD x: 31 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E5 p: 00 pc: 025D sp: FD x: 31 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: E5 p: 00 pc: 025F sp: FD x: 31 y: 04 
---
[1]    55 0261: 	sec
[2] a: E5 p: 80 pc: 0261 sp: FD x: 31 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E5 p: 81 pc: 0262 sp: FD x: 31 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 35 p: 00 pc: 0264 sp: FD x: 31 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 35 p: 00 pc: 0266 sp: FD x: 31 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 31 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 31 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 31 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 31 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 31 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 31 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 31 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 81 pc: 025D sp: FD x: 31 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 35 p: 81 pc: 026C sp: FD x: 31 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 35 p: 00 pc: 026E sp: FD x: 31 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 35 p: 00 pc: 0270 sp: FD x: 31 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 35 p: 00 pc: 0259 sp: FD x: 31 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 31 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 00 pc: 025D sp: FD x: 31 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 35 p: 00 pc: 025F sp: FD x: 31 y: 04 
---
[1]    55 0261: 	sec
[2] a: 35 p: 00 pc: 0261 sp: FD x: 31 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 35 p: 01 pc: 0262 sp: FD x: 31 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 31 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 31 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 31 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 31 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 31 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 31 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 31 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 31 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 31 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 31 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 31 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 31 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 31 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 31 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 31 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 31 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 31 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 31 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 31 y: 04 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 31 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 31 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 09 p: 01 pc: 0222 sp: FF x: 31 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 09 p: 01 pc: 0224 sp: FF x: 31 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 31 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 31 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 31 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 31 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 31 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: E5 p: 81 pc: 0216 sp: FF x: 31 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: E5 p: 81 pc: 0218 sp: FF x: 31 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 31 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 31 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 31 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 31 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 31 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 31 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 31 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 31 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 31 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 31 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 31 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 31 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 31 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 31 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 31 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 31 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 31 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 31 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 31 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 31 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 31 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 31 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 31 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 31 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 31 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 31 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 31 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 31 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 31 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E5 p: 80 pc: 025B sp: FD x: 31 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E5 p: 00 pc: 025D sp: FD x: 31 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: E5 p: 00 pc: 025F sp: FD x: 31 y: 05 
---
[1]    55 0261: 	sec
[2] a: E5 p: 80 pc: 0261 sp: FD x: 31 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E5 p: 81 pc: 0262 sp: FD x: 31 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 31 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 31 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 31 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 31 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 31 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 31 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 31 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 31 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 31 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 31 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 31 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 31 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 31 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 31 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 31 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 31 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 31 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 31 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 31 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 31 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 31 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 31 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 31 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 31 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 31 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 31 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 31 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 31 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 31 y: 05 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 31 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 31 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 08 p: 00 pc: 0264 sp: FD x: 31 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 08 p: 00 pc: 0266 sp: FD x: 31 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 31 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 31 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 31 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 31 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 31 y: 05 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 31 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 31 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 08 p: 01 pc: 0222 sp: FF x: 31 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 08 p: 01 pc: 0224 sp: FF x: 31 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 31 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 81 pc: 0229 sp: FF x: 31 y: 05 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0D p: 81 pc: 022B sp: FF x: 31 y: 05 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0D p: 01 pc: 022C sp: FF x: 31 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 31 y: 06 
---
[1]    18 0216: 	sta dividend
[2] a: E5 p: 81 pc: 0216 sp: FF x: 31 y: 06 
---
[1]    19 0218: 	lda pstore, y
[2] a: E5 p: 81 pc: 0218 sp: FF x: 31 y: 06 
---
[1]    20 021B: 	sta divisor
[2] a: 11 p: 01 pc: 021B sp: FF x: 31 y: 06 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 11 p: 01 pc: 021D sp: FF x: 31 y: 06 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 11 p: 01 pc: 0244 sp: FD x: 31 y: 06 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 31 y: 06 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 31 y: 06 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 31 y: 06 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 31 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 11 p: 01 pc: 024E sp: FD x: 31 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 11 p: 81 pc: 0250 sp: FD x: 31 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 11 p: 81 pc: 0252 sp: FD x: 31 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 11 p: 00 pc: 0254 sp: FD x: 31 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 22 p: 00 pc: 0255 sp: FD x: 31 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 22 p: 00 pc: 024E sp: FD x: 31 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 22 p: 81 pc: 0250 sp: FD x: 31 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 22 p: 81 pc: 0252 sp: FD x: 31 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 22 p: 00 pc: 0254 sp: FD x: 31 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 44 p: 00 pc: 0255 sp: FD x: 31 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 44 p: 00 pc: 024E sp: FD x: 31 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 44 p: 81 pc: 0250 sp: FD x: 31 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 44 p: 81 pc: 0252 sp: FD x: 31 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 44 p: 00 pc: 0254 sp: FD x: 31 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 88 p: 80 pc: 0255 sp: FD x: 31 y: 06 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 88 p: 80 pc: 0257 sp: FD x: 31 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 88 p: 80 pc: 0259 sp: FD x: 31 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E5 p: 80 pc: 025B sp: FD x: 31 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E5 p: 00 pc: 025D sp: FD x: 31 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: E5 p: 00 pc: 025F sp: FD x: 31 y: 06 
---
[1]    55 0261: 	sec
[2] a: E5 p: 80 pc: 0261 sp: FD x: 31 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E5 p: 81 pc: 0262 sp: FD x: 31 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 5D p: 40 pc: 0264 sp: FD x: 31 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 5D p: 40 pc: 0266 sp: FD x: 31 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 31 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 31 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 31 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 31 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 31 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 31 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5D p: 40 pc: 025B sp: FD x: 31 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5D p: 40 pc: 025D sp: FD x: 31 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 5D p: 40 pc: 025F sp: FD x: 31 y: 06 
---
[1]    55 0261: 	sec
[2] a: 5D p: 40 pc: 0261 sp: FD x: 31 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5D p: 41 pc: 0262 sp: FD x: 31 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 31 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 31 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 31 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 31 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 31 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 31 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 31 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 31 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 31 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 31 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 31 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 31 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 31 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 31 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 31 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 31 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 31 y: 06 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 31 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 31 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 08 p: 00 pc: 0264 sp: FD x: 31 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 08 p: 00 pc: 0266 sp: FD x: 31 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 31 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 31 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 31 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 31 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 31 y: 06 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 31 y: 06 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 31 y: 06 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 08 p: 01 pc: 0222 sp: FF x: 31 y: 06 
---
[1]    24 0224: 	lda pstore, y
[2] a: 08 p: 01 pc: 0224 sp: FF x: 31 y: 06 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 11 p: 01 pc: 0227 sp: FF x: 31 y: 06 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 11 p: 00 pc: 0229 sp: FF x: 31 y: 06 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 11 p: 00 pc: 022E sp: FF x: 31 y: 06 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: E5 p: 80 pc: 0231 sp: FF x: 31 y: 06 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: E5 p: 00 pc: 0232 sp: FF x: 32 y: 06 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: E5 p: 00 pc: 0235 sp: FF x: 32 y: 06 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: E5 p: 80 pc: 0238 sp: FF x: 32 y: 06 
---
[1]    34 023B: 	lda pstore, x
[2] a: E5 p: 80 pc: 023B sp: FF x: 32 y: 06 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: E7 p: 80 pc: 023E sp: FF x: 32 y: 06 
---
[1]    36 0240: 	bmi checkp
[2] a: E7 p: 81 pc: 0240 sp: FF x: 32 y: 06 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: E7 p: 81 pc: 0211 sp: FF x: 32 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: E7 p: 01 pc: 0213 sp: FF x: 32 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: E7 p: 81 pc: 0216 sp: FF x: 32 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: E7 p: 81 pc: 0218 sp: FF x: 32 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 32 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 32 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 32 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 32 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 32 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 32 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 32 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 32 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 32 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 32 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 32 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 32 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 32 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 32 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 32 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 32 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 32 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 32 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 32 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 32 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 32 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 32 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 32 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 32 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 32 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 32 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 32 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 32 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 32 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 32 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 32 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 32 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 32 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 32 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 32 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 32 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 32 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E7 p: 80 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E7 p: 00 pc: 025D sp: FD x: 32 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: E7 p: 00 pc: 025F sp: FD x: 32 y: 01 
---
[1]    55 0261: 	sec
[2] a: E7 p: 80 pc: 0261 sp: FD x: 32 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E7 p: 81 pc: 0262 sp: FD x: 32 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 27 p: 00 pc: 0264 sp: FD x: 32 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 27 p: 00 pc: 0266 sp: FD x: 32 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 32 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 81 pc: 025D sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 81 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 00 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 00 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 27 p: 00 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 81 pc: 025D sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 81 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 00 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 00 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 27 p: 00 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 32 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 32 y: 01 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 32 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 32 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 32 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 32 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 32 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 48 p: 00 pc: 026A sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 48 p: 00 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 48 p: 00 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 48 p: 00 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 48 p: 00 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 32 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 32 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 32 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 32 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 32 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 32 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 48 p: 00 pc: 0268 sp: FD x: 32 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4C p: 00 pc: 026A sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4C p: 00 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4C p: 00 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4C p: 00 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4C p: 00 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 32 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 32 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 32 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 32 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 32 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 32 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 4C p: 00 pc: 0268 sp: FD x: 32 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4D p: 00 pc: 026A sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4D p: 00 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4D p: 01 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4D p: 03 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    64 0272: 	rts
[2] a: 4D p: 03 pc: 0272 sp: FD x: 32 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 4D p: 03 pc: 0220 sp: FF x: 32 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 32 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 32 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 32 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 32 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: E9 p: 81 pc: 023E sp: FF x: 32 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: E9 p: 81 pc: 0240 sp: FF x: 32 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: E9 p: 81 pc: 0211 sp: FF x: 32 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: E9 p: 01 pc: 0213 sp: FF x: 32 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: E9 p: 81 pc: 0216 sp: FF x: 32 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: E9 p: 81 pc: 0218 sp: FF x: 32 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 32 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 32 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 32 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 32 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 32 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 32 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 32 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 32 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 32 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 32 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 32 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 32 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 32 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 32 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 32 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 32 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 32 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 32 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 32 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 32 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 32 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 32 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 32 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 32 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 32 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 32 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 32 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 32 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 32 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 32 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 32 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 32 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 32 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 32 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 32 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 32 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 32 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E9 p: 80 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E9 p: 00 pc: 025D sp: FD x: 32 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: E9 p: 00 pc: 025F sp: FD x: 32 y: 01 
---
[1]    55 0261: 	sec
[2] a: E9 p: 80 pc: 0261 sp: FD x: 32 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E9 p: 81 pc: 0262 sp: FD x: 32 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 29 p: 00 pc: 0264 sp: FD x: 32 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 29 p: 00 pc: 0266 sp: FD x: 32 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 32 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 81 pc: 025D sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 29 p: 81 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 29 p: 00 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 29 p: 00 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 29 p: 00 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 81 pc: 025D sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 29 p: 81 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 29 p: 00 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 29 p: 00 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 29 p: 00 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 29 p: 00 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 29 p: 00 pc: 025D sp: FD x: 32 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 29 p: 00 pc: 025F sp: FD x: 32 y: 01 
---
[1]    55 0261: 	sec
[2] a: 29 p: 00 pc: 0261 sp: FD x: 32 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 29 p: 01 pc: 0262 sp: FD x: 32 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 32 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 32 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 32 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 48 p: 00 pc: 026A sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 48 p: 00 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 48 p: 00 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 48 p: 00 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 48 p: 00 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 32 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 32 y: 01 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 32 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 32 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 32 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 32 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 48 p: 00 pc: 0268 sp: FD x: 32 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4C p: 00 pc: 026A sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4C p: 00 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4C p: 00 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4C p: 00 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4C p: 00 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 32 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 32 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 32 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 32 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 32 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 32 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 32 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 32 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 4C p: 00 pc: 0268 sp: FD x: 32 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4D p: 00 pc: 026A sp: FD x: 32 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4D p: 00 pc: 026C sp: FD x: 32 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4D p: 01 pc: 026E sp: FD x: 32 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4D p: 03 pc: 0270 sp: FD x: 32 y: 01 
---
[1]    64 0272: 	rts
[2] a: 4D p: 03 pc: 0272 sp: FD x: 32 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 4D p: 03 pc: 0220 sp: FF x: 32 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 32 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 32 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 32 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 32 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 32 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 32 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 32 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: E9 p: 81 pc: 0216 sp: FF x: 32 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: E9 p: 81 pc: 0218 sp: FF x: 32 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 32 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 32 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 32 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 32 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 32 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 32 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 32 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 32 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 32 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 32 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 32 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 32 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 32 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 32 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 32 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 32 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 32 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 32 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 32 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 32 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 32 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 32 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 32 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 32 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 32 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 32 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 32 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 32 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 32 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 32 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 32 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 32 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 32 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 32 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E9 p: 80 pc: 025B sp: FD x: 32 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E9 p: 00 pc: 025D sp: FD x: 32 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: E9 p: 00 pc: 025F sp: FD x: 32 y: 02 
---
[1]    55 0261: 	sec
[2] a: E9 p: 80 pc: 0261 sp: FD x: 32 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E9 p: 81 pc: 0262 sp: FD x: 32 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 49 p: 40 pc: 0264 sp: FD x: 32 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 49 p: 40 pc: 0266 sp: FD x: 32 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 32 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 32 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 32 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 32 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 32 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 32 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 49 p: 40 pc: 025B sp: FD x: 32 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 49 p: C1 pc: 025D sp: FD x: 32 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 49 p: C1 pc: 026C sp: FD x: 32 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 49 p: 40 pc: 026E sp: FD x: 32 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 49 p: 40 pc: 0270 sp: FD x: 32 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 49 p: 40 pc: 0259 sp: FD x: 32 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 49 p: 40 pc: 025B sp: FD x: 32 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 49 p: 40 pc: 025D sp: FD x: 32 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 49 p: 40 pc: 025F sp: FD x: 32 y: 02 
---
[1]    55 0261: 	sec
[2] a: 49 p: 40 pc: 0261 sp: FD x: 32 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 49 p: 41 pc: 0262 sp: FD x: 32 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 32 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 32 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 32 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 32 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 32 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 32 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 32 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 32 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 32 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 32 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 32 y: 02 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 32 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 32 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 32 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 32 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 32 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 32 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 32 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 32 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 32 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 32 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 32 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 32 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 32 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 32 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 32 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 32 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 32 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2C p: 00 pc: 0268 sp: FD x: 32 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2E p: 00 pc: 026A sp: FD x: 32 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2E p: 00 pc: 026C sp: FD x: 32 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2E p: 00 pc: 026E sp: FD x: 32 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2E p: 00 pc: 0270 sp: FD x: 32 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2E p: 00 pc: 0259 sp: FD x: 32 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 32 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 32 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 32 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 32 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 32 y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 32 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 32 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 32 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 32 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 32 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 32 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 32 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 32 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 32 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: E9 p: 81 pc: 0216 sp: FF x: 32 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: E9 p: 81 pc: 0218 sp: FF x: 32 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 32 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 32 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 32 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 32 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 32 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 32 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 32 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 32 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 32 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 32 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 32 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 32 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 32 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 32 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 32 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 32 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 32 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 32 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 32 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 32 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 32 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 32 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 32 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 32 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 32 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 32 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 32 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 32 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 32 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 32 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 32 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 32 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 32 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 32 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E9 p: 80 pc: 025B sp: FD x: 32 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E9 p: 00 pc: 025D sp: FD x: 32 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: E9 p: 00 pc: 025F sp: FD x: 32 y: 03 
---
[1]    55 0261: 	sec
[2] a: E9 p: 80 pc: 0261 sp: FD x: 32 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E9 p: 81 pc: 0262 sp: FD x: 32 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 32 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 32 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 32 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 32 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 32 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 32 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 32 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 32 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 32 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 32 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 32 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 32 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 32 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 32 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 32 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 32 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 32 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 32 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 32 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 32 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 32 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 32 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 32 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 32 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 32 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 32 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 32 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 32 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 32 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 32 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 32 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 32 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 32 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 32 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 32 y: 03 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 32 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 32 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 32 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 32 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 32 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 21 p: 00 pc: 026A sp: FD x: 32 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 00 pc: 026C sp: FD x: 32 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 01 pc: 026E sp: FD x: 32 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 03 pc: 0270 sp: FD x: 32 y: 03 
---
[1]    64 0272: 	rts
[2] a: 21 p: 03 pc: 0272 sp: FD x: 32 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 21 p: 03 pc: 0220 sp: FF x: 32 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 32 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 32 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 32 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 32 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 32 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 32 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 32 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: E9 p: 81 pc: 0216 sp: FF x: 32 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: E9 p: 81 pc: 0218 sp: FF x: 32 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 32 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 32 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 32 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 32 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 32 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 32 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 32 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 32 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 32 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 32 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 32 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 32 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 32 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 32 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 32 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 32 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 32 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 32 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 32 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 32 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 32 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 32 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 32 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 32 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 32 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 32 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 32 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 32 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 32 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E9 p: 80 pc: 025B sp: FD x: 32 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E9 p: 00 pc: 025D sp: FD x: 32 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: E9 p: 00 pc: 025F sp: FD x: 32 y: 04 
---
[1]    55 0261: 	sec
[2] a: E9 p: 80 pc: 0261 sp: FD x: 32 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E9 p: 81 pc: 0262 sp: FD x: 32 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 39 p: 00 pc: 0264 sp: FD x: 32 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 39 p: 00 pc: 0266 sp: FD x: 32 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 32 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 32 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 32 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 32 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 32 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 32 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 32 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 81 pc: 025D sp: FD x: 32 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 39 p: 81 pc: 026C sp: FD x: 32 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 39 p: 00 pc: 026E sp: FD x: 32 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 39 p: 00 pc: 0270 sp: FD x: 32 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 39 p: 00 pc: 0259 sp: FD x: 32 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 32 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 00 pc: 025D sp: FD x: 32 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 39 p: 00 pc: 025F sp: FD x: 32 y: 04 
---
[1]    55 0261: 	sec
[2] a: 39 p: 00 pc: 0261 sp: FD x: 32 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 39 p: 01 pc: 0262 sp: FD x: 32 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 32 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 32 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 32 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 32 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 32 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 32 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 32 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 32 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 32 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 32 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 32 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 32 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 32 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 32 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 32 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 32 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 32 y: 04 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 32 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 32 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 32 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 32 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 32 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 15 p: 00 pc: 026A sp: FD x: 32 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 00 pc: 026C sp: FD x: 32 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 01 pc: 026E sp: FD x: 32 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 03 pc: 0270 sp: FD x: 32 y: 04 
---
[1]    64 0272: 	rts
[2] a: 15 p: 03 pc: 0272 sp: FD x: 32 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 15 p: 03 pc: 0220 sp: FF x: 32 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 32 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 32 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 32 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 32 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 32 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 32 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 32 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: E9 p: 81 pc: 0216 sp: FF x: 32 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: E9 p: 81 pc: 0218 sp: FF x: 32 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 32 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 32 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 32 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 32 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 32 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 32 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 32 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 32 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 32 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 32 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 32 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 32 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 32 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 32 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 32 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 32 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 32 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 32 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 32 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 32 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 32 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 32 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 32 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 32 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 32 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 32 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 32 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 32 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 32 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E9 p: 80 pc: 025B sp: FD x: 32 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E9 p: 00 pc: 025D sp: FD x: 32 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: E9 p: 00 pc: 025F sp: FD x: 32 y: 05 
---
[1]    55 0261: 	sec
[2] a: E9 p: 80 pc: 0261 sp: FD x: 32 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E9 p: 81 pc: 0262 sp: FD x: 32 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 19 p: 00 pc: 0264 sp: FD x: 32 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 19 p: 00 pc: 0266 sp: FD x: 32 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 32 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 32 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 32 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 32 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 32 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 32 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 32 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 32 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 32 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 32 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 32 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 32 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 32 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 32 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 32 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 32 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 32 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 32 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 32 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 81 pc: 025D sp: FD x: 32 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 19 p: 81 pc: 026C sp: FD x: 32 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 19 p: 00 pc: 026E sp: FD x: 32 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 19 p: 00 pc: 0270 sp: FD x: 32 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 19 p: 00 pc: 0259 sp: FD x: 32 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 19 p: 00 pc: 025B sp: FD x: 32 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 19 p: 00 pc: 025D sp: FD x: 32 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 19 p: 00 pc: 025F sp: FD x: 32 y: 05 
---
[1]    55 0261: 	sec
[2] a: 19 p: 00 pc: 0261 sp: FD x: 32 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 19 p: 01 pc: 0262 sp: FD x: 32 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 0C p: 00 pc: 0264 sp: FD x: 32 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 0C p: 00 pc: 0266 sp: FD x: 32 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 32 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 11 p: 00 pc: 026A sp: FD x: 32 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 00 pc: 026C sp: FD x: 32 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 01 pc: 026E sp: FD x: 32 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 03 pc: 0270 sp: FD x: 32 y: 05 
---
[1]    64 0272: 	rts
[2] a: 11 p: 03 pc: 0272 sp: FD x: 32 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 11 p: 03 pc: 0220 sp: FF x: 32 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0C p: 01 pc: 0222 sp: FF x: 32 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0C p: 01 pc: 0224 sp: FF x: 32 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 32 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 81 pc: 0229 sp: FF x: 32 y: 05 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0D p: 81 pc: 022B sp: FF x: 32 y: 05 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0D p: 01 pc: 022C sp: FF x: 32 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 32 y: 06 
---
[1]    18 0216: 	sta dividend
[2] a: E9 p: 81 pc: 0216 sp: FF x: 32 y: 06 
---
[1]    19 0218: 	lda pstore, y
[2] a: E9 p: 81 pc: 0218 sp: FF x: 32 y: 06 
---
[1]    20 021B: 	sta divisor
[2] a: 11 p: 01 pc: 021B sp: FF x: 32 y: 06 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 11 p: 01 pc: 021D sp: FF x: 32 y: 06 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 11 p: 01 pc: 0244 sp: FD x: 32 y: 06 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 32 y: 06 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 32 y: 06 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 32 y: 06 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 32 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 11 p: 01 pc: 024E sp: FD x: 32 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 11 p: 81 pc: 0250 sp: FD x: 32 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 11 p: 81 pc: 0252 sp: FD x: 32 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 11 p: 00 pc: 0254 sp: FD x: 32 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 22 p: 00 pc: 0255 sp: FD x: 32 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 22 p: 00 pc: 024E sp: FD x: 32 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 22 p: 81 pc: 0250 sp: FD x: 32 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 22 p: 81 pc: 0252 sp: FD x: 32 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 22 p: 00 pc: 0254 sp: FD x: 32 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 44 p: 00 pc: 0255 sp: FD x: 32 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 44 p: 00 pc: 024E sp: FD x: 32 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 44 p: 81 pc: 0250 sp: FD x: 32 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 44 p: 81 pc: 0252 sp: FD x: 32 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 44 p: 00 pc: 0254 sp: FD x: 32 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 88 p: 80 pc: 0255 sp: FD x: 32 y: 06 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 88 p: 80 pc: 0257 sp: FD x: 32 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 88 p: 80 pc: 0259 sp: FD x: 32 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: E9 p: 80 pc: 025B sp: FD x: 32 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: E9 p: 00 pc: 025D sp: FD x: 32 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: E9 p: 00 pc: 025F sp: FD x: 32 y: 06 
---
[1]    55 0261: 	sec
[2] a: E9 p: 80 pc: 0261 sp: FD x: 32 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: E9 p: 81 pc: 0262 sp: FD x: 32 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 61 p: 40 pc: 0264 sp: FD x: 32 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 61 p: 40 pc: 0266 sp: FD x: 32 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 32 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 32 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 32 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 32 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 32 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 32 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 61 p: 40 pc: 025B sp: FD x: 32 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 61 p: 40 pc: 025D sp: FD x: 32 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 61 p: 40 pc: 025F sp: FD x: 32 y: 06 
---
[1]    55 0261: 	sec
[2] a: 61 p: 40 pc: 0261 sp: FD x: 32 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 61 p: 41 pc: 0262 sp: FD x: 32 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 1D p: 00 pc: 0264 sp: FD x: 32 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 1D p: 00 pc: 0266 sp: FD x: 32 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 32 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 32 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 32 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 32 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 32 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 32 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 32 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 81 pc: 025D sp: FD x: 32 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 81 pc: 026C sp: FD x: 32 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 00 pc: 026E sp: FD x: 32 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 00 pc: 0270 sp: FD x: 32 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1D p: 00 pc: 0259 sp: FD x: 32 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 32 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 32 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 32 y: 06 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 32 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 32 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 0C p: 00 pc: 0264 sp: FD x: 32 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 0C p: 00 pc: 0266 sp: FD x: 32 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 32 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0D p: 00 pc: 026A sp: FD x: 32 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 00 pc: 026C sp: FD x: 32 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 32 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 32 y: 06 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 32 y: 06 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 32 y: 06 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0C p: 01 pc: 0222 sp: FF x: 32 y: 06 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0C p: 01 pc: 0224 sp: FF x: 32 y: 06 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 11 p: 01 pc: 0227 sp: FF x: 32 y: 06 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 11 p: 00 pc: 0229 sp: FF x: 32 y: 06 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 11 p: 00 pc: 022E sp: FF x: 32 y: 06 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: E9 p: 80 pc: 0231 sp: FF x: 32 y: 06 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: E9 p: 00 pc: 0232 sp: FF x: 33 y: 06 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: E9 p: 00 pc: 0235 sp: FF x: 33 y: 06 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: E9 p: 80 pc: 0238 sp: FF x: 33 y: 06 
---
[1]    34 023B: 	lda pstore, x
[2] a: E9 p: 80 pc: 023B sp: FF x: 33 y: 06 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: EB p: 80 pc: 023E sp: FF x: 33 y: 06 
---
[1]    36 0240: 	bmi checkp
[2] a: EB p: 81 pc: 0240 sp: FF x: 33 y: 06 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: EB p: 81 pc: 0211 sp: FF x: 33 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: EB p: 01 pc: 0213 sp: FF x: 33 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: EB p: 81 pc: 0216 sp: FF x: 33 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: EB p: 81 pc: 0218 sp: FF x: 33 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 33 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 33 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 33 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 33 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 33 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 33 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: EB p: 80 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: EB p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: EB p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: EB p: 80 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: EB p: 81 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 2B p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 2B p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 81 pc: 025D sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 81 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2B p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 81 pc: 025D sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 81 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2B p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2B p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: 2B p: 00 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2B p: 01 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 48 p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 48 p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 48 p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 48 p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 48 p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 48 p: 00 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4C p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4C p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4C p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4C p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4C p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 4C p: 00 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4E p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4E p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4E p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4E p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4E p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 33 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 33 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 33 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 33 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 33 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 33 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 33 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 33 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 33 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: EB p: 81 pc: 0216 sp: FF x: 33 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: EB p: 81 pc: 0218 sp: FF x: 33 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 33 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 33 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 33 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 33 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 33 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 33 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 33 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 33 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 33 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 33 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 33 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 33 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 33 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 33 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 33 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 33 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 33 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 33 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 33 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 33 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 33 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 33 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 33 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 33 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 33 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 33 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 33 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 33 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 33 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 33 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 33 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 33 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 33 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 33 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: EB p: 80 pc: 025B sp: FD x: 33 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: EB p: 00 pc: 025D sp: FD x: 33 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: EB p: 00 pc: 025F sp: FD x: 33 y: 02 
---
[1]    55 0261: 	sec
[2] a: EB p: 80 pc: 0261 sp: FD x: 33 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: EB p: 81 pc: 0262 sp: FD x: 33 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 4B p: 40 pc: 0264 sp: FD x: 33 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 4B p: 40 pc: 0266 sp: FD x: 33 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 33 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 33 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 33 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 33 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 33 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 33 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4B p: 40 pc: 025B sp: FD x: 33 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4B p: C1 pc: 025D sp: FD x: 33 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4B p: C1 pc: 026C sp: FD x: 33 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 4B p: 40 pc: 026E sp: FD x: 33 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4B p: 40 pc: 0270 sp: FD x: 33 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4B p: 40 pc: 0259 sp: FD x: 33 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4B p: 40 pc: 025B sp: FD x: 33 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4B p: 40 pc: 025D sp: FD x: 33 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 4B p: 40 pc: 025F sp: FD x: 33 y: 02 
---
[1]    55 0261: 	sec
[2] a: 4B p: 40 pc: 0261 sp: FD x: 33 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4B p: 41 pc: 0262 sp: FD x: 33 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 33 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 33 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 33 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 33 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 33 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 33 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 33 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 33 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 33 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 33 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 33 y: 02 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 33 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 33 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 33 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 33 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 33 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 33 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 33 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 33 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 33 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 33 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 33 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 33 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 33 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 33 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 33 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 33 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 33 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2C p: 00 pc: 0268 sp: FD x: 33 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2E p: 00 pc: 026A sp: FD x: 33 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2E p: 00 pc: 026C sp: FD x: 33 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2E p: 00 pc: 026E sp: FD x: 33 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2E p: 00 pc: 0270 sp: FD x: 33 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2E p: 00 pc: 0259 sp: FD x: 33 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 33 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 33 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 33 y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 33 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 33 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 33 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 33 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2E p: 00 pc: 0268 sp: FD x: 33 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2F p: 00 pc: 026A sp: FD x: 33 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2F p: 00 pc: 026C sp: FD x: 33 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2F p: 01 pc: 026E sp: FD x: 33 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2F p: 03 pc: 0270 sp: FD x: 33 y: 02 
---
[1]    64 0272: 	rts
[2] a: 2F p: 03 pc: 0272 sp: FD x: 33 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 2F p: 03 pc: 0220 sp: FF x: 33 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 33 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 33 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 33 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 33 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: ED p: 81 pc: 023E sp: FF x: 33 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: ED p: 81 pc: 0240 sp: FF x: 33 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: ED p: 81 pc: 0211 sp: FF x: 33 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: ED p: 01 pc: 0213 sp: FF x: 33 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: ED p: 81 pc: 0216 sp: FF x: 33 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: ED p: 81 pc: 0218 sp: FF x: 33 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 33 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 33 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 33 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 33 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 33 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 33 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: ED p: 80 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: ED p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: ED p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: ED p: 80 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: ED p: 81 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 2D p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 2D p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 81 pc: 025D sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2D p: 81 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2D p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2D p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2D p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 81 pc: 025D sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2D p: 81 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2D p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2D p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2D p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2D p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2D p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2D p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: 2D p: 00 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2D p: 01 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 48 p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 48 p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 48 p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 48 p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 48 p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 48 p: 00 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4C p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4C p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4C p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4C p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4C p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 4C p: 00 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4E p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4E p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4E p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4E p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4E p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 4E p: 00 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4F p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4F p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4F p: 01 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4F p: 03 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    64 0272: 	rts
[2] a: 4F p: 03 pc: 0272 sp: FD x: 33 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 4F p: 03 pc: 0220 sp: FF x: 33 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 33 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 33 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 33 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 33 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: EF p: 81 pc: 023E sp: FF x: 33 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: EF p: 81 pc: 0240 sp: FF x: 33 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: EF p: 81 pc: 0211 sp: FF x: 33 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: EF p: 01 pc: 0213 sp: FF x: 33 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: EF p: 81 pc: 0216 sp: FF x: 33 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: EF p: 81 pc: 0218 sp: FF x: 33 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 33 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 33 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 33 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 33 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 33 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 33 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 33 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 33 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 33 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 33 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 33 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: EF p: 80 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: EF p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: EF p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: EF p: 80 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: EF p: 81 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 2F p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 2F p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 81 pc: 025D sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2F p: 81 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2F p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2F p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2F p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 81 pc: 025D sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2F p: 81 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 2F p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2F p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2F p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 2F p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: 2F p: 00 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2F p: 01 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 48 p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 48 p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 48 p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 48 p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 48 p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 48 p: 00 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4C p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4C p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4C p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4C p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4C p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 4C p: 00 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4E p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4E p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4E p: 00 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4E p: 00 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4E p: 00 pc: 0259 sp: FD x: 33 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 33 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 33 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 33 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 33 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 33 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 33 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 33 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 4E p: 00 pc: 0268 sp: FD x: 33 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 4F p: 00 pc: 026A sp: FD x: 33 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4F p: 00 pc: 026C sp: FD x: 33 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 4F p: 01 pc: 026E sp: FD x: 33 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4F p: 03 pc: 0270 sp: FD x: 33 y: 01 
---
[1]    64 0272: 	rts
[2] a: 4F p: 03 pc: 0272 sp: FD x: 33 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 4F p: 03 pc: 0220 sp: FF x: 33 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 33 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 33 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 33 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 33 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 33 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 33 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 33 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: EF p: 81 pc: 0216 sp: FF x: 33 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: EF p: 81 pc: 0218 sp: FF x: 33 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 33 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 33 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 33 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 33 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 33 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 33 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 33 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 33 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 33 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 33 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 33 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 33 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 33 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 33 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 33 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 33 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 33 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 33 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 33 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 33 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 33 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 33 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 33 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 33 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 33 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 33 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 33 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 33 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 33 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 33 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 33 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 33 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 33 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 33 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: EF p: 80 pc: 025B sp: FD x: 33 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: EF p: 00 pc: 025D sp: FD x: 33 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: EF p: 00 pc: 025F sp: FD x: 33 y: 02 
---
[1]    55 0261: 	sec
[2] a: EF p: 80 pc: 0261 sp: FD x: 33 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: EF p: 81 pc: 0262 sp: FD x: 33 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 4F p: 40 pc: 0264 sp: FD x: 33 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 4F p: 40 pc: 0266 sp: FD x: 33 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 33 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 33 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 33 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 33 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 33 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 33 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 40 pc: 025B sp: FD x: 33 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: C1 pc: 025D sp: FD x: 33 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4F p: C1 pc: 026C sp: FD x: 33 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 4F p: 40 pc: 026E sp: FD x: 33 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4F p: 40 pc: 0270 sp: FD x: 33 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4F p: 40 pc: 0259 sp: FD x: 33 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4F p: 40 pc: 025B sp: FD x: 33 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4F p: 40 pc: 025D sp: FD x: 33 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 4F p: 40 pc: 025F sp: FD x: 33 y: 02 
---
[1]    55 0261: 	sec
[2] a: 4F p: 40 pc: 0261 sp: FD x: 33 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4F p: 41 pc: 0262 sp: FD x: 33 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 27 p: 00 pc: 0264 sp: FD x: 33 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 27 p: 00 pc: 0266 sp: FD x: 33 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 33 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 28 p: 00 pc: 026A sp: FD x: 33 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 28 p: 00 pc: 026C sp: FD x: 33 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 28 p: 00 pc: 026E sp: FD x: 33 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 28 p: 00 pc: 0270 sp: FD x: 33 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 28 p: 00 pc: 0259 sp: FD x: 33 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 33 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 33 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 33 y: 02 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 33 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 33 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 33 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 33 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 28 p: 00 pc: 0268 sp: FD x: 33 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2C p: 00 pc: 026A sp: FD x: 33 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2C p: 00 pc: 026C sp: FD x: 33 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2C p: 00 pc: 026E sp: FD x: 33 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2C p: 00 pc: 0270 sp: FD x: 33 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2C p: 00 pc: 0259 sp: FD x: 33 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 33 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 33 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 33 y: 02 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 33 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 33 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 33 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 33 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2C p: 00 pc: 0268 sp: FD x: 33 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2E p: 00 pc: 026A sp: FD x: 33 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2E p: 00 pc: 026C sp: FD x: 33 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2E p: 00 pc: 026E sp: FD x: 33 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2E p: 00 pc: 0270 sp: FD x: 33 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2E p: 00 pc: 0259 sp: FD x: 33 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 33 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 33 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 33 y: 02 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 33 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 33 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 33 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 33 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 2E p: 00 pc: 0268 sp: FD x: 33 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 2F p: 00 pc: 026A sp: FD x: 33 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2F p: 00 pc: 026C sp: FD x: 33 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 2F p: 01 pc: 026E sp: FD x: 33 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2F p: 03 pc: 0270 sp: FD x: 33 y: 02 
---
[1]    64 0272: 	rts
[2] a: 2F p: 03 pc: 0272 sp: FD x: 33 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 2F p: 03 pc: 0220 sp: FF x: 33 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 33 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 33 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 33 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 33 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 33 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 33 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 33 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: EF p: 81 pc: 0216 sp: FF x: 33 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: EF p: 81 pc: 0218 sp: FF x: 33 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 33 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 33 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 33 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 33 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 33 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 33 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 33 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 33 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 33 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 33 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 33 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 33 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 33 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 33 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 33 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 33 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 33 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 33 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 33 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 33 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 33 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 33 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 33 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 33 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 33 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 33 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 33 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 33 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 33 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 33 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 33 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 33 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 33 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 33 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: EF p: 80 pc: 025B sp: FD x: 33 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: EF p: 00 pc: 025D sp: FD x: 33 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: EF p: 00 pc: 025F sp: FD x: 33 y: 03 
---
[1]    55 0261: 	sec
[2] a: EF p: 80 pc: 0261 sp: FD x: 33 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: EF p: 81 pc: 0262 sp: FD x: 33 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0F p: 00 pc: 0264 sp: FD x: 33 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0F p: 00 pc: 0266 sp: FD x: 33 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 33 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 33 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 33 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 33 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 33 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 33 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 33 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 33 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 33 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 33 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 33 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 33 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 33 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 33 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 33 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 33 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 33 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 33 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 33 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 81 pc: 025D sp: FD x: 33 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0F p: 81 pc: 026C sp: FD x: 33 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 0F p: 00 pc: 026E sp: FD x: 33 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0F p: 00 pc: 0270 sp: FD x: 33 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0F p: 00 pc: 0259 sp: FD x: 33 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0F p: 00 pc: 025B sp: FD x: 33 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0F p: 00 pc: 025D sp: FD x: 33 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0F p: 00 pc: 025F sp: FD x: 33 y: 03 
---
[1]    55 0261: 	sec
[2] a: 0F p: 00 pc: 0261 sp: FD x: 33 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0F p: 01 pc: 0262 sp: FD x: 33 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 33 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 33 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 33 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 22 p: 00 pc: 026A sp: FD x: 33 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 22 p: 00 pc: 026C sp: FD x: 33 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 22 p: 00 pc: 026E sp: FD x: 33 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 22 p: 00 pc: 0270 sp: FD x: 33 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 22 p: 00 pc: 0259 sp: FD x: 33 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 33 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 33 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 33 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 33 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 33 y: 03 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 33 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 33 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 33 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 33 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 33 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 33 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 33 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 33 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 33 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: EF p: 81 pc: 0216 sp: FF x: 33 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: EF p: 81 pc: 0218 sp: FF x: 33 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 33 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 33 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 33 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 33 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 33 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 33 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 33 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 33 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 33 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 33 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 33 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 33 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 33 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 33 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 33 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 33 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 33 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 33 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 33 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 33 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 33 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 33 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 33 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 33 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 33 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 33 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 33 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 33 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 33 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: EF p: 80 pc: 025B sp: FD x: 33 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: EF p: 00 pc: 025D sp: FD x: 33 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: EF p: 00 pc: 025F sp: FD x: 33 y: 04 
---
[1]    55 0261: 	sec
[2] a: EF p: 80 pc: 0261 sp: FD x: 33 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: EF p: 81 pc: 0262 sp: FD x: 33 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 3F p: 00 pc: 0264 sp: FD x: 33 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 3F p: 00 pc: 0266 sp: FD x: 33 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 33 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 33 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 33 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 33 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 33 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 33 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3F p: 00 pc: 025B sp: FD x: 33 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3F p: 81 pc: 025D sp: FD x: 33 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3F p: 81 pc: 026C sp: FD x: 33 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 3F p: 00 pc: 026E sp: FD x: 33 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3F p: 00 pc: 0270 sp: FD x: 33 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3F p: 00 pc: 0259 sp: FD x: 33 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3F p: 00 pc: 025B sp: FD x: 33 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3F p: 00 pc: 025D sp: FD x: 33 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 3F p: 00 pc: 025F sp: FD x: 33 y: 04 
---
[1]    55 0261: 	sec
[2] a: 3F p: 00 pc: 0261 sp: FD x: 33 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3F p: 01 pc: 0262 sp: FD x: 33 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 13 p: 00 pc: 0264 sp: FD x: 33 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 13 p: 00 pc: 0266 sp: FD x: 33 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 33 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 33 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 33 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 33 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 33 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 33 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 33 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 81 pc: 025D sp: FD x: 33 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 81 pc: 026C sp: FD x: 33 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 00 pc: 026E sp: FD x: 33 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 00 pc: 0270 sp: FD x: 33 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 13 p: 00 pc: 0259 sp: FD x: 33 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 13 p: 00 pc: 025B sp: FD x: 33 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 13 p: 00 pc: 025D sp: FD x: 33 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 13 p: 00 pc: 025F sp: FD x: 33 y: 04 
---
[1]    55 0261: 	sec
[2] a: 13 p: 00 pc: 0261 sp: FD x: 33 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 13 p: 01 pc: 0262 sp: FD x: 33 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 08 p: 00 pc: 0264 sp: FD x: 33 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 08 p: 00 pc: 0266 sp: FD x: 33 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 33 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 15 p: 00 pc: 026A sp: FD x: 33 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 00 pc: 026C sp: FD x: 33 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 01 pc: 026E sp: FD x: 33 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 03 pc: 0270 sp: FD x: 33 y: 04 
---
[1]    64 0272: 	rts
[2] a: 15 p: 03 pc: 0272 sp: FD x: 33 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 15 p: 03 pc: 0220 sp: FF x: 33 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 08 p: 01 pc: 0222 sp: FF x: 33 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 08 p: 01 pc: 0224 sp: FF x: 33 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 33 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 33 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 33 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 33 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 33 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: EF p: 81 pc: 0216 sp: FF x: 33 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: EF p: 81 pc: 0218 sp: FF x: 33 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 33 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 33 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 33 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 33 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 33 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 33 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 33 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 33 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 33 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 33 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 33 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 33 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 33 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 33 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 33 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 33 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 33 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 33 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 33 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 33 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 33 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 33 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 33 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 33 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 33 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 33 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 33 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 33 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 33 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: EF p: 80 pc: 025B sp: FD x: 33 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: EF p: 00 pc: 025D sp: FD x: 33 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: EF p: 00 pc: 025F sp: FD x: 33 y: 05 
---
[1]    55 0261: 	sec
[2] a: EF p: 80 pc: 0261 sp: FD x: 33 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: EF p: 81 pc: 0262 sp: FD x: 33 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 1F p: 00 pc: 0264 sp: FD x: 33 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 1F p: 00 pc: 0266 sp: FD x: 33 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 33 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 33 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 33 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 33 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 33 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 33 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 33 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 81 pc: 025D sp: FD x: 33 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 81 pc: 026C sp: FD x: 33 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 00 pc: 026E sp: FD x: 33 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 00 pc: 0270 sp: FD x: 33 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1F p: 00 pc: 0259 sp: FD x: 33 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 33 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 81 pc: 025D sp: FD x: 33 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1F p: 81 pc: 026C sp: FD x: 33 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 1F p: 00 pc: 026E sp: FD x: 33 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1F p: 00 pc: 0270 sp: FD x: 33 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1F p: 00 pc: 0259 sp: FD x: 33 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 33 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 33 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 33 y: 05 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 33 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 33 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 33 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 33 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 33 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 33 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 33 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 33 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 33 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 33 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 33 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 33 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 33 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 33 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 33 y: 05 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 33 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 33 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 33 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 33 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 33 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 81 pc: 0229 sp: FF x: 33 y: 05 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0D p: 81 pc: 022B sp: FF x: 33 y: 05 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0D p: 01 pc: 022C sp: FF x: 33 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 33 y: 06 
---
[1]    18 0216: 	sta dividend
[2] a: EF p: 81 pc: 0216 sp: FF x: 33 y: 06 
---
[1]    19 0218: 	lda pstore, y
[2] a: EF p: 81 pc: 0218 sp: FF x: 33 y: 06 
---
[1]    20 021B: 	sta divisor
[2] a: 11 p: 01 pc: 021B sp: FF x: 33 y: 06 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 11 p: 01 pc: 021D sp: FF x: 33 y: 06 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 11 p: 01 pc: 0244 sp: FD x: 33 y: 06 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 33 y: 06 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 33 y: 06 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 33 y: 06 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 33 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 11 p: 01 pc: 024E sp: FD x: 33 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 11 p: 81 pc: 0250 sp: FD x: 33 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 11 p: 81 pc: 0252 sp: FD x: 33 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 11 p: 00 pc: 0254 sp: FD x: 33 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 22 p: 00 pc: 0255 sp: FD x: 33 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 22 p: 00 pc: 024E sp: FD x: 33 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 22 p: 81 pc: 0250 sp: FD x: 33 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 22 p: 81 pc: 0252 sp: FD x: 33 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 22 p: 00 pc: 0254 sp: FD x: 33 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 44 p: 00 pc: 0255 sp: FD x: 33 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 44 p: 00 pc: 024E sp: FD x: 33 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 44 p: 81 pc: 0250 sp: FD x: 33 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 44 p: 81 pc: 0252 sp: FD x: 33 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 44 p: 00 pc: 0254 sp: FD x: 33 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 88 p: 80 pc: 0255 sp: FD x: 33 y: 06 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 88 p: 80 pc: 0257 sp: FD x: 33 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 88 p: 80 pc: 0259 sp: FD x: 33 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: EF p: 80 pc: 025B sp: FD x: 33 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: EF p: 00 pc: 025D sp: FD x: 33 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: EF p: 00 pc: 025F sp: FD x: 33 y: 06 
---
[1]    55 0261: 	sec
[2] a: EF p: 80 pc: 0261 sp: FD x: 33 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: EF p: 81 pc: 0262 sp: FD x: 33 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 67 p: 40 pc: 0264 sp: FD x: 33 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 67 p: 40 pc: 0266 sp: FD x: 33 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 33 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 33 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 33 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 33 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 33 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 33 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 67 p: 40 pc: 025B sp: FD x: 33 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 67 p: 40 pc: 025D sp: FD x: 33 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 67 p: 40 pc: 025F sp: FD x: 33 y: 06 
---
[1]    55 0261: 	sec
[2] a: 67 p: 40 pc: 0261 sp: FD x: 33 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 67 p: 41 pc: 0262 sp: FD x: 33 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 23 p: 00 pc: 0264 sp: FD x: 33 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 23 p: 00 pc: 0266 sp: FD x: 33 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 33 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 33 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 33 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 33 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 33 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 33 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 23 p: 00 pc: 025B sp: FD x: 33 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 23 p: 00 pc: 025D sp: FD x: 33 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 23 p: 00 pc: 025F sp: FD x: 33 y: 06 
---
[1]    55 0261: 	sec
[2] a: 23 p: 00 pc: 0261 sp: FD x: 33 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 23 p: 01 pc: 0262 sp: FD x: 33 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 33 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 33 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 33 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 33 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 33 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 33 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 33 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 33 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 33 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 33 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 33 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 33 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 33 y: 06 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 33 y: 06 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 33 y: 06 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 33 y: 06 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 33 y: 06 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 11 p: 01 pc: 0227 sp: FF x: 33 y: 06 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 11 p: 00 pc: 0229 sp: FF x: 33 y: 06 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 11 p: 00 pc: 022E sp: FF x: 33 y: 06 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: EF p: 80 pc: 0231 sp: FF x: 33 y: 06 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: EF p: 00 pc: 0232 sp: FF x: 34 y: 06 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: EF p: 00 pc: 0235 sp: FF x: 34 y: 06 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: EF p: 80 pc: 0238 sp: FF x: 34 y: 06 
---
[1]    34 023B: 	lda pstore, x
[2] a: EF p: 80 pc: 023B sp: FF x: 34 y: 06 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: F1 p: 80 pc: 023E sp: FF x: 34 y: 06 
---
[1]    36 0240: 	bmi checkp
[2] a: F1 p: 81 pc: 0240 sp: FF x: 34 y: 06 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: F1 p: 81 pc: 0211 sp: FF x: 34 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: F1 p: 01 pc: 0213 sp: FF x: 34 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: F1 p: 81 pc: 0216 sp: FF x: 34 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: F1 p: 81 pc: 0218 sp: FF x: 34 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 34 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 34 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 34 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 34 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 34 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 34 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 34 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 34 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 34 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 34 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 34 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 34 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 34 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 34 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 34 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 34 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 34 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 34 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 34 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 34 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 34 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 34 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 34 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 34 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 34 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 34 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 34 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 34 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 34 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 34 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 34 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 34 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 34 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 34 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 34 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 34 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 34 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 34 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 34 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F1 p: 80 pc: 025B sp: FD x: 34 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F1 p: 00 pc: 025D sp: FD x: 34 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: F1 p: 00 pc: 025F sp: FD x: 34 y: 01 
---
[1]    55 0261: 	sec
[2] a: F1 p: 80 pc: 0261 sp: FD x: 34 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F1 p: 81 pc: 0262 sp: FD x: 34 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 31 p: 00 pc: 0264 sp: FD x: 34 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 31 p: 00 pc: 0266 sp: FD x: 34 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 34 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 34 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 34 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 34 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 34 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 34 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 34 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 81 pc: 025D sp: FD x: 34 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 31 p: 81 pc: 026C sp: FD x: 34 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 31 p: 00 pc: 026E sp: FD x: 34 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 31 p: 00 pc: 0270 sp: FD x: 34 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 31 p: 00 pc: 0259 sp: FD x: 34 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 31 p: 00 pc: 025B sp: FD x: 34 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 31 p: 00 pc: 025D sp: FD x: 34 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 31 p: 00 pc: 025F sp: FD x: 34 y: 01 
---
[1]    55 0261: 	sec
[2] a: 31 p: 00 pc: 0261 sp: FD x: 34 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 31 p: 01 pc: 0262 sp: FD x: 34 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 34 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 34 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 34 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 50 p: 00 pc: 026A sp: FD x: 34 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 50 p: 00 pc: 026C sp: FD x: 34 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 50 p: 00 pc: 026E sp: FD x: 34 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 50 p: 00 pc: 0270 sp: FD x: 34 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 34 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 34 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 34 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 34 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 34 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 34 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 34 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 34 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 34 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 34 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 34 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 34 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 34 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 34 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 34 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 34 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 34 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 34 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 34 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 34 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 34 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 34 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 34 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 34 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 34 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 34 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 34 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 34 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 34 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 34 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 34 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 34 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 34 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: F1 p: 81 pc: 0216 sp: FF x: 34 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: F1 p: 81 pc: 0218 sp: FF x: 34 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 34 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 34 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 34 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 34 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 34 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 34 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 34 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 34 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 34 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 34 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 34 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 34 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 34 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 34 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 34 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 34 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 34 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 34 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 34 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 34 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 34 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 34 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 34 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 34 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 34 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 34 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 34 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 34 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 34 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 34 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 34 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 34 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 34 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 34 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F1 p: 80 pc: 025B sp: FD x: 34 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F1 p: 00 pc: 025D sp: FD x: 34 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: F1 p: 00 pc: 025F sp: FD x: 34 y: 02 
---
[1]    55 0261: 	sec
[2] a: F1 p: 80 pc: 0261 sp: FD x: 34 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F1 p: 81 pc: 0262 sp: FD x: 34 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 51 p: 40 pc: 0264 sp: FD x: 34 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 51 p: 40 pc: 0266 sp: FD x: 34 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 34 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 34 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 34 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 34 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 34 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 34 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 51 p: 40 pc: 025B sp: FD x: 34 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 51 p: 40 pc: 025D sp: FD x: 34 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 51 p: 40 pc: 025F sp: FD x: 34 y: 02 
---
[1]    55 0261: 	sec
[2] a: 51 p: 40 pc: 0261 sp: FD x: 34 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 51 p: 41 pc: 0262 sp: FD x: 34 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 34 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 34 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 34 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 34 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 34 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 34 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 34 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 34 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 34 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 34 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 34 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 34 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 34 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 34 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 34 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 34 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 34 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 34 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 34 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 34 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 34 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 34 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 34 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 34 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 34 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 34 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 34 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 34 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 34 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 34 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 34 y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 34 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 34 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 34 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 34 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 34 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 34 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 34 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 34 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 34 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: F1 p: 81 pc: 0216 sp: FF x: 34 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: F1 p: 81 pc: 0218 sp: FF x: 34 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 34 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 34 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 34 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 34 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 34 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 34 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 34 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 34 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 34 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 34 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 34 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 34 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 34 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 34 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 34 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 34 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 34 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 34 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 34 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 34 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 34 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 34 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 34 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 34 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 34 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 34 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 34 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 34 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 34 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 34 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 34 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 34 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 34 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 34 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F1 p: 80 pc: 025B sp: FD x: 34 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F1 p: 00 pc: 025D sp: FD x: 34 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: F1 p: 00 pc: 025F sp: FD x: 34 y: 03 
---
[1]    55 0261: 	sec
[2] a: F1 p: 80 pc: 0261 sp: FD x: 34 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F1 p: 81 pc: 0262 sp: FD x: 34 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 34 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 34 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 34 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 34 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 34 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 34 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 34 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 34 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 34 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 34 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 34 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 34 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 34 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 34 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 34 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 34 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 34 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 34 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 34 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 34 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 34 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 81 pc: 025D sp: FD x: 34 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 11 p: 81 pc: 026C sp: FD x: 34 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 11 p: 00 pc: 026E sp: FD x: 34 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 11 p: 00 pc: 0270 sp: FD x: 34 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 11 p: 00 pc: 0259 sp: FD x: 34 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 34 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 34 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 34 y: 03 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 34 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 34 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 34 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 34 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 34 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 22 p: 00 pc: 026A sp: FD x: 34 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 22 p: 00 pc: 026C sp: FD x: 34 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 22 p: 00 pc: 026E sp: FD x: 34 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 22 p: 00 pc: 0270 sp: FD x: 34 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 22 p: 00 pc: 0259 sp: FD x: 34 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 34 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 34 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 34 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 34 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 34 y: 03 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 34 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 34 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 34 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 34 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 34 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 34 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 34 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 34 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 34 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: F1 p: 81 pc: 0216 sp: FF x: 34 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: F1 p: 81 pc: 0218 sp: FF x: 34 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 34 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 34 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 34 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 34 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 34 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 34 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 34 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 34 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 34 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 34 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 34 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 34 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 34 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 34 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 34 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 34 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 34 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 34 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 34 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 34 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 34 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 34 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 34 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 34 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 34 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 34 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 34 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 34 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 34 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F1 p: 80 pc: 025B sp: FD x: 34 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F1 p: 00 pc: 025D sp: FD x: 34 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: F1 p: 00 pc: 025F sp: FD x: 34 y: 04 
---
[1]    55 0261: 	sec
[2] a: F1 p: 80 pc: 0261 sp: FD x: 34 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F1 p: 81 pc: 0262 sp: FD x: 34 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 41 p: 40 pc: 0264 sp: FD x: 34 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 41 p: 40 pc: 0266 sp: FD x: 34 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 34 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 34 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 34 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 34 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 34 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 34 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 41 p: 40 pc: 025B sp: FD x: 34 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 41 p: C1 pc: 025D sp: FD x: 34 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 41 p: C1 pc: 026C sp: FD x: 34 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 41 p: 40 pc: 026E sp: FD x: 34 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 41 p: 40 pc: 0270 sp: FD x: 34 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 41 p: 40 pc: 0259 sp: FD x: 34 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 41 p: 40 pc: 025B sp: FD x: 34 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 41 p: 40 pc: 025D sp: FD x: 34 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 41 p: 40 pc: 025F sp: FD x: 34 y: 04 
---
[1]    55 0261: 	sec
[2] a: 41 p: 40 pc: 0261 sp: FD x: 34 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 41 p: 41 pc: 0262 sp: FD x: 34 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 15 p: 00 pc: 0264 sp: FD x: 34 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 15 p: 00 pc: 0266 sp: FD x: 34 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 34 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 34 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 34 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 34 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 34 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 34 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 34 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 81 pc: 025D sp: FD x: 34 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 81 pc: 026C sp: FD x: 34 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 00 pc: 026E sp: FD x: 34 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 00 pc: 0270 sp: FD x: 34 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 15 p: 00 pc: 0259 sp: FD x: 34 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 15 p: 00 pc: 025B sp: FD x: 34 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 15 p: 00 pc: 025D sp: FD x: 34 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 15 p: 00 pc: 025F sp: FD x: 34 y: 04 
---
[1]    55 0261: 	sec
[2] a: 15 p: 00 pc: 0261 sp: FD x: 34 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 15 p: 01 pc: 0262 sp: FD x: 34 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0A p: 00 pc: 0264 sp: FD x: 34 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0A p: 00 pc: 0266 sp: FD x: 34 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 34 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 15 p: 00 pc: 026A sp: FD x: 34 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 15 p: 00 pc: 026C sp: FD x: 34 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 15 p: 01 pc: 026E sp: FD x: 34 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 15 p: 03 pc: 0270 sp: FD x: 34 y: 04 
---
[1]    64 0272: 	rts
[2] a: 15 p: 03 pc: 0272 sp: FD x: 34 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 15 p: 03 pc: 0220 sp: FF x: 34 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0A p: 01 pc: 0222 sp: FF x: 34 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0A p: 01 pc: 0224 sp: FF x: 34 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 34 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 34 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 34 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 34 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 34 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: F1 p: 81 pc: 0216 sp: FF x: 34 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: F1 p: 81 pc: 0218 sp: FF x: 34 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 34 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 34 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 34 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 34 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 34 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 34 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 34 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 34 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 34 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 34 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 34 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 34 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 34 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 34 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 34 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 34 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 34 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 34 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 34 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 34 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 34 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 34 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 34 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 34 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 34 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 34 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 34 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 34 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 34 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F1 p: 80 pc: 025B sp: FD x: 34 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F1 p: 00 pc: 025D sp: FD x: 34 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: F1 p: 00 pc: 025F sp: FD x: 34 y: 05 
---
[1]    55 0261: 	sec
[2] a: F1 p: 80 pc: 0261 sp: FD x: 34 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F1 p: 81 pc: 0262 sp: FD x: 34 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 34 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 34 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 34 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 34 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 34 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 34 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 34 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 34 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 34 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 34 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 34 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 34 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 34 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 34 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 34 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 81 pc: 025D sp: FD x: 34 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 21 p: 81 pc: 026C sp: FD x: 34 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 21 p: 00 pc: 026E sp: FD x: 34 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 21 p: 00 pc: 0270 sp: FD x: 34 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 21 p: 00 pc: 0259 sp: FD x: 34 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 34 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 34 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 34 y: 05 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 34 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 34 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 34 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 34 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 34 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 34 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 34 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 34 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 34 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 34 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 34 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 34 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 34 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 01 pc: 026E sp: FD x: 34 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 03 pc: 0270 sp: FD x: 34 y: 05 
---
[1]    64 0272: 	rts
[2] a: 07 p: 03 pc: 0272 sp: FD x: 34 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 07 p: 03 pc: 0220 sp: FF x: 34 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 07 p: 01 pc: 0222 sp: FF x: 34 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 07 p: 01 pc: 0224 sp: FF x: 34 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 34 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 81 pc: 0229 sp: FF x: 34 y: 05 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0D p: 81 pc: 022B sp: FF x: 34 y: 05 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0D p: 01 pc: 022C sp: FF x: 34 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 34 y: 06 
---
[1]    18 0216: 	sta dividend
[2] a: F1 p: 81 pc: 0216 sp: FF x: 34 y: 06 
---
[1]    19 0218: 	lda pstore, y
[2] a: F1 p: 81 pc: 0218 sp: FF x: 34 y: 06 
---
[1]    20 021B: 	sta divisor
[2] a: 11 p: 01 pc: 021B sp: FF x: 34 y: 06 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 11 p: 01 pc: 021D sp: FF x: 34 y: 06 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 11 p: 01 pc: 0244 sp: FD x: 34 y: 06 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 34 y: 06 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 34 y: 06 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 34 y: 06 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 34 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 11 p: 01 pc: 024E sp: FD x: 34 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 11 p: 81 pc: 0250 sp: FD x: 34 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 11 p: 81 pc: 0252 sp: FD x: 34 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 11 p: 00 pc: 0254 sp: FD x: 34 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 22 p: 00 pc: 0255 sp: FD x: 34 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 22 p: 00 pc: 024E sp: FD x: 34 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 22 p: 81 pc: 0250 sp: FD x: 34 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 22 p: 81 pc: 0252 sp: FD x: 34 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 22 p: 00 pc: 0254 sp: FD x: 34 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 44 p: 00 pc: 0255 sp: FD x: 34 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 44 p: 00 pc: 024E sp: FD x: 34 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 44 p: 81 pc: 0250 sp: FD x: 34 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 44 p: 81 pc: 0252 sp: FD x: 34 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 44 p: 00 pc: 0254 sp: FD x: 34 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 88 p: 80 pc: 0255 sp: FD x: 34 y: 06 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 88 p: 80 pc: 0257 sp: FD x: 34 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 88 p: 80 pc: 0259 sp: FD x: 34 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F1 p: 80 pc: 025B sp: FD x: 34 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F1 p: 00 pc: 025D sp: FD x: 34 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: F1 p: 00 pc: 025F sp: FD x: 34 y: 06 
---
[1]    55 0261: 	sec
[2] a: F1 p: 80 pc: 0261 sp: FD x: 34 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F1 p: 81 pc: 0262 sp: FD x: 34 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 69 p: 40 pc: 0264 sp: FD x: 34 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 69 p: 40 pc: 0266 sp: FD x: 34 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 34 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 34 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 34 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 34 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 34 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 34 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 69 p: 40 pc: 025B sp: FD x: 34 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 69 p: 40 pc: 025D sp: FD x: 34 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 69 p: 40 pc: 025F sp: FD x: 34 y: 06 
---
[1]    55 0261: 	sec
[2] a: 69 p: 40 pc: 0261 sp: FD x: 34 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 69 p: 41 pc: 0262 sp: FD x: 34 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 25 p: 00 pc: 0264 sp: FD x: 34 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 25 p: 00 pc: 0266 sp: FD x: 34 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 34 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 34 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 34 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 34 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 34 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 34 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 25 p: 00 pc: 025B sp: FD x: 34 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 25 p: 00 pc: 025D sp: FD x: 34 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 25 p: 00 pc: 025F sp: FD x: 34 y: 06 
---
[1]    55 0261: 	sec
[2] a: 25 p: 00 pc: 0261 sp: FD x: 34 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 25 p: 01 pc: 0262 sp: FD x: 34 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 34 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 34 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 34 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 34 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 34 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 34 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 34 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 34 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 34 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 34 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 34 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 34 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 34 y: 06 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 34 y: 06 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 34 y: 06 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 34 y: 06 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 34 y: 06 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 11 p: 01 pc: 0227 sp: FF x: 34 y: 06 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 11 p: 00 pc: 0229 sp: FF x: 34 y: 06 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 11 p: 00 pc: 022E sp: FF x: 34 y: 06 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: F1 p: 80 pc: 0231 sp: FF x: 34 y: 06 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: F1 p: 00 pc: 0232 sp: FF x: 35 y: 06 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: F1 p: 00 pc: 0235 sp: FF x: 35 y: 06 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: F1 p: 80 pc: 0238 sp: FF x: 35 y: 06 
---
[1]    34 023B: 	lda pstore, x
[2] a: F1 p: 80 pc: 023B sp: FF x: 35 y: 06 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: F3 p: 80 pc: 023E sp: FF x: 35 y: 06 
---
[1]    36 0240: 	bmi checkp
[2] a: F3 p: 81 pc: 0240 sp: FF x: 35 y: 06 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: F3 p: 81 pc: 0211 sp: FF x: 35 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: F3 p: 01 pc: 0213 sp: FF x: 35 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: F3 p: 81 pc: 0216 sp: FF x: 35 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: F3 p: 81 pc: 0218 sp: FF x: 35 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 35 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 35 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 35 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F3 p: 80 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F3 p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: F3 p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: F3 p: 80 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F3 p: 81 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 33 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 33 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 33 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 33 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 33 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 33 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 33 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 33 p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 33 p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: 33 p: 00 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 33 p: 01 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 50 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 50 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 50 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 50 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 03 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 50 p: 00 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 51 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 51 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 51 p: 01 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 51 p: 03 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    64 0272: 	rts
[2] a: 51 p: 03 pc: 0272 sp: FD x: 35 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 51 p: 03 pc: 0220 sp: FF x: 35 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 35 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 35 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 35 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 35 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: F5 p: 81 pc: 023E sp: FF x: 35 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: F5 p: 81 pc: 0240 sp: FF x: 35 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: F5 p: 81 pc: 0211 sp: FF x: 35 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: F5 p: 01 pc: 0213 sp: FF x: 35 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: F5 p: 81 pc: 0216 sp: FF x: 35 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: F5 p: 81 pc: 0218 sp: FF x: 35 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 35 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 35 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 35 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F5 p: 80 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F5 p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: F5 p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: F5 p: 80 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F5 p: 81 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 35 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 35 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 35 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 35 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 35 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 35 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 35 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 35 p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 35 p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: 35 p: 00 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 35 p: 01 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 50 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 50 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 50 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 50 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 50 p: 00 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 51 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 51 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 51 p: 01 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 51 p: 03 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    64 0272: 	rts
[2] a: 51 p: 03 pc: 0272 sp: FD x: 35 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 51 p: 03 pc: 0220 sp: FF x: 35 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 35 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 35 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 35 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 35 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 35 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 35 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 35 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: F5 p: 81 pc: 0216 sp: FF x: 35 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: F5 p: 81 pc: 0218 sp: FF x: 35 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 35 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 35 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 35 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F5 p: 80 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F5 p: 00 pc: 025D sp: FD x: 35 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: F5 p: 00 pc: 025F sp: FD x: 35 y: 02 
---
[1]    55 0261: 	sec
[2] a: F5 p: 80 pc: 0261 sp: FD x: 35 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F5 p: 81 pc: 0262 sp: FD x: 35 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 55 p: 40 pc: 0264 sp: FD x: 35 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 55 p: 40 pc: 0266 sp: FD x: 35 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 35 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 55 p: 40 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 55 p: 40 pc: 025D sp: FD x: 35 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 55 p: 40 pc: 025F sp: FD x: 35 y: 02 
---
[1]    55 0261: 	sec
[2] a: 55 p: 40 pc: 0261 sp: FD x: 35 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 55 p: 41 pc: 0262 sp: FD x: 35 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 35 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 35 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 35 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 00 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 00 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 05 p: 00 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 02 pc: 025D sp: FD x: 35 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 02 pc: 025F sp: FD x: 35 y: 02 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 35 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 35 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 35 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 35 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 35 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 31 p: 00 pc: 026A sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 31 p: 00 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 31 p: 01 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 31 p: 03 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    64 0272: 	rts
[2] a: 31 p: 03 pc: 0272 sp: FD x: 35 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 31 p: 03 pc: 0220 sp: FF x: 35 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 35 y: 02 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 35 y: 02 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 35 y: 02 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 35 y: 02 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: F7 p: 81 pc: 023E sp: FF x: 35 y: 02 
---
[1]    36 0240: 	bmi checkp
[2] a: F7 p: 81 pc: 0240 sp: FF x: 35 y: 02 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: F7 p: 81 pc: 0211 sp: FF x: 35 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: F7 p: 01 pc: 0213 sp: FF x: 35 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: F7 p: 81 pc: 0216 sp: FF x: 35 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: F7 p: 81 pc: 0218 sp: FF x: 35 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 35 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 35 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 35 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F7 p: 80 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F7 p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: F7 p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: F7 p: 80 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F7 p: 81 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 37 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 37 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 37 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 37 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 37 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 37 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 37 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 37 p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 37 p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: 37 p: 00 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 37 p: 01 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 50 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 50 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 50 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 50 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 50 p: 00 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 52 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 52 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 52 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 52 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 52 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 35 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 35 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 35 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 35 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 35 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 35 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 35 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 35 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 35 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: F7 p: 81 pc: 0216 sp: FF x: 35 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: F7 p: 81 pc: 0218 sp: FF x: 35 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 35 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 35 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 35 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F7 p: 80 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F7 p: 00 pc: 025D sp: FD x: 35 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: F7 p: 00 pc: 025F sp: FD x: 35 y: 02 
---
[1]    55 0261: 	sec
[2] a: F7 p: 80 pc: 0261 sp: FD x: 35 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F7 p: 81 pc: 0262 sp: FD x: 35 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 57 p: 40 pc: 0264 sp: FD x: 35 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 57 p: 40 pc: 0266 sp: FD x: 35 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 35 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 57 p: 40 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 57 p: 40 pc: 025D sp: FD x: 35 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 57 p: 40 pc: 025F sp: FD x: 35 y: 02 
---
[1]    55 0261: 	sec
[2] a: 57 p: 40 pc: 0261 sp: FD x: 35 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 57 p: 41 pc: 0262 sp: FD x: 35 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 07 p: 00 pc: 0264 sp: FD x: 35 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 07 p: 00 pc: 0266 sp: FD x: 35 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 35 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 81 pc: 025D sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 07 p: 81 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 07 p: 00 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 07 p: 00 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 07 p: 00 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 07 p: 00 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 07 p: 00 pc: 025D sp: FD x: 35 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 07 p: 00 pc: 025F sp: FD x: 35 y: 02 
---
[1]    55 0261: 	sec
[2] a: 07 p: 00 pc: 0261 sp: FD x: 35 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 07 p: 01 pc: 0262 sp: FD x: 35 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 35 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 35 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 35 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 31 p: 00 pc: 026A sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 31 p: 00 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 31 p: 01 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 31 p: 03 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    64 0272: 	rts
[2] a: 31 p: 03 pc: 0272 sp: FD x: 35 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 31 p: 03 pc: 0220 sp: FF x: 35 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 35 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 35 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 35 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 35 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 35 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 35 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 35 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: F7 p: 81 pc: 0216 sp: FF x: 35 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: F7 p: 81 pc: 0218 sp: FF x: 35 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 35 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 35 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 35 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 35 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 35 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 35 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 35 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 35 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 35 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 35 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 35 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 35 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 35 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 35 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 35 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 35 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 35 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 35 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 35 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 35 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 35 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 35 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 35 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 35 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 35 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 35 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 35 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 35 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 35 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 35 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F7 p: 80 pc: 025B sp: FD x: 35 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F7 p: 00 pc: 025D sp: FD x: 35 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: F7 p: 00 pc: 025F sp: FD x: 35 y: 03 
---
[1]    55 0261: 	sec
[2] a: F7 p: 80 pc: 0261 sp: FD x: 35 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F7 p: 81 pc: 0262 sp: FD x: 35 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 17 p: 00 pc: 0264 sp: FD x: 35 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 17 p: 00 pc: 0266 sp: FD x: 35 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 35 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 35 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 35 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 35 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 35 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 35 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 35 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 35 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 35 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 35 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 35 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 35 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 35 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 35 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 35 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 35 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 35 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 35 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 35 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 81 pc: 025D sp: FD x: 35 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 81 pc: 026C sp: FD x: 35 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 00 pc: 026E sp: FD x: 35 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 00 pc: 0270 sp: FD x: 35 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 17 p: 00 pc: 0259 sp: FD x: 35 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 17 p: 00 pc: 025B sp: FD x: 35 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 17 p: 00 pc: 025D sp: FD x: 35 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 17 p: 00 pc: 025F sp: FD x: 35 y: 03 
---
[1]    55 0261: 	sec
[2] a: 17 p: 00 pc: 0261 sp: FD x: 35 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 17 p: 01 pc: 0262 sp: FD x: 35 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 35 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 35 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 35 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 22 p: 00 pc: 026A sp: FD x: 35 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 22 p: 00 pc: 026C sp: FD x: 35 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 22 p: 00 pc: 026E sp: FD x: 35 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 22 p: 00 pc: 0270 sp: FD x: 35 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 22 p: 00 pc: 0259 sp: FD x: 35 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 35 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 35 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 35 y: 03 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 35 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 35 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 35 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 35 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 22 p: 00 pc: 0268 sp: FD x: 35 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 23 p: 00 pc: 026A sp: FD x: 35 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 00 pc: 026C sp: FD x: 35 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 01 pc: 026E sp: FD x: 35 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 03 pc: 0270 sp: FD x: 35 y: 03 
---
[1]    64 0272: 	rts
[2] a: 23 p: 03 pc: 0272 sp: FD x: 35 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 23 p: 03 pc: 0220 sp: FF x: 35 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 35 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 35 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 35 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 35 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 35 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 35 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 35 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: F7 p: 81 pc: 0216 sp: FF x: 35 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: F7 p: 81 pc: 0218 sp: FF x: 35 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 35 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 35 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 35 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 35 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 35 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 35 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 35 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 35 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 35 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 35 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 35 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 35 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 35 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 35 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 35 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 35 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 35 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 35 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 35 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 35 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 35 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 35 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 35 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 35 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 35 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F7 p: 80 pc: 025B sp: FD x: 35 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F7 p: 00 pc: 025D sp: FD x: 35 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: F7 p: 00 pc: 025F sp: FD x: 35 y: 04 
---
[1]    55 0261: 	sec
[2] a: F7 p: 80 pc: 0261 sp: FD x: 35 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F7 p: 81 pc: 0262 sp: FD x: 35 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 47 p: 40 pc: 0264 sp: FD x: 35 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 47 p: 40 pc: 0266 sp: FD x: 35 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 35 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 35 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 35 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 35 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 35 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 35 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 47 p: 40 pc: 025B sp: FD x: 35 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 47 p: C1 pc: 025D sp: FD x: 35 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 47 p: C1 pc: 026C sp: FD x: 35 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 47 p: 40 pc: 026E sp: FD x: 35 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 47 p: 40 pc: 0270 sp: FD x: 35 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 47 p: 40 pc: 0259 sp: FD x: 35 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 47 p: 40 pc: 025B sp: FD x: 35 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 47 p: 40 pc: 025D sp: FD x: 35 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 47 p: 40 pc: 025F sp: FD x: 35 y: 04 
---
[1]    55 0261: 	sec
[2] a: 47 p: 40 pc: 0261 sp: FD x: 35 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 47 p: 41 pc: 0262 sp: FD x: 35 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 35 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 35 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 35 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 35 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 35 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 35 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 35 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 35 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 35 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 35 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 35 y: 04 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 35 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 35 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 35 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 35 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 35 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 35 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 35 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 35 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 35 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 35 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 35 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 81 pc: 025D sp: FD x: 35 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 05 p: 81 pc: 026C sp: FD x: 35 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 05 p: 01 pc: 026E sp: FD x: 35 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 05 p: 03 pc: 0270 sp: FD x: 35 y: 04 
---
[1]    64 0272: 	rts
[2] a: 05 p: 03 pc: 0272 sp: FD x: 35 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 05 p: 03 pc: 0220 sp: FF x: 35 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 05 p: 01 pc: 0222 sp: FF x: 35 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 05 p: 01 pc: 0224 sp: FF x: 35 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 35 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 35 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 35 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 35 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 35 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: F7 p: 81 pc: 0216 sp: FF x: 35 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: F7 p: 81 pc: 0218 sp: FF x: 35 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 35 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 35 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 35 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 35 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 35 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 35 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 35 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 35 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 35 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 35 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 35 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 35 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 35 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 35 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 35 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 35 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 35 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 35 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 35 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 35 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 35 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 35 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 35 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 35 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 35 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F7 p: 80 pc: 025B sp: FD x: 35 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F7 p: 00 pc: 025D sp: FD x: 35 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: F7 p: 00 pc: 025F sp: FD x: 35 y: 05 
---
[1]    55 0261: 	sec
[2] a: F7 p: 80 pc: 0261 sp: FD x: 35 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F7 p: 81 pc: 0262 sp: FD x: 35 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 27 p: 00 pc: 0264 sp: FD x: 35 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 27 p: 00 pc: 0266 sp: FD x: 35 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 35 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 35 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 35 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 35 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 35 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 35 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 35 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 81 pc: 025D sp: FD x: 35 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 81 pc: 026C sp: FD x: 35 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 00 pc: 026E sp: FD x: 35 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 00 pc: 0270 sp: FD x: 35 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 27 p: 00 pc: 0259 sp: FD x: 35 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 35 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 81 pc: 025D sp: FD x: 35 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 27 p: 81 pc: 026C sp: FD x: 35 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 27 p: 00 pc: 026E sp: FD x: 35 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 27 p: 00 pc: 0270 sp: FD x: 35 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 27 p: 00 pc: 0259 sp: FD x: 35 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 27 p: 00 pc: 025B sp: FD x: 35 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 27 p: 00 pc: 025D sp: FD x: 35 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 27 p: 00 pc: 025F sp: FD x: 35 y: 05 
---
[1]    55 0261: 	sec
[2] a: 27 p: 00 pc: 0261 sp: FD x: 35 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 27 p: 01 pc: 0262 sp: FD x: 35 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 35 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 35 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 35 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 35 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 35 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 35 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 35 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 35 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 35 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 02 pc: 025D sp: FD x: 35 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 02 pc: 025F sp: FD x: 35 y: 05 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 35 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 35 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 35 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 35 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 12 p: 00 pc: 0268 sp: FD x: 35 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 13 p: 00 pc: 026A sp: FD x: 35 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 00 pc: 026C sp: FD x: 35 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 01 pc: 026E sp: FD x: 35 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 03 pc: 0270 sp: FD x: 35 y: 05 
---
[1]    64 0272: 	rts
[2] a: 13 p: 03 pc: 0272 sp: FD x: 35 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 13 p: 03 pc: 0220 sp: FF x: 35 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 35 y: 05 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 35 y: 05 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 35 y: 05 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 35 y: 05 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: F9 p: 81 pc: 023E sp: FF x: 35 y: 05 
---
[1]    36 0240: 	bmi checkp
[2] a: F9 p: 81 pc: 0240 sp: FF x: 35 y: 05 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: F9 p: 81 pc: 0211 sp: FF x: 35 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: F9 p: 01 pc: 0213 sp: FF x: 35 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: F9 p: 81 pc: 0216 sp: FF x: 35 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: F9 p: 81 pc: 0218 sp: FF x: 35 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 35 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 35 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 35 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: F9 p: 80 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: F9 p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: F9 p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: F9 p: 80 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: F9 p: 81 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 39 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 39 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 39 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 39 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 39 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 39 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 39 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 39 p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 39 p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: 39 p: 00 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 39 p: 01 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 50 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 50 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 50 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 50 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 09 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 09 p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: 09 p: 00 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 09 p: 01 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 50 p: 00 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 52 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 52 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 52 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 52 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 52 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 02 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 03 p: 02 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: 03 p: 00 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 03 p: 01 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 52 p: 00 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 53 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 53 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 53 p: 01 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 53 p: 03 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    64 0272: 	rts
[2] a: 53 p: 03 pc: 0272 sp: FD x: 35 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 53 p: 03 pc: 0220 sp: FF x: 35 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 35 y: 01 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 35 y: 01 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 35 y: 01 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 35 y: 01 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: FB p: 81 pc: 023E sp: FF x: 35 y: 01 
---
[1]    36 0240: 	bmi checkp
[2] a: FB p: 81 pc: 0240 sp: FF x: 35 y: 01 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: FB p: 81 pc: 0211 sp: FF x: 35 y: 01 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: FB p: 01 pc: 0213 sp: FF x: 35 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: FB p: 81 pc: 0216 sp: FF x: 35 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: FB p: 81 pc: 0218 sp: FF x: 35 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 35 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 35 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 35 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 35 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 35 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 35 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 35 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 35 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: FB p: 80 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: FB p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: FB p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: FB p: 80 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: FB p: 81 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 3B p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 3B p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3B p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3B p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3B p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3B p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3B p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3B p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 3B p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: 3B p: 00 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3B p: 01 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 50 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 50 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 50 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 50 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 05 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 05 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 50 p: 00 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 52 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 52 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 52 p: 00 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 52 p: 00 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 52 p: 00 pc: 0259 sp: FD x: 35 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 05 p: 00 pc: 025B sp: FD x: 35 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 05 p: 00 pc: 025D sp: FD x: 35 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 05 p: 00 pc: 025F sp: FD x: 35 y: 01 
---
[1]    55 0261: 	sec
[2] a: 05 p: 00 pc: 0261 sp: FD x: 35 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 05 p: 01 pc: 0262 sp: FD x: 35 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 02 p: 00 pc: 0264 sp: FD x: 35 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 02 p: 00 pc: 0266 sp: FD x: 35 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 52 p: 00 pc: 0268 sp: FD x: 35 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 53 p: 00 pc: 026A sp: FD x: 35 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 53 p: 00 pc: 026C sp: FD x: 35 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 53 p: 01 pc: 026E sp: FD x: 35 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 53 p: 03 pc: 0270 sp: FD x: 35 y: 01 
---
[1]    64 0272: 	rts
[2] a: 53 p: 03 pc: 0272 sp: FD x: 35 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 53 p: 03 pc: 0220 sp: FF x: 35 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 02 p: 01 pc: 0222 sp: FF x: 35 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 02 p: 01 pc: 0224 sp: FF x: 35 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 35 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 35 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 35 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 35 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 35 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: FB p: 81 pc: 0216 sp: FF x: 35 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: FB p: 81 pc: 0218 sp: FF x: 35 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 35 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 35 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 35 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 35 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 35 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 35 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 35 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 35 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: FB p: 80 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: FB p: 00 pc: 025D sp: FD x: 35 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: FB p: 00 pc: 025F sp: FD x: 35 y: 02 
---
[1]    55 0261: 	sec
[2] a: FB p: 80 pc: 0261 sp: FD x: 35 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: FB p: 81 pc: 0262 sp: FD x: 35 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 5B p: 40 pc: 0264 sp: FD x: 35 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 5B p: 40 pc: 0266 sp: FD x: 35 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 35 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5B p: 40 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5B p: 40 pc: 025D sp: FD x: 35 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 5B p: 40 pc: 025F sp: FD x: 35 y: 02 
---
[1]    55 0261: 	sec
[2] a: 5B p: 40 pc: 0261 sp: FD x: 35 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5B p: 41 pc: 0262 sp: FD x: 35 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 35 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 35 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 35 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 81 pc: 025D sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0B p: 81 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0B p: 00 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0B p: 00 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0B p: 00 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 00 pc: 025D sp: FD x: 35 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 00 pc: 025F sp: FD x: 35 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 35 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 35 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 35 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 35 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 35 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 32 p: 00 pc: 026A sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 32 p: 00 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 32 p: 00 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 32 p: 00 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 32 p: 00 pc: 0259 sp: FD x: 35 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 35 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 35 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 35 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 35 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 35 y: 02 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 35 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 35 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 35 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 35 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 35 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 35 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 35 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 35 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 35 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: FB p: 81 pc: 0216 sp: FF x: 35 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: FB p: 81 pc: 0218 sp: FF x: 35 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 35 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 35 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 35 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 35 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 35 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 35 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 35 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 35 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 35 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 35 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 35 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 35 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 35 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 35 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 35 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 35 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 35 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 35 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 35 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 35 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 35 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 35 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 35 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 35 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 35 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 35 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 35 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 35 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 35 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 35 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: FB p: 80 pc: 025B sp: FD x: 35 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: FB p: 00 pc: 025D sp: FD x: 35 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: FB p: 00 pc: 025F sp: FD x: 35 y: 03 
---
[1]    55 0261: 	sec
[2] a: FB p: 80 pc: 0261 sp: FD x: 35 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: FB p: 81 pc: 0262 sp: FD x: 35 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 1B p: 00 pc: 0264 sp: FD x: 35 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 1B p: 00 pc: 0266 sp: FD x: 35 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 35 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 35 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 35 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 35 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 35 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 35 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 35 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 35 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 35 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 35 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 35 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 35 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 35 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 35 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 35 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 35 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 35 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 35 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 35 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 81 pc: 025D sp: FD x: 35 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1B p: 81 pc: 026C sp: FD x: 35 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1B p: 00 pc: 026E sp: FD x: 35 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1B p: 00 pc: 0270 sp: FD x: 35 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1B p: 00 pc: 0259 sp: FD x: 35 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1B p: 00 pc: 025B sp: FD x: 35 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1B p: 00 pc: 025D sp: FD x: 35 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 1B p: 00 pc: 025F sp: FD x: 35 y: 03 
---
[1]    55 0261: 	sec
[2] a: 1B p: 00 pc: 0261 sp: FD x: 35 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1B p: 01 pc: 0262 sp: FD x: 35 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 35 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 35 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 35 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 22 p: 00 pc: 026A sp: FD x: 35 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 22 p: 00 pc: 026C sp: FD x: 35 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 22 p: 00 pc: 026E sp: FD x: 35 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 22 p: 00 pc: 0270 sp: FD x: 35 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 22 p: 00 pc: 0259 sp: FD x: 35 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 35 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 35 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 35 y: 03 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 35 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 35 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 06 p: 00 pc: 0264 sp: FD x: 35 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 06 p: 00 pc: 0266 sp: FD x: 35 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 22 p: 00 pc: 0268 sp: FD x: 35 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 23 p: 00 pc: 026A sp: FD x: 35 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 23 p: 00 pc: 026C sp: FD x: 35 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 23 p: 01 pc: 026E sp: FD x: 35 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 23 p: 03 pc: 0270 sp: FD x: 35 y: 03 
---
[1]    64 0272: 	rts
[2] a: 23 p: 03 pc: 0272 sp: FD x: 35 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 23 p: 03 pc: 0220 sp: FF x: 35 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 06 p: 01 pc: 0222 sp: FF x: 35 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 06 p: 01 pc: 0224 sp: FF x: 35 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 35 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 35 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 35 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 35 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 35 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: FB p: 81 pc: 0216 sp: FF x: 35 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: FB p: 81 pc: 0218 sp: FF x: 35 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 35 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 35 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 35 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 35 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 35 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 35 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 35 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 35 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 35 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 35 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 35 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 35 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 35 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 35 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 35 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 35 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 35 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 35 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 35 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 35 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 35 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 35 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 35 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 35 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 35 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: FB p: 80 pc: 025B sp: FD x: 35 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: FB p: 00 pc: 025D sp: FD x: 35 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: FB p: 00 pc: 025F sp: FD x: 35 y: 04 
---
[1]    55 0261: 	sec
[2] a: FB p: 80 pc: 0261 sp: FD x: 35 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: FB p: 81 pc: 0262 sp: FD x: 35 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 4B p: 40 pc: 0264 sp: FD x: 35 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 4B p: 40 pc: 0266 sp: FD x: 35 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 35 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 35 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 35 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 35 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 35 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 35 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4B p: 40 pc: 025B sp: FD x: 35 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4B p: C1 pc: 025D sp: FD x: 35 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4B p: C1 pc: 026C sp: FD x: 35 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 4B p: 40 pc: 026E sp: FD x: 35 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4B p: 40 pc: 0270 sp: FD x: 35 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4B p: 40 pc: 0259 sp: FD x: 35 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4B p: 40 pc: 025B sp: FD x: 35 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4B p: 40 pc: 025D sp: FD x: 35 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 4B p: 40 pc: 025F sp: FD x: 35 y: 04 
---
[1]    55 0261: 	sec
[2] a: 4B p: 40 pc: 0261 sp: FD x: 35 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4B p: 41 pc: 0262 sp: FD x: 35 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 1F p: 00 pc: 0264 sp: FD x: 35 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 1F p: 00 pc: 0266 sp: FD x: 35 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 35 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 35 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 35 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 35 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 35 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 35 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1F p: 00 pc: 025B sp: FD x: 35 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1F p: 00 pc: 025D sp: FD x: 35 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 1F p: 00 pc: 025F sp: FD x: 35 y: 04 
---
[1]    55 0261: 	sec
[2] a: 1F p: 00 pc: 0261 sp: FD x: 35 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1F p: 01 pc: 0262 sp: FD x: 35 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 09 p: 00 pc: 0264 sp: FD x: 35 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 09 p: 00 pc: 0266 sp: FD x: 35 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 35 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 35 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 35 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 35 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 35 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 35 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 09 p: 00 pc: 025B sp: FD x: 35 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 09 p: 81 pc: 025D sp: FD x: 35 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 09 p: 81 pc: 026C sp: FD x: 35 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 09 p: 01 pc: 026E sp: FD x: 35 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 09 p: 03 pc: 0270 sp: FD x: 35 y: 04 
---
[1]    64 0272: 	rts
[2] a: 09 p: 03 pc: 0272 sp: FD x: 35 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 09 p: 03 pc: 0220 sp: FF x: 35 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 09 p: 01 pc: 0222 sp: FF x: 35 y: 04 
---
[1]    24 0224: 	lda pstore, y
[2] a: 09 p: 01 pc: 0224 sp: FF x: 35 y: 04 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0B p: 01 pc: 0227 sp: FF x: 35 y: 04 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0B p: 81 pc: 0229 sp: FF x: 35 y: 04 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0B p: 81 pc: 022B sp: FF x: 35 y: 04 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0B p: 01 pc: 022C sp: FF x: 35 y: 05 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0B p: 01 pc: 0213 sp: FF x: 35 y: 05 
---
[1]    18 0216: 	sta dividend
[2] a: FB p: 81 pc: 0216 sp: FF x: 35 y: 05 
---
[1]    19 0218: 	lda pstore, y
[2] a: FB p: 81 pc: 0218 sp: FF x: 35 y: 05 
---
[1]    20 021B: 	sta divisor
[2] a: 0D p: 01 pc: 021B sp: FF x: 35 y: 05 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0D p: 01 pc: 021D sp: FF x: 35 y: 05 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0D p: 01 pc: 0244 sp: FD x: 35 y: 05 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 05 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 05 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 05 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0D p: 01 pc: 024E sp: FD x: 35 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0D p: 81 pc: 0250 sp: FD x: 35 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 0D p: 81 pc: 0252 sp: FD x: 35 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0D p: 00 pc: 0254 sp: FD x: 35 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1A p: 00 pc: 0255 sp: FD x: 35 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1A p: 00 pc: 024E sp: FD x: 35 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1A p: 81 pc: 0250 sp: FD x: 35 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 1A p: 81 pc: 0252 sp: FD x: 35 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1A p: 00 pc: 0254 sp: FD x: 35 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 34 p: 00 pc: 0255 sp: FD x: 35 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 34 p: 00 pc: 024E sp: FD x: 35 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 34 p: 81 pc: 0250 sp: FD x: 35 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 34 p: 81 pc: 0252 sp: FD x: 35 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 34 p: 00 pc: 0254 sp: FD x: 35 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 68 p: 00 pc: 0255 sp: FD x: 35 y: 05 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 68 p: 00 pc: 024E sp: FD x: 35 y: 05 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 68 p: 81 pc: 0250 sp: FD x: 35 y: 05 
---
[1]    47 0252: 	asl bitd
[2] a: 68 p: 81 pc: 0252 sp: FD x: 35 y: 05 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 68 p: 00 pc: 0254 sp: FD x: 35 y: 05 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: D0 p: 80 pc: 0255 sp: FD x: 35 y: 05 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: D0 p: 80 pc: 0257 sp: FD x: 35 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: D0 p: 80 pc: 0259 sp: FD x: 35 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: FB p: 80 pc: 025B sp: FD x: 35 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: FB p: 00 pc: 025D sp: FD x: 35 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: FB p: 00 pc: 025F sp: FD x: 35 y: 05 
---
[1]    55 0261: 	sec
[2] a: FB p: 80 pc: 0261 sp: FD x: 35 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: FB p: 81 pc: 0262 sp: FD x: 35 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 2B p: 00 pc: 0264 sp: FD x: 35 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 2B p: 00 pc: 0266 sp: FD x: 35 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 35 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 00 pc: 026A sp: FD x: 35 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 00 pc: 026C sp: FD x: 35 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 00 pc: 026E sp: FD x: 35 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 00 pc: 0270 sp: FD x: 35 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 00 pc: 0259 sp: FD x: 35 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 35 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 81 pc: 025D sp: FD x: 35 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 81 pc: 026C sp: FD x: 35 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 00 pc: 026E sp: FD x: 35 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 00 pc: 0270 sp: FD x: 35 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2B p: 00 pc: 0259 sp: FD x: 35 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 35 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 81 pc: 025D sp: FD x: 35 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 2B p: 81 pc: 026C sp: FD x: 35 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 2B p: 00 pc: 026E sp: FD x: 35 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 2B p: 00 pc: 0270 sp: FD x: 35 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 2B p: 00 pc: 0259 sp: FD x: 35 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2B p: 00 pc: 025B sp: FD x: 35 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2B p: 00 pc: 025D sp: FD x: 35 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 2B p: 00 pc: 025F sp: FD x: 35 y: 05 
---
[1]    55 0261: 	sec
[2] a: 2B p: 00 pc: 0261 sp: FD x: 35 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2B p: 01 pc: 0262 sp: FD x: 35 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 11 p: 00 pc: 0264 sp: FD x: 35 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 11 p: 00 pc: 0266 sp: FD x: 35 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 35 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 12 p: 00 pc: 026A sp: FD x: 35 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 12 p: 00 pc: 026C sp: FD x: 35 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 12 p: 00 pc: 026E sp: FD x: 35 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 12 p: 00 pc: 0270 sp: FD x: 35 y: 05 
---
[1]    51 0259: @1:	lda dividend
[2] a: 12 p: 00 pc: 0259 sp: FD x: 35 y: 05 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 11 p: 00 pc: 025B sp: FD x: 35 y: 05 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 11 p: 00 pc: 025D sp: FD x: 35 y: 05 
---
[1]    54 025F: 	lda dividend
[2] a: 11 p: 00 pc: 025F sp: FD x: 35 y: 05 
---
[1]    55 0261: 	sec
[2] a: 11 p: 00 pc: 0261 sp: FD x: 35 y: 05 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 11 p: 01 pc: 0262 sp: FD x: 35 y: 05 
---
[1]    57 0264: 	sta dividend
[2] a: 04 p: 00 pc: 0264 sp: FD x: 35 y: 05 
---
[1]    58 0266: 	lda quotient
[2] a: 04 p: 00 pc: 0266 sp: FD x: 35 y: 05 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 12 p: 00 pc: 0268 sp: FD x: 35 y: 05 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 13 p: 00 pc: 026A sp: FD x: 35 y: 05 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 13 p: 00 pc: 026C sp: FD x: 35 y: 05 
---
[1]    62 026E: 	lsr bitd
[2] a: 13 p: 01 pc: 026E sp: FD x: 35 y: 05 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 13 p: 03 pc: 0270 sp: FD x: 35 y: 05 
---
[1]    64 0272: 	rts
[2] a: 13 p: 03 pc: 0272 sp: FD x: 35 y: 05 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 13 p: 03 pc: 0220 sp: FF x: 35 y: 05 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 04 p: 01 pc: 0222 sp: FF x: 35 y: 05 
---
[1]    24 0224: 	lda pstore, y
[2] a: 04 p: 01 pc: 0224 sp: FF x: 35 y: 05 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 0D p: 01 pc: 0227 sp: FF x: 35 y: 05 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 0D p: 81 pc: 0229 sp: FF x: 35 y: 05 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 0D p: 81 pc: 022B sp: FF x: 35 y: 05 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 0D p: 01 pc: 022C sp: FF x: 35 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 0D p: 01 pc: 0213 sp: FF x: 35 y: 06 
---
[1]    18 0216: 	sta dividend
[2] a: FB p: 81 pc: 0216 sp: FF x: 35 y: 06 
---
[1]    19 0218: 	lda pstore, y
[2] a: FB p: 81 pc: 0218 sp: FF x: 35 y: 06 
---
[1]    20 021B: 	sta divisor
[2] a: 11 p: 01 pc: 021B sp: FF x: 35 y: 06 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 11 p: 01 pc: 021D sp: FF x: 35 y: 06 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 11 p: 01 pc: 0244 sp: FD x: 35 y: 06 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 35 y: 06 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 35 y: 06 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 35 y: 06 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 35 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 11 p: 01 pc: 024E sp: FD x: 35 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 11 p: 81 pc: 0250 sp: FD x: 35 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 11 p: 81 pc: 0252 sp: FD x: 35 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 11 p: 00 pc: 0254 sp: FD x: 35 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 22 p: 00 pc: 0255 sp: FD x: 35 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 22 p: 00 pc: 024E sp: FD x: 35 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 22 p: 81 pc: 0250 sp: FD x: 35 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 22 p: 81 pc: 0252 sp: FD x: 35 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 22 p: 00 pc: 0254 sp: FD x: 35 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 44 p: 00 pc: 0255 sp: FD x: 35 y: 06 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 44 p: 00 pc: 024E sp: FD x: 35 y: 06 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 44 p: 81 pc: 0250 sp: FD x: 35 y: 06 
---
[1]    47 0252: 	asl bitd
[2] a: 44 p: 81 pc: 0252 sp: FD x: 35 y: 06 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 44 p: 00 pc: 0254 sp: FD x: 35 y: 06 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 88 p: 80 pc: 0255 sp: FD x: 35 y: 06 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: 88 p: 80 pc: 0257 sp: FD x: 35 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 88 p: 80 pc: 0259 sp: FD x: 35 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: FB p: 80 pc: 025B sp: FD x: 35 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: FB p: 00 pc: 025D sp: FD x: 35 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: FB p: 00 pc: 025F sp: FD x: 35 y: 06 
---
[1]    55 0261: 	sec
[2] a: FB p: 80 pc: 0261 sp: FD x: 35 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: FB p: 81 pc: 0262 sp: FD x: 35 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 73 p: 40 pc: 0264 sp: FD x: 35 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 73 p: 40 pc: 0266 sp: FD x: 35 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 35 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 08 p: 40 pc: 026A sp: FD x: 35 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 08 p: 40 pc: 026C sp: FD x: 35 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 08 p: 40 pc: 026E sp: FD x: 35 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 08 p: 40 pc: 0270 sp: FD x: 35 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 08 p: 40 pc: 0259 sp: FD x: 35 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 73 p: 40 pc: 025B sp: FD x: 35 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 73 p: 40 pc: 025D sp: FD x: 35 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 73 p: 40 pc: 025F sp: FD x: 35 y: 06 
---
[1]    55 0261: 	sec
[2] a: 73 p: 40 pc: 0261 sp: FD x: 35 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 73 p: 41 pc: 0262 sp: FD x: 35 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 2F p: 00 pc: 0264 sp: FD x: 35 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 2F p: 00 pc: 0266 sp: FD x: 35 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 08 p: 00 pc: 0268 sp: FD x: 35 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0C p: 00 pc: 026A sp: FD x: 35 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0C p: 00 pc: 026C sp: FD x: 35 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0C p: 00 pc: 026E sp: FD x: 35 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0C p: 00 pc: 0270 sp: FD x: 35 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0C p: 00 pc: 0259 sp: FD x: 35 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 2F p: 00 pc: 025B sp: FD x: 35 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 2F p: 00 pc: 025D sp: FD x: 35 y: 06 
---
[1]    54 025F: 	lda dividend
[2] a: 2F p: 00 pc: 025F sp: FD x: 35 y: 06 
---
[1]    55 0261: 	sec
[2] a: 2F p: 00 pc: 0261 sp: FD x: 35 y: 06 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 2F p: 01 pc: 0262 sp: FD x: 35 y: 06 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 35 y: 06 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 35 y: 06 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 0C p: 00 pc: 0268 sp: FD x: 35 y: 06 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 0E p: 00 pc: 026A sp: FD x: 35 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0E p: 00 pc: 026C sp: FD x: 35 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0E p: 00 pc: 026E sp: FD x: 35 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0E p: 00 pc: 0270 sp: FD x: 35 y: 06 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0E p: 00 pc: 0259 sp: FD x: 35 y: 06 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 35 y: 06 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 35 y: 06 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 35 y: 06 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 01 pc: 026E sp: FD x: 35 y: 06 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 03 pc: 0270 sp: FD x: 35 y: 06 
---
[1]    64 0272: 	rts
[2] a: 0D p: 03 pc: 0272 sp: FD x: 35 y: 06 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 0D p: 03 pc: 0220 sp: FF x: 35 y: 06 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 0D p: 01 pc: 0222 sp: FF x: 35 y: 06 
---
[1]    24 0224: 	lda pstore, y
[2] a: 0D p: 01 pc: 0224 sp: FF x: 35 y: 06 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 11 p: 01 pc: 0227 sp: FF x: 35 y: 06 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 11 p: 00 pc: 0229 sp: FF x: 35 y: 06 
---
[1]    29 022E: found:	lda pstore, x		; get new prime
[2] a: 11 p: 00 pc: 022E sp: FF x: 35 y: 06 
---
[1]    30 0231: 	inx			; advance to new prime location
[2] a: FB p: 80 pc: 0231 sp: FF x: 35 y: 06 
---
[1]    31 0232: 	sta pstore, x		; put last prime+2 for next prime candidate
[2] a: FB p: 00 pc: 0232 sp: FF x: 36 y: 06 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: FB p: 00 pc: 0235 sp: FF x: 36 y: 06 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: FB p: 80 pc: 0238 sp: FF x: 36 y: 06 
---
[1]    34 023B: 	lda pstore, x
[2] a: FB p: 80 pc: 023B sp: FF x: 36 y: 06 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: FD p: 80 pc: 023E sp: FF x: 36 y: 06 
---
[1]    36 0240: 	bmi checkp
[2] a: FD p: 81 pc: 0240 sp: FF x: 36 y: 06 
---
[1]    16 0211: checkp:	ldy #1			; start at 2nd prime (skip 2)
[2] a: FD p: 81 pc: 0211 sp: FF x: 36 y: 06 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: FD p: 01 pc: 0213 sp: FF x: 36 y: 01 
---
[1]    18 0216: 	sta dividend
[2] a: FD p: 81 pc: 0216 sp: FF x: 36 y: 01 
---
[1]    19 0218: 	lda pstore, y
[2] a: FD p: 81 pc: 0218 sp: FF x: 36 y: 01 
---
[1]    20 021B: 	sta divisor
[2] a: 03 p: 01 pc: 021B sp: FF x: 36 y: 01 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 03 p: 01 pc: 021D sp: FF x: 36 y: 01 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 03 p: 01 pc: 0244 sp: FD x: 36 y: 01 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 36 y: 01 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 36 y: 01 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 36 y: 01 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 36 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 03 p: 01 pc: 024E sp: FD x: 36 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 03 p: 81 pc: 0250 sp: FD x: 36 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 03 p: 81 pc: 0252 sp: FD x: 36 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 03 p: 00 pc: 0254 sp: FD x: 36 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 06 p: 00 pc: 0255 sp: FD x: 36 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 06 p: 00 pc: 024E sp: FD x: 36 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 06 p: 81 pc: 0250 sp: FD x: 36 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 06 p: 81 pc: 0252 sp: FD x: 36 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 06 p: 00 pc: 0254 sp: FD x: 36 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0C p: 00 pc: 0255 sp: FD x: 36 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0C p: 00 pc: 024E sp: FD x: 36 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0C p: 81 pc: 0250 sp: FD x: 36 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 0C p: 81 pc: 0252 sp: FD x: 36 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0C p: 00 pc: 0254 sp: FD x: 36 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 18 p: 00 pc: 0255 sp: FD x: 36 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 18 p: 00 pc: 024E sp: FD x: 36 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 18 p: 81 pc: 0250 sp: FD x: 36 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 18 p: 81 pc: 0252 sp: FD x: 36 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 18 p: 00 pc: 0254 sp: FD x: 36 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 30 p: 00 pc: 0255 sp: FD x: 36 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 30 p: 00 pc: 024E sp: FD x: 36 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 30 p: 81 pc: 0250 sp: FD x: 36 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 30 p: 81 pc: 0252 sp: FD x: 36 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 30 p: 00 pc: 0254 sp: FD x: 36 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 60 p: 00 pc: 0255 sp: FD x: 36 y: 01 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 60 p: 00 pc: 024E sp: FD x: 36 y: 01 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 60 p: 81 pc: 0250 sp: FD x: 36 y: 01 
---
[1]    47 0252: 	asl bitd
[2] a: 60 p: 81 pc: 0252 sp: FD x: 36 y: 01 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 60 p: 00 pc: 0254 sp: FD x: 36 y: 01 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: C0 p: 80 pc: 0255 sp: FD x: 36 y: 01 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: C0 p: 80 pc: 0257 sp: FD x: 36 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: C0 p: 80 pc: 0259 sp: FD x: 36 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: FD p: 80 pc: 025B sp: FD x: 36 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: FD p: 00 pc: 025D sp: FD x: 36 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: FD p: 00 pc: 025F sp: FD x: 36 y: 01 
---
[1]    55 0261: 	sec
[2] a: FD p: 80 pc: 0261 sp: FD x: 36 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: FD p: 81 pc: 0262 sp: FD x: 36 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 3D p: 00 pc: 0264 sp: FD x: 36 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 3D p: 00 pc: 0266 sp: FD x: 36 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 36 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 40 p: 00 pc: 026A sp: FD x: 36 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 40 p: 00 pc: 026C sp: FD x: 36 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 40 p: 00 pc: 026E sp: FD x: 36 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 40 p: 00 pc: 0270 sp: FD x: 36 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 40 p: 00 pc: 0259 sp: FD x: 36 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 36 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 81 pc: 025D sp: FD x: 36 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 3D p: 81 pc: 026C sp: FD x: 36 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 3D p: 00 pc: 026E sp: FD x: 36 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 3D p: 00 pc: 0270 sp: FD x: 36 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 3D p: 00 pc: 0259 sp: FD x: 36 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 3D p: 00 pc: 025B sp: FD x: 36 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 3D p: 00 pc: 025D sp: FD x: 36 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 3D p: 00 pc: 025F sp: FD x: 36 y: 01 
---
[1]    55 0261: 	sec
[2] a: 3D p: 00 pc: 0261 sp: FD x: 36 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 3D p: 01 pc: 0262 sp: FD x: 36 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 36 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 36 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 40 p: 00 pc: 0268 sp: FD x: 36 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 50 p: 00 pc: 026A sp: FD x: 36 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 50 p: 00 pc: 026C sp: FD x: 36 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 50 p: 00 pc: 026E sp: FD x: 36 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 50 p: 00 pc: 0270 sp: FD x: 36 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 50 p: 00 pc: 0259 sp: FD x: 36 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 36 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 36 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 36 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 36 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 36 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 36 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 36 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 36 y: 01 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 36 y: 01 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 36 y: 01 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 36 y: 01 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 36 y: 01 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 36 y: 01 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 50 p: 00 pc: 0268 sp: FD x: 36 y: 01 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 54 p: 00 pc: 026A sp: FD x: 36 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 54 p: 00 pc: 026C sp: FD x: 36 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 54 p: 00 pc: 026E sp: FD x: 36 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 54 p: 00 pc: 0270 sp: FD x: 36 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 54 p: 00 pc: 0259 sp: FD x: 36 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 36 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 36 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 36 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 36 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 36 y: 01 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 36 y: 01 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 36 y: 01 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 36 y: 01 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 36 y: 01 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 36 y: 01 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 36 y: 01 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 36 y: 01 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 36 y: 01 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 36 y: 01 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 36 y: 01 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 03 p: 01 pc: 0227 sp: FF x: 36 y: 01 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 03 p: 81 pc: 0229 sp: FF x: 36 y: 01 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 03 p: 81 pc: 022B sp: FF x: 36 y: 01 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 03 p: 01 pc: 022C sp: FF x: 36 y: 02 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 03 p: 01 pc: 0213 sp: FF x: 36 y: 02 
---
[1]    18 0216: 	sta dividend
[2] a: FD p: 81 pc: 0216 sp: FF x: 36 y: 02 
---
[1]    19 0218: 	lda pstore, y
[2] a: FD p: 81 pc: 0218 sp: FF x: 36 y: 02 
---
[1]    20 021B: 	sta divisor
[2] a: 05 p: 01 pc: 021B sp: FF x: 36 y: 02 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 05 p: 01 pc: 021D sp: FF x: 36 y: 02 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 05 p: 01 pc: 0244 sp: FD x: 36 y: 02 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 36 y: 02 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 36 y: 02 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 36 y: 02 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 36 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 05 p: 01 pc: 024E sp: FD x: 36 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 05 p: 81 pc: 0250 sp: FD x: 36 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 05 p: 81 pc: 0252 sp: FD x: 36 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 05 p: 00 pc: 0254 sp: FD x: 36 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0A p: 00 pc: 0255 sp: FD x: 36 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0A p: 00 pc: 024E sp: FD x: 36 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0A p: 81 pc: 0250 sp: FD x: 36 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 0A p: 81 pc: 0252 sp: FD x: 36 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0A p: 00 pc: 0254 sp: FD x: 36 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 14 p: 00 pc: 0255 sp: FD x: 36 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 14 p: 00 pc: 024E sp: FD x: 36 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 14 p: 81 pc: 0250 sp: FD x: 36 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 14 p: 81 pc: 0252 sp: FD x: 36 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 14 p: 00 pc: 0254 sp: FD x: 36 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 28 p: 00 pc: 0255 sp: FD x: 36 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 28 p: 00 pc: 024E sp: FD x: 36 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 28 p: 81 pc: 0250 sp: FD x: 36 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 28 p: 81 pc: 0252 sp: FD x: 36 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 28 p: 00 pc: 0254 sp: FD x: 36 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 50 p: 00 pc: 0255 sp: FD x: 36 y: 02 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 50 p: 00 pc: 024E sp: FD x: 36 y: 02 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 50 p: 81 pc: 0250 sp: FD x: 36 y: 02 
---
[1]    47 0252: 	asl bitd
[2] a: 50 p: 81 pc: 0252 sp: FD x: 36 y: 02 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 50 p: 00 pc: 0254 sp: FD x: 36 y: 02 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: A0 p: 80 pc: 0255 sp: FD x: 36 y: 02 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: A0 p: 80 pc: 0257 sp: FD x: 36 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: A0 p: 80 pc: 0259 sp: FD x: 36 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: FD p: 80 pc: 025B sp: FD x: 36 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: FD p: 00 pc: 025D sp: FD x: 36 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: FD p: 00 pc: 025F sp: FD x: 36 y: 02 
---
[1]    55 0261: 	sec
[2] a: FD p: 80 pc: 0261 sp: FD x: 36 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: FD p: 81 pc: 0262 sp: FD x: 36 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 5D p: 40 pc: 0264 sp: FD x: 36 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 5D p: 40 pc: 0266 sp: FD x: 36 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 36 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 40 pc: 026A sp: FD x: 36 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 40 pc: 026C sp: FD x: 36 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 40 pc: 026E sp: FD x: 36 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 40 pc: 0270 sp: FD x: 36 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 40 pc: 0259 sp: FD x: 36 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 5D p: 40 pc: 025B sp: FD x: 36 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 5D p: 40 pc: 025D sp: FD x: 36 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 5D p: 40 pc: 025F sp: FD x: 36 y: 02 
---
[1]    55 0261: 	sec
[2] a: 5D p: 40 pc: 0261 sp: FD x: 36 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 5D p: 41 pc: 0262 sp: FD x: 36 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 0D p: 00 pc: 0264 sp: FD x: 36 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 0D p: 00 pc: 0266 sp: FD x: 36 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 36 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 30 p: 00 pc: 026A sp: FD x: 36 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 30 p: 00 pc: 026C sp: FD x: 36 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 30 p: 00 pc: 026E sp: FD x: 36 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 30 p: 00 pc: 0270 sp: FD x: 36 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 30 p: 00 pc: 0259 sp: FD x: 36 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 36 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 36 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 36 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 36 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 36 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 36 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 36 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 81 pc: 025D sp: FD x: 36 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 0D p: 81 pc: 026C sp: FD x: 36 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 0D p: 00 pc: 026E sp: FD x: 36 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 0D p: 00 pc: 0270 sp: FD x: 36 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 0D p: 00 pc: 0259 sp: FD x: 36 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0D p: 00 pc: 025B sp: FD x: 36 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0D p: 00 pc: 025D sp: FD x: 36 y: 02 
---
[1]    54 025F: 	lda dividend
[2] a: 0D p: 00 pc: 025F sp: FD x: 36 y: 02 
---
[1]    55 0261: 	sec
[2] a: 0D p: 00 pc: 0261 sp: FD x: 36 y: 02 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0D p: 01 pc: 0262 sp: FD x: 36 y: 02 
---
[1]    57 0264: 	sta dividend
[2] a: 03 p: 00 pc: 0264 sp: FD x: 36 y: 02 
---
[1]    58 0266: 	lda quotient
[2] a: 03 p: 00 pc: 0266 sp: FD x: 36 y: 02 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 30 p: 00 pc: 0268 sp: FD x: 36 y: 02 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 32 p: 00 pc: 026A sp: FD x: 36 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 32 p: 00 pc: 026C sp: FD x: 36 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 32 p: 00 pc: 026E sp: FD x: 36 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 32 p: 00 pc: 0270 sp: FD x: 36 y: 02 
---
[1]    51 0259: @1:	lda dividend
[2] a: 32 p: 00 pc: 0259 sp: FD x: 36 y: 02 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 03 p: 00 pc: 025B sp: FD x: 36 y: 02 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 03 p: 81 pc: 025D sp: FD x: 36 y: 02 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 03 p: 81 pc: 026C sp: FD x: 36 y: 02 
---
[1]    62 026E: 	lsr bitd
[2] a: 03 p: 01 pc: 026E sp: FD x: 36 y: 02 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 03 p: 03 pc: 0270 sp: FD x: 36 y: 02 
---
[1]    64 0272: 	rts
[2] a: 03 p: 03 pc: 0272 sp: FD x: 36 y: 02 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 03 p: 03 pc: 0220 sp: FF x: 36 y: 02 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 03 p: 01 pc: 0222 sp: FF x: 36 y: 02 
---
[1]    24 0224: 	lda pstore, y
[2] a: 03 p: 01 pc: 0224 sp: FF x: 36 y: 02 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 05 p: 01 pc: 0227 sp: FF x: 36 y: 02 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 05 p: 81 pc: 0229 sp: FF x: 36 y: 02 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 05 p: 81 pc: 022B sp: FF x: 36 y: 02 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 05 p: 01 pc: 022C sp: FF x: 36 y: 03 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 05 p: 01 pc: 0213 sp: FF x: 36 y: 03 
---
[1]    18 0216: 	sta dividend
[2] a: FD p: 81 pc: 0216 sp: FF x: 36 y: 03 
---
[1]    19 0218: 	lda pstore, y
[2] a: FD p: 81 pc: 0218 sp: FF x: 36 y: 03 
---
[1]    20 021B: 	sta divisor
[2] a: 07 p: 01 pc: 021B sp: FF x: 36 y: 03 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 07 p: 01 pc: 021D sp: FF x: 36 y: 03 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 07 p: 01 pc: 0244 sp: FD x: 36 y: 03 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 36 y: 03 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 36 y: 03 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 36 y: 03 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 36 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 07 p: 01 pc: 024E sp: FD x: 36 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 07 p: 81 pc: 0250 sp: FD x: 36 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 07 p: 81 pc: 0252 sp: FD x: 36 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 07 p: 00 pc: 0254 sp: FD x: 36 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 0E p: 00 pc: 0255 sp: FD x: 36 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0E p: 00 pc: 024E sp: FD x: 36 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0E p: 81 pc: 0250 sp: FD x: 36 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 0E p: 81 pc: 0252 sp: FD x: 36 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0E p: 00 pc: 0254 sp: FD x: 36 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 1C p: 00 pc: 0255 sp: FD x: 36 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 1C p: 00 pc: 024E sp: FD x: 36 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 1C p: 81 pc: 0250 sp: FD x: 36 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 1C p: 81 pc: 0252 sp: FD x: 36 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 1C p: 00 pc: 0254 sp: FD x: 36 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 38 p: 00 pc: 0255 sp: FD x: 36 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 38 p: 00 pc: 024E sp: FD x: 36 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 38 p: 81 pc: 0250 sp: FD x: 36 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 38 p: 81 pc: 0252 sp: FD x: 36 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 38 p: 00 pc: 0254 sp: FD x: 36 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 70 p: 00 pc: 0255 sp: FD x: 36 y: 03 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 70 p: 00 pc: 024E sp: FD x: 36 y: 03 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 70 p: 81 pc: 0250 sp: FD x: 36 y: 03 
---
[1]    47 0252: 	asl bitd
[2] a: 70 p: 81 pc: 0252 sp: FD x: 36 y: 03 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 70 p: 00 pc: 0254 sp: FD x: 36 y: 03 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: E0 p: 80 pc: 0255 sp: FD x: 36 y: 03 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: E0 p: 80 pc: 0257 sp: FD x: 36 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: E0 p: 80 pc: 0259 sp: FD x: 36 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: FD p: 80 pc: 025B sp: FD x: 36 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: FD p: 00 pc: 025D sp: FD x: 36 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: FD p: 00 pc: 025F sp: FD x: 36 y: 03 
---
[1]    55 0261: 	sec
[2] a: FD p: 80 pc: 0261 sp: FD x: 36 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: FD p: 81 pc: 0262 sp: FD x: 36 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 1D p: 00 pc: 0264 sp: FD x: 36 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 1D p: 00 pc: 0266 sp: FD x: 36 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 02 pc: 0268 sp: FD x: 36 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 20 p: 00 pc: 026A sp: FD x: 36 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 20 p: 00 pc: 026C sp: FD x: 36 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 20 p: 00 pc: 026E sp: FD x: 36 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 20 p: 00 pc: 0270 sp: FD x: 36 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 20 p: 00 pc: 0259 sp: FD x: 36 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 36 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 81 pc: 025D sp: FD x: 36 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 81 pc: 026C sp: FD x: 36 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 00 pc: 026E sp: FD x: 36 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 00 pc: 0270 sp: FD x: 36 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1D p: 00 pc: 0259 sp: FD x: 36 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 36 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 81 pc: 025D sp: FD x: 36 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 1D p: 81 pc: 026C sp: FD x: 36 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 1D p: 00 pc: 026E sp: FD x: 36 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 1D p: 00 pc: 0270 sp: FD x: 36 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 1D p: 00 pc: 0259 sp: FD x: 36 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 1D p: 00 pc: 025B sp: FD x: 36 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 1D p: 00 pc: 025D sp: FD x: 36 y: 03 
---
[1]    54 025F: 	lda dividend
[2] a: 1D p: 00 pc: 025F sp: FD x: 36 y: 03 
---
[1]    55 0261: 	sec
[2] a: 1D p: 00 pc: 0261 sp: FD x: 36 y: 03 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 1D p: 01 pc: 0262 sp: FD x: 36 y: 03 
---
[1]    57 0264: 	sta dividend
[2] a: 01 p: 00 pc: 0264 sp: FD x: 36 y: 03 
---
[1]    58 0266: 	lda quotient
[2] a: 01 p: 00 pc: 0266 sp: FD x: 36 y: 03 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 20 p: 00 pc: 0268 sp: FD x: 36 y: 03 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 24 p: 00 pc: 026A sp: FD x: 36 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 24 p: 00 pc: 026C sp: FD x: 36 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 24 p: 00 pc: 026E sp: FD x: 36 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 24 p: 00 pc: 0270 sp: FD x: 36 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 24 p: 00 pc: 0259 sp: FD x: 36 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 36 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 36 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 36 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 00 pc: 026E sp: FD x: 36 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 00 pc: 0270 sp: FD x: 36 y: 03 
---
[1]    51 0259: @1:	lda dividend
[2] a: 01 p: 00 pc: 0259 sp: FD x: 36 y: 03 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 01 p: 00 pc: 025B sp: FD x: 36 y: 03 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 01 p: 81 pc: 025D sp: FD x: 36 y: 03 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 01 p: 81 pc: 026C sp: FD x: 36 y: 03 
---
[1]    62 026E: 	lsr bitd
[2] a: 01 p: 01 pc: 026E sp: FD x: 36 y: 03 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 01 p: 03 pc: 0270 sp: FD x: 36 y: 03 
---
[1]    64 0272: 	rts
[2] a: 01 p: 03 pc: 0272 sp: FD x: 36 y: 03 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 01 p: 03 pc: 0220 sp: FF x: 36 y: 03 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 01 p: 01 pc: 0222 sp: FF x: 36 y: 03 
---
[1]    24 0224: 	lda pstore, y
[2] a: 01 p: 01 pc: 0224 sp: FF x: 36 y: 03 
---
[1]    25 0227: 	cmp quotient		; was test prime/prime factor <= prime factor
[2] a: 07 p: 01 pc: 0227 sp: FF x: 36 y: 03 
---
[1]    26 0229: 	bpl found		; if yes, number is prime
[2] a: 07 p: 81 pc: 0229 sp: FF x: 36 y: 03 
---
[1]    27 022B: 	iny			; next prime factor
[2] a: 07 p: 81 pc: 022B sp: FF x: 36 y: 03 
---
[1]    28 022C: 	bne divp		; divide next prime factor
[2] a: 07 p: 01 pc: 022C sp: FF x: 36 y: 04 
---
[1]    17 0213: divp:	lda pstore, x
[2] a: 07 p: 01 pc: 0213 sp: FF x: 36 y: 04 
---
[1]    18 0216: 	sta dividend
[2] a: FD p: 81 pc: 0216 sp: FF x: 36 y: 04 
---
[1]    19 0218: 	lda pstore, y
[2] a: FD p: 81 pc: 0218 sp: FF x: 36 y: 04 
---
[1]    20 021B: 	sta divisor
[2] a: 0B p: 01 pc: 021B sp: FF x: 36 y: 04 
---
[1]    21 021D: 	jsr div8		; divide test prime by prime factor
[2] a: 0B p: 01 pc: 021D sp: FF x: 36 y: 04 
---
[1]    40 0244: div8:	lda #1			; start dividing pstore,x/pstore,y
[2] a: 0B p: 01 pc: 0244 sp: FD x: 36 y: 04 
---
[1]    41 0246: 	sta bitd		; start at bit 1
[2] a: 01 p: 01 pc: 0246 sp: FD x: 36 y: 04 
---
[1]    42 0248: 	lda #0
[2] a: 01 p: 01 pc: 0248 sp: FD x: 36 y: 04 
---
[1]    43 024A: 	sta quotient		; clear quotient
[2] a: 00 p: 03 pc: 024A sp: FD x: 36 y: 04 
---
[1]    44 024C: 	lda divisor		; get divisor in a
[2] a: 00 p: 03 pc: 024C sp: FD x: 36 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 0B p: 01 pc: 024E sp: FD x: 36 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 0B p: 81 pc: 0250 sp: FD x: 36 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 0B p: 81 pc: 0252 sp: FD x: 36 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 0B p: 00 pc: 0254 sp: FD x: 36 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 16 p: 00 pc: 0255 sp: FD x: 36 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 16 p: 00 pc: 024E sp: FD x: 36 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 16 p: 81 pc: 0250 sp: FD x: 36 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 16 p: 81 pc: 0252 sp: FD x: 36 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 16 p: 00 pc: 0254 sp: FD x: 36 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 2C p: 00 pc: 0255 sp: FD x: 36 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 2C p: 00 pc: 024E sp: FD x: 36 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 2C p: 81 pc: 0250 sp: FD x: 36 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 2C p: 81 pc: 0252 sp: FD x: 36 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 2C p: 00 pc: 0254 sp: FD x: 36 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: 58 p: 00 pc: 0255 sp: FD x: 36 y: 04 
---
[1]    45 024E: @1:	cmp dividend		; compare to dividend
[2] a: 58 p: 00 pc: 024E sp: FD x: 36 y: 04 
---
[1]    46 0250: 	bpl startd		; if shift divisor>dividend, start div
[2] a: 58 p: 81 pc: 0250 sp: FD x: 36 y: 04 
---
[1]    47 0252: 	asl bitd
[2] a: 58 p: 81 pc: 0252 sp: FD x: 36 y: 04 
---
[1]    48 0254: 	asl a			; shift bit and divisor left
[2] a: 58 p: 00 pc: 0254 sp: FD x: 36 y: 04 
---
[1]    49 0255: 	bpl @1			; until divisor>dividend or divisor>7fh
[2] a: B0 p: 80 pc: 0255 sp: FD x: 36 y: 04 
---
[1]    50 0257: startd:	sta divisor		; save divisor
[2] a: B0 p: 80 pc: 0257 sp: FD x: 36 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: B0 p: 80 pc: 0259 sp: FD x: 36 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: FD p: 80 pc: 025B sp: FD x: 36 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: FD p: 00 pc: 025D sp: FD x: 36 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: FD p: 00 pc: 025F sp: FD x: 36 y: 04 
---
[1]    55 0261: 	sec
[2] a: FD p: 80 pc: 0261 sp: FD x: 36 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: FD p: 81 pc: 0262 sp: FD x: 36 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 4D p: 40 pc: 0264 sp: FD x: 36 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 4D p: 40 pc: 0266 sp: FD x: 36 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 00 p: 42 pc: 0268 sp: FD x: 36 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 10 p: 40 pc: 026A sp: FD x: 36 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 10 p: 40 pc: 026C sp: FD x: 36 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 10 p: 40 pc: 026E sp: FD x: 36 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 10 p: 40 pc: 0270 sp: FD x: 36 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 10 p: 40 pc: 0259 sp: FD x: 36 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4D p: 40 pc: 025B sp: FD x: 36 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4D p: C1 pc: 025D sp: FD x: 36 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 4D p: C1 pc: 026C sp: FD x: 36 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 4D p: 40 pc: 026E sp: FD x: 36 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 4D p: 40 pc: 0270 sp: FD x: 36 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 4D p: 40 pc: 0259 sp: FD x: 36 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 4D p: 40 pc: 025B sp: FD x: 36 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 4D p: 40 pc: 025D sp: FD x: 36 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 4D p: 40 pc: 025F sp: FD x: 36 y: 04 
---
[1]    55 0261: 	sec
[2] a: 4D p: 40 pc: 0261 sp: FD x: 36 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 4D p: 41 pc: 0262 sp: FD x: 36 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 21 p: 00 pc: 0264 sp: FD x: 36 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 21 p: 00 pc: 0266 sp: FD x: 36 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 10 p: 00 pc: 0268 sp: FD x: 36 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 14 p: 00 pc: 026A sp: FD x: 36 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 14 p: 00 pc: 026C sp: FD x: 36 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 14 p: 00 pc: 026E sp: FD x: 36 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 14 p: 00 pc: 0270 sp: FD x: 36 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 14 p: 00 pc: 0259 sp: FD x: 36 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 21 p: 00 pc: 025B sp: FD x: 36 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 21 p: 00 pc: 025D sp: FD x: 36 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 21 p: 00 pc: 025F sp: FD x: 36 y: 04 
---
[1]    55 0261: 	sec
[2] a: 21 p: 00 pc: 0261 sp: FD x: 36 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 21 p: 01 pc: 0262 sp: FD x: 36 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 0B p: 00 pc: 0264 sp: FD x: 36 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 0B p: 00 pc: 0266 sp: FD x: 36 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 14 p: 00 pc: 0268 sp: FD x: 36 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 16 p: 00 pc: 026A sp: FD x: 36 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 16 p: 00 pc: 026C sp: FD x: 36 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 16 p: 00 pc: 026E sp: FD x: 36 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 16 p: 00 pc: 0270 sp: FD x: 36 y: 04 
---
[1]    51 0259: @1:	lda dividend
[2] a: 16 p: 00 pc: 0259 sp: FD x: 36 y: 04 
---
[1]    52 025B: 	cmp divisor		; dividend > divisor
[2] a: 0B p: 00 pc: 025B sp: FD x: 36 y: 04 
---
[1]    53 025D: 	bmi nxtbit		; no, don't subtract, but get next bit
[2] a: 0B p: 02 pc: 025D sp: FD x: 36 y: 04 
---
[1]    54 025F: 	lda dividend
[2] a: 0B p: 02 pc: 025F sp: FD x: 36 y: 04 
---
[1]    55 0261: 	sec
[2] a: 0B p: 00 pc: 0261 sp: FD x: 36 y: 04 
---
[1]    56 0262: 	sbc divisor		; subtract divisor from dividend
[2] a: 0B p: 01 pc: 0262 sp: FD x: 36 y: 04 
---
[1]    57 0264: 	sta dividend
[2] a: 00 p: 02 pc: 0264 sp: FD x: 36 y: 04 
---
[1]    58 0266: 	lda quotient
[2] a: 00 p: 02 pc: 0266 sp: FD x: 36 y: 04 
---
[1]    59 0268: 	ora bitd		; if we subtrct divisor, set corresponding
[2] a: 16 p: 00 pc: 0268 sp: FD x: 36 y: 04 
---
[1]    60 026A: 	sta quotient		; bit of quotient
[2] a: 17 p: 00 pc: 026A sp: FD x: 36 y: 04 
---
[1]    61 026C: nxtbit:	lsr divisor		; next rightmost bit
[2] a: 17 p: 00 pc: 026C sp: FD x: 36 y: 04 
---
[1]    62 026E: 	lsr bitd
[2] a: 17 p: 01 pc: 026E sp: FD x: 36 y: 04 
---
[1]    63 0270: 	bne @1			; done all bit? if no, continue
[2] a: 17 p: 03 pc: 0270 sp: FD x: 36 y: 04 
---
[1]    64 0272: 	rts
[2] a: 17 p: 03 pc: 0272 sp: FD x: 36 y: 04 
---
[1]    22 0220: 	lda dividend		; yes, look at remainder
[2] a: 17 p: 03 pc: 0220 sp: FF x: 36 y: 04 
---
[1]    23 0222: 	beq nextp		; if remainder zero, this number is not prime
[2] a: 00 p: 03 pc: 0222 sp: FF x: 36 y: 04 
---
[1]    32 0235: nextp:	inc pstore, x
[2] a: 00 p: 03 pc: 0235 sp: FF x: 36 y: 04 
---
[1]    33 0238: 	inc pstore, x		;  new prime candidate
[2] a: 00 p: 81 pc: 0238 sp: FF x: 36 y: 04 
---
[1]    34 023B: 	lda pstore, x
[2] a: 00 p: 81 pc: 023B sp: FF x: 36 y: 04 
---
[1]    35 023E: 	cmp #0ffh		; don't go past 255
[2] a: FF p: 81 pc: 023E sp: FF x: 36 y: 04 
---
[1]    36 0240: 	bmi checkp
[2] a: FF p: 02 pc: 0240 sp: FF x: 36 y: 04 
---
[1]    37 0242: 	txa			; put number of prime in accumulator
[2] a: FF p: 02 pc: 0242 sp: FF x: 36 y: 04 
---
[1]    38 0243: done:	rts
[2] a: 36 p: 00 pc: 0243 sp: FF x: 36 y: 04 
Break at line 38
> 0300:  02 03 05 07 0B 0D 11 13 17 1D 1F 25 29 2B 2F 35
0310:  3B 3D 43 47 49 4F 53 59 61 65 67 6B 6D 71 7F 83
0320:  89 8B 95 97 9D A3 A7 AD B3 B5 BF C1 C5 C7 D3 DF
0330:  E3 E5 E9 EF F1 FB
> Quit simulator (yes or no)? 